<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>A short-term study schedule</title>
    <url>/2025/04/28/A-short-term-study-schedule/</url>
    <content><![CDATA[<p>在这段时间的学习中，我决定进行更细致的规划。目前，我打算从这三个方面入手：</p>
<ul>
<li>Computer Vision</li>
<li>Data Structures</li>
<li>Embodied AI</li>
</ul>
<p>对于前两个而言，我购入了两本书。一本是动手学计算机视觉，一本是王道的数据结构。那么，要学习这两个方向，我需要认真细致地阅读，并辅以配套的视频资源。最好能做好学习笔记，以 <code>.md</code> 的形式记录下来。</p>
<p>对于第三个而言，具身智能的概念太过于宽泛，难以整合学习资源。在网上查阅资料之后，我打算参照<a href="https://zhuanlan.zhihu.com/p/682978828">东林钟声的知乎专栏</a>中给出的路线进行学习：</p>
<p><strong>1.Robotics</strong></p>
<ul>
<li>至少需要掌握<strong>D-H参数、正逆运动学、雅克比矩阵、动力学、轨迹规划、跟踪控制</strong>等。可以参考《<a href="https://hades.mech.northwestern.edu/index.php/Modern_Robotics">Modern Robotics</a>》</li>
</ul>
<p><strong>2.基础模型</strong></p>
<ul>
<li><p>了解一些深度学习模型，需搞清楚 <code>Transformer</code> 和 <code>Diffusion Layer</code>。</p>
</li>
<li><p>可以按照如下的学习路线：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MLP -&gt; RNN -&gt; Transformer -&gt; Stable Diffusion</span><br></pre></td></tr></table></figure>
<p>可以参考李沐的《动手学深度学习》和他在B站上的视频。</p>
</li>
<li><p>学习完 <code>Transformer</code> 之后，可以了解一下 <code>LLM</code> 和 <code>VLM</code> 背后的原理，比如阅读相关论文。</p>
</li>
</ul>
<p><strong>3.强化学习</strong></p>
<ul>
<li>对我而言，之前 RL 涉及的不是很多。主要需要搞明白 <code>Q-Learing</code> <code>Temporal Difference</code> <code>Policy Gradient</code> 和 <code>Actor-Critic</code>。</li>
</ul>
<p><strong>4.Robotics和LLM</strong></p>
<ul>
<li>之前智创的学长讲过<strong>AI agent驱动的物理机器人</strong>，这应该也算 <code>Embodied AI</code> 的一种实现（？</li>
<li><p>不过目前LLM驱动机器人可能存在一些问题，如<strong>延迟</strong>等；但非LLM机器人 (比如用纯Transformer) 虽然快，但效果很可能不尽如人意。因此，仍需在二者之间寻找平衡点。</p>
</li>
<li><p>可以阅读<a href="https://zhuanlan.zhihu.com/p/668053911">知乎专栏</a></p>
</li>
</ul>
<p><strong>5.模仿学习</strong></p>
<ul>
<li>在有了多模态数据的基础上，可能模仿学习相对于强化学习会有更大的作用。</li>
<li>可以阅读以下两个内容：<a href="https://zhuanlan.zhihu.com/p/670398998">Diffusion Policy</a> 和 <a href="https://zhuanlan.zhihu.com/p/677625871">Action Chunking Transformers (ACT)</a>。</li>
</ul>
<p><strong>6.其他</strong></p>
<ul>
<li>PL: C++ and Python</li>
<li>ROS</li>
<li>Computer Network and Data Structures</li>
<li>…</li>
</ul>
<p><strong>7.复现论文</strong></p>
<ul>
<li>尝试在 <code>Push-T</code> 环境下进行复现：<a href="https://github.com/real-stanford/diffusion_policy">Diffusion Policy</a></li>
</ul>
]]></content>
      <tags>
        <tag>具身智能</tag>
      </tags>
  </entry>
  <entry>
    <title>4K音游制作</title>
    <url>/2025/02/21/4K%E9%9F%B3%E6%B8%B8%E5%88%B6%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="4K音游制作"><a href="#4K音游制作" class="headerlink" title="4K音游制作"></a>4K音游制作</h1><p><strong>Foreword</strong></p>
<p>Just as I mentioned last time, I need more practical experience. Therefore, based on <code>Unity</code> and <code>C#</code>, I have decided to create a rhythm game.</p>
<p>Nowadays, there are many types of rhythm games in the market. One type is no-key rhythm games, such as <code>Phigros</code> and <code>Rizline</code>. Another type is  multiple-keys rhythm games, such as <code>Kalpa</code> and <code>Muse Dash</code>. There is also a type of rhythm games called emergence rhythm games, such as <code>Cytus</code> and <code>阳春白雪</code>. In addition, there are many games that mix multiple elements from the above types, such as <code>Arcaea</code> and <code>maimaiDX</code>. Considering the difficulty and time cost, I have ultimately chosen 4K rhythm games as my goal.</p>
<hr>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>顾名思义，4K(即4 keys)音游，一共包含四个轨道。在每个轨道会有音符下落，游玩者需要在音符到达判定线处点击。每次点击后会进行判定，点击越精准评级也就会越高。以我曾常玩的游戏 <code>Malody 4k</code> 为例，游戏游玩界面如下：</p>
<p><img src="/images/4k_pic1.jpg" alt="malody"></p>
<p>基于此，我们来对整个制作过程的思路进行梳理。</p>
<p>首先，音游程序可以大致分为四个部分，即<strong>谱面读取、触控输入、游戏控制器和键型</strong>四个部分。对于每个部分，我们再来进行详细的解析。</p>
<hr>
<h2 id="程序梳理"><a href="#程序梳理" class="headerlink" title="程序梳理"></a>程序梳理</h2><p><strong>谱面读取</strong></p>
<p>首先，在玩音游的第一步必然是谱面的读取，读取完谱面后才能有接下来的展开。对于谱面的读取，我们可以从以下三个方面来考虑：</p>
<ul>
<li>读取谱面文件</li>
<li>解析数据并储存</li>
<li>初始化</li>
</ul>
<p>于是，我们完成了谱面读取的初步分析。</p>
<p><strong>键型</strong></p>
<p>在这里我们先来讨论一下键型。在4k中，我们仅仅使用 <code>tap</code> 和 <code>hold</code> 。其中最主要的就是 <code>tap</code>，由此我们才分生出各种叠、切、乱、锚键、多押等等键型。当然 <code>hold</code> 也会用到，不过就没有 <code>tap</code> 那么频繁，一般在恶心的面条谱里、休息段以及低dan谱中会遇到较多。因此，我们考虑这两种键型：</p>
<ul>
<li>tap：点击即可</li>
<li>hold：点击后需长按，直至结束</li>
</ul>
<p><strong>触控输入</strong></p>
<p>基于上面的键型，我们来讨论触控输入。我们可以分成三类，分别是<strong>输入信息、分析方法和输出信息</strong>。首先，玩家触碰屏幕时，我们就来判断触碰的位置信息和状态信息。判断位置信息即判断你是否碰到了这个音符对应的位置，状态信息即判断你是否正确打击了对应键型。</p>
<p>随后，我们来分析玩家的输入。分析方法分为两种，一种是<strong>点击</strong>，即手指点到屏幕<strong>那一刻</strong>的手势；一种是<strong>触摸</strong>，就是手指在屏幕上的手势。</p>
<p>最后就是输出了。最后判定是<strong>点击</strong>还是<strong>触摸</strong>即可。</p>
<p><strong>游戏控制器</strong></p>
<p>经过梳理，我们可以总结如下：</p>
<ul>
<li>谱面读取（可以独立出去）——加载谱面，初始化关卡，设置游戏开始</li>
<li>每一帧都记时</li>
<li>如果到了对应的时间，就生成谱面对应的音符</li>
<li>如果游戏开始，且音乐已经播放完毕</li>
<li>结束游戏</li>
</ul>
<p>由此，我们给出了一个大致的思路框架。我们仍需对特定对象进行细化。比如音符、判定器等。</p>
<p><strong>音符</strong></p>
<p>在4k中，音符(note)呈下落式。因此，我们让音符在每一帧都移动，由此来模拟下落。如果进入了自己的时间判定区域，就执行如下代码：</p>
<ul>
<li><p>每一帧都检测自己<strong>是否被点击</strong>（或者对应的<strong>手势</strong>）</p>
</li>
<li><p>如果被点到，就消除自己，并且生成点击特效（也可以辅以音效<del>，比如でらっくす</del>）</p>
</li>
<li><p>向判定器发送被点击的时间</p>
</li>
</ul>
<p><strong>判定器</strong></p>
<p>用来计算点击的评价，显示评价的结果、更改分数、combo数等等，可以集成在控制器里。</p>
<p>由此，我们的大致框架已经完成，我们来进行下一步。</p>
<hr>
<h2 id="Unity的使用"><a href="#Unity的使用" class="headerlink" title="Unity的使用"></a>Unity的使用</h2><p>我这边安装了<code>Unity</code>的 <code>LTS</code> 版本，以及 <code>VS 2022</code>。接下来，就可以着手开始了~</p>
<p>新建项目完成后，点击右上角的灰框，切换至 <code>2 by 3</code> 模式。这样就能同时打开<strong>场景编辑器</strong>和<strong>游戏视角</strong>两个视窗。</p>
<p><img src="/images/4k_pic2.png" alt="2by3"></p>
<p><img src="/images/4k_pic3.png" alt="windows"></p>
<p>随后，我们来添加背景，即创建轨道。这也是每一个note得以下落的基础。在经过一系列的调整以及摄像机位置的调整后，成功实现了背景的搭建：</p>
<p><img src="/images/4k_pic4.png" alt="background"></p>
<p>随后，我们在 <code>Assets</code> 文件夹下，创建 <code>Scripts</code> 文件夹，用来存放我们的 <code>C#</code> 代码。</p>
<p>首先，我们需要处理触控输入部分。在 <code>Unity Manual</code> 中，我们用 <code>touch</code> 作为关键词进行搜索。尽管结果众多，但不难发现，<code>Touch.phase</code> 和 <code>Touch.position</code> 使我们需要的。我们可以看见，旁边写到：</p>
<ul>
<li><code>Touch.phase</code>：描述触摸阶段</li>
<li><code>Touch.position</code>：触摸在屏幕空间中的位置</li>
</ul>
]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>C#初步学习</title>
    <url>/2025/02/19/C-%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="C-初步学习"><a href="#C-初步学习" class="headerlink" title="C#初步学习"></a>C#初步学习</h1><p><strong>Foreword</strong></p>
<p>During last term’s study, I found that all of my studies were focused on theories and abstract concepts. What I lacked was practical experience, such as working on a concrete project. Thus, I wanna make a new game. I’m an avid rhythm game player. tbh, It’s really cool to make a rhythm game by myself. After looking up references and websites, I decided to create a traditional 4K rhythm game based on <code>Unity</code> , a game engine including abundant functions and frameworks. Therefore, it’s essential for me to study <code>C#</code> as an important programming language.</p>
<p><strong>简介</strong></p>
<ul>
<li><code>C#</code> 是一种由 <code>C</code> 和 <code>C++</code> 衍生出来的<strong>面向对象的编程语言</strong>，它不仅去掉了 <code>C++</code> 中的一些复杂特性，还提供了可视化工具，能够高效地编写程序。</li>
<li><code>C#</code> 是由 <code>C</code> 和 <code>C++</code> 衍生出来的一种安全的、稳定的、简单的、优雅的面向对象编程语言。它在继承C和C++强大功能的同时去掉了一些它们的复杂特性 (例如没有宏以及不允许多重继承) 。</li>
<li><code>C#</code> 使得 <code>C++</code> 程序员可以高效的开发程序，且因可调用由 <code>C/C++</code> 编写的本机原生函数，而绝不损失<code>C/C++</code> 原有的强大的功能。因为这种继承关系，<code>C#</code> 与 <code>C/C++</code> 具有极大的相似性，熟悉类似语言的开发者可以很快的转向 <code>C#</code> 。</li>
</ul>
<hr>
<h2 id="一个简单的-Hello-World"><a href="#一个简单的-Hello-World" class="headerlink" title="一个简单的 Hello World!"></a>一个简单的 Hello World!</h2><p>一个 <code>C#</code> 程序主要包含以下部分：</p>
<ul>
<li>命名空间的声明</li>
<li>一个 <code>class</code></li>
<li><code>class</code> 方法</li>
<li><code>class</code> 属性</li>
<li>一个 <code>Main</code> 方法</li>
<li>语句&amp;表达式</li>
<li>注释</li>
</ul>
<p><code>C#</code> 文件的后缀为 <code>.cs</code></p>
<p>我们在 <code>Visual Studio</code> 中创建一个 <code>test.cs</code> 文件，包含了可以打印出 <code>Hello World</code> 的简单代码：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">HelloWorldApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">HelloWorld</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 我的第一个C#程序 */</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>在 <code>C#</code> 中，变量分为以下几种类型：</p>
<ul>
<li>值类型</li>
<li>引用类型</li>
<li>指针类型</li>
</ul>
<h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><p>值类型变量可以直接分配给一个值，它们是从类 <code>System.ValueType</code> 中派生的。</p>
<p>如下：</p>
<ul>
<li>bool</li>
<li>byte: 8位无符号整数类型</li>
<li>char</li>
<li>decimal</li>
<li>double</li>
<li>float</li>
<li>int</li>
<li>long</li>
<li><code>sbyte</code>：8位有符号整数类型</li>
<li>short</li>
<li><code>uint</code></li>
<li><code>ulong</code></li>
<li><code>ushort</code></li>
</ul>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><ul>
<li><p>引用类型<strong>不包含</strong>存储在变量中的<strong>实际数据</strong>，但它们<strong>包含</strong>对变量的<strong>引用</strong>。</p>
</li>
<li><p>换句话说，它们指的是一个<strong>内存位置</strong>。使用多个变量时，引用类型可以指向一个内存位置。如果内存位置的数据是由一个变量改变的，其他变量会自动反映这种值的变化。内置的引用类型有：object、dynamic 和 string。</p>
</li>
</ul>
<p><strong>对象类型</strong></p>
<p>对象类型是 <code>C#</code> 通用类型系统中所有数据类型的终极基类。<code>Object</code> 是 <code>System.Object</code> 类的别名。所以对象类型可以被分配任何其他类型的值。但是在分配值之前，需要先进行类型转换。当一个值类型转换为对象类型时，则被称为<strong>装箱</strong>；另一方面，当一个对象类型转换为值类型时，则被称为<strong>拆箱</strong>。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="built_in">object</span> obj;</span><br><span class="line">obj = <span class="number">100</span>; <span class="comment">//这是装箱</span></span><br></pre></td></tr></table></figure>
<p><strong>动态类型</strong></p>
<p>可以存储任何类型的值在动态数据类型变量中。这些变量的类型检查是在运行时发生的。</p>
<p>声明动态类型的语法：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> &lt;variable_name&gt; = <span class="keyword">value</span>;</span><br><span class="line"><span class="comment">// 例如：</span></span><br><span class="line"><span class="built_in">dynamic</span> d = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p><strong>字符串类型</strong></p>
<p>字符串类型允许给变量分配人格字符串值。字符串类型是 <code>System.String</code> 类的别名。他是从对象类型派生的。字符串类型的值可以通过两种形式进行分配：引号和 <code>@</code> 引号</p>
<p>例如：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;WoShiNaiLong&quot;</span>;</span><br></pre></td></tr></table></figure>
<p><code>C#</code> string字符串的前面可以加 <code>@</code> 将转义字符当做普通字符对待，比如：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">@&quot;C:\Windows&quot;</span>;</span><br><span class="line"><span class="comment">//等价于：</span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;C:\\Windows&quot;</span>;</span><br></pre></td></tr></table></figure>
<p><code>@</code> 字符串中可以任意换行，换行符及缩进空格都计算在字符串长度之内。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">@&quot;&lt;script type=&quot;&quot;text/javascript&quot;&quot;&gt;</span></span><br><span class="line"><span class="string">	&lt;!--</span></span><br><span class="line"><span class="string">	--&gt;</span></span><br><span class="line"><span class="string">&lt;/script&gt;&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>用户自定义引用类型有：<code>class</code>、<code>interface</code> 或 <code>delegate</code>。我们将在以后讨论这些类型。</p>
<h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><p>指针类型变量存储另一个类型的内存地址，<code>C#</code> 中的指针与 <code>C</code> 或 <code>C++</code> 中的指针有相同的功能，声明指针类型的语法：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">type* identifier;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="built_in">char</span>* cptr;</span><br><span class="line"><span class="built_in">int</span>* iptr;</span><br></pre></td></tr></table></figure>
<h3 id="C-类型转换"><a href="#C-类型转换" class="headerlink" title="C#类型转换"></a>C#类型转换</h3><p>类型转换从根本上说是类型铸造，或者说是把数据从一种类型转换为另一种类型。在 C# 中，类型铸造有两种形式：</p>
<ul>
<li><strong>隐式类型转换</strong>：这些转换是 <code>C#</code> 默认的以安全方式进行的转换, 不会导致数据丢失。例如，从小的整数类型转换为大的整数类型，从派生类转换为基类。</li>
<li><strong>显式类型转换</strong>：显式类型转换，即强制类型转换。显式转换需要强制转换运算符，而且强制转换会造成数据丢失。</li>
</ul>
<p><strong>显式的类型转换示例：</strong></p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">TypeConversionApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">ExplicitConversion</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">double</span> d = <span class="number">5673.74</span>;</span><br><span class="line">            <span class="built_in">int</span> i;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 强制转换 double 为 int</span></span><br><span class="line">            i = (<span class="built_in">int</span>)d;</span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">5673</span></span><br></pre></td></tr></table></figure>
<h4 id="C-类型转换方法"><a href="#C-类型转换方法" class="headerlink" title="C#类型转换方法"></a>C#类型转换方法</h4><p><code>C#</code> 提供了下列内置的类型转换方法：</p>
<ul>
<li><code>ToBoolean</code>：转换为 <code>bool</code> 型</li>
<li><code>ToByte</code></li>
<li><code>Tochar</code></li>
<li><code>ToDateTime</code>：转换为 <code>日期-时间</code> 结构</li>
<li><code>ToDecimal</code></li>
<li><code>ToDouble</code></li>
<li><code>Toint16</code></li>
<li><code>Toint32</code></li>
<li><code>Toint64</code></li>
<li><code>ToSbyte</code></li>
<li><code>ToSingle</code>：把类型转换为小浮点数类型</li>
<li><code>ToString</code></li>
<li><code>ToType</code></li>
<li><code>ToUInt16</code></li>
<li><code>ToUInt32</code></li>
<li><code>ToUInt64</code></li>
</ul>
<p>一个示例：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">Console.WriteLine(i.ToString());</span><br></pre></td></tr></table></figure>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p><strong>静态常量const</strong></p>
<p>静态常量(编译时常量)<strong>在编译时就确定了值</strong>，必须在声明时就进行初始化且之后不能进行更改，可在类和方法中定义。使用 <code>const</code> 关键字，定义一个常量的语法如下：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &lt;data_type&gt; &lt;constant_name&gt; = <span class="keyword">value</span>;</span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">double</span> a = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure>
<p><strong>动态常量readonly</strong></p>
<p>在运行时确定值，只能在声明时或构造函数中初始化，只能在类中定义。定义方法如下：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="built_in">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="built_in">int</span> b;</span><br><span class="line">    Program() <span class="comment">// 构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        b = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态常量与动态常量的使用场景</p>
<p>在下面两种情况下，可以使用 <code>const</code> 常量：</p>
<ul>
<li><strong>取值永久不变</strong>。比如圆周率、一天包含的小时数、地球的半径等。</li>
<li><strong>对程序性能要求非常苛刻</strong>。</li>
</ul>
<p>除此之外的其他情况都应该优先采用 <code>readonly</code> 常量。</p>
<h2 id="C-运算符"><a href="#C-运算符" class="headerlink" title="C#运算符"></a>C#运算符</h2>]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>GM(1,1)灰色预测</title>
    <url>/2025/01/19/GM-1-1-%E7%81%B0%E8%89%B2%E9%A2%84%E6%B5%8B/</url>
    <content><![CDATA[<h1 id="GM-1-1-灰色预测"><a href="#GM-1-1-灰色预测" class="headerlink" title="GM(1,1)灰色预测"></a>GM(1,1)灰色预测</h1><p>显然地，G代表Grey(灰色)，M代表Model(模型)；而(1,1)代表只含有一个变量的一阶微分方程模型。</p>
<p><strong>灰色系统：</strong></p>
<ul>
<li><p>介于黑色和白色之间，<strong>部分已知</strong>，<strong>部分未知</strong>，具有小样本数据的<strong>不确定性</strong>系统。</p>
</li>
<li><p>典型例子：GDP就是灰色系统。</p>
</li>
</ul>
<p><strong>适用赛题：</strong></p>
<ul>
<li><p><strong>数列预测</strong></p>
<ul>
<li>特点：<strong>定时求量</strong>。已知xx年到xx年的数据，请预测下一年的数值。</li>
<li>常见GDP、人口数量、耕地面积、粮食产量等问题。</li>
<li>针对的问题往往短期<strong>波动小</strong>、<strong>可预测</strong>，但长期可能变化大、难以预测。</li>
</ul>
</li>
<li><p><strong>灾变预测</strong></p>
<ul>
<li>特点：<strong>定量求时</strong>。已知xx年到xx年的数据和某灾变的阈值，预测下一次灾变发生的时间。</li>
<li>常见洪涝灾害、虫灾等问题。</li>
<li>模型中需要把<strong>超出阈值</strong>的数据 (异常数据) 对应的时间组成新序列。</li>
</ul>
</li>
<li><strong>拓扑预测</strong><ul>
<li>特点：<strong>对数据波形进行预测。</strong>求的是多个模型构成的模型群，等于求解<strong>多个</strong>灾变预测。</li>
<li>与灾变预测类似，不过有较详细的分级，例如虫灾 “轻微” “中度” “重度”。</li>
</ul>
</li>
<li><strong>注意事项</strong><ul>
<li>需要的<strong>数据量少</strong>，数据量太多了没有意义。</li>
<li>只能<strong>短期预测</strong>，但究竟多短没有严格限制。</li>
</ul>
</li>
</ul>
<p>以下题为例：某城市1986到1992年道路噪声平均声级数据见下表。请预测下一年的数据。</p>
<ul>
<li>某城市交通噪声数据/$dB(A)$ </li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">年份</td>
<td style="text-align:center">1986</td>
<td style="text-align:center">1987</td>
<td style="text-align:center">1988</td>
<td style="text-align:center">1989</td>
<td style="text-align:center">1990</td>
<td style="text-align:center">1991</td>
<td style="text-align:center">1992</td>
</tr>
<tr>
<td style="text-align:center">噪声</td>
<td style="text-align:center">71.1</td>
<td style="text-align:center">72.4</td>
<td style="text-align:center">72.4</td>
<td style="text-align:center">72.1</td>
<td style="text-align:center">71.4</td>
<td style="text-align:center">72.0</td>
<td style="text-align:center">71.6</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>特点：<strong>数据少，看不出明显规律</strong>，适合用灰色预测。</li>
</ul>
<p>可进行数据的<strong>累加</strong>，于是有：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">年份</td>
<td style="text-align:center">1986</td>
<td style="text-align:center">1987</td>
<td style="text-align:center">1988</td>
<td style="text-align:center">1989</td>
<td style="text-align:center">1990</td>
<td style="text-align:center">1991</td>
<td style="text-align:center">1992</td>
</tr>
<tr>
<td style="text-align:center">$x^{(0)}$</td>
<td style="text-align:center">71.1</td>
<td style="text-align:center">72.4</td>
<td style="text-align:center">72.4</td>
<td style="text-align:center">72.1</td>
<td style="text-align:center">71.4</td>
<td style="text-align:center">72.0</td>
<td style="text-align:center">71.6</td>
</tr>
<tr>
<td style="text-align:center">$x^{(1)}$</td>
<td style="text-align:center">71.1</td>
<td style="text-align:center">143.5</td>
<td style="text-align:center">215.9</td>
<td style="text-align:center">288</td>
<td style="text-align:center">359.4</td>
<td style="text-align:center">431.4</td>
<td style="text-align:center">503</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>累加生成序列：$x^{(1)}(k) = \sum_{i=1}^k x^{(0)}(i)$</p>
</li>
<li><p>弱化其<strong>随机性</strong>，显现其<strong>规律性</strong>。</p>
</li>
</ul>
<p>此时生成的新序列 $x^{(1)}$ ，看起来像一个指数曲线 (直线)。因此可用一个<strong>指数曲线</strong>的表达式来逼近这个新序列，相应可构建<strong>一阶常微分方程</strong>来求解拟合<strong>指数曲线</strong>的<strong>函数表达式</strong>。</p>
<p>关于一阶常微分方程，假设 $x^{(1)}$ 满足形式： $\frac{dx^{(1)}}{dt} + ax^{(1)} = u$</p>
<ul>
<li>要预测下一年数值，就需要新序列 $x^{(1)}$ 的表达式，那就要解出<strong>微分方程</strong>。</li>
<li>要解微分方程，就要先知道参数 $a$ 和 $u$ </li>
</ul>
<h3 id="表达式处理"><a href="#表达式处理" class="headerlink" title="表达式处理"></a>表达式处理</h3><p>已知的 $\frac{dx^{(1)}}{dt} + ax^{(1)} = u$ 中的数据是离散的，所以应该把 $\frac{dx^{(1)}}{dt}$ 写成 $\frac{\Delta x^{(1)}}{\Delta t}$ .</p>
<ul>
<li>$\Delta t = t - (t-1) = 1$，始终为1；而 $\Delta x^{(1)} = x^{(1)}(t)- x^{(1)}(t-1) = x^{(0)}(t)$</li>
<li>得到方程$x^{(0)}(t) + ax^{(1)}(t) = u$ ，即 $x^{(0)}(t) = - ax^{(1)}(t) + u$</li>
</ul>
<p>为了进一步消除数据随机性，将 $x^{(1)}(t)$ 修正为 $z^{(1)}(t)$</p>
<ul>
<li>考虑到原方程中有 $\frac{\Delta x^{(1)}}{\Delta t}$，因此将 $x^{(1)}(t)$ 改为取<strong>前后两个时刻的均值</strong>更合理。</li>
<li>对 $x^{(1)}$ 进行<strong>均值生成</strong>：$z^{(1)}(t) = 0.5x^{(1)}(t)+0.5 x^{(1)}(t-1),t=2,…,n$，即方程改为 $x^{(0)}(t) = - az^{(1)}(t) + u$ .</li>
<li>可用<strong>最小二乘法</strong>求未知参数。</li>
</ul>
<h3 id="模型求解"><a href="#模型求解" class="headerlink" title="模型求解"></a>模型求解</h3><p>1.最小二乘法求解</p>
<ul>
<li>当前方程 (函数) 为 $x^{(0)}(t) = - az^{(1)}(t) + u$ .</li>
<li>最小二乘法就是求出当拟合函数求的值与已知数据的平方差最小时，未知参数的取值。</li>
<li>方程矩阵形式 $Y = B U$</li>
</ul>
<script type="math/tex; mode=display">
\begin{bmatrix}
x^{(0)}(2)  \\
x^{(0)}(3)  \\   
\vdots      \\
x^{(0)}(N) 
\end{bmatrix}
=
\begin{bmatrix}
-\frac{1}{2} [x^{(1)}(2) + x^{(1)}(1)] & 1 \\
-\frac{1}{2} [x^{(1)}(3) + x^{(1)}(2)] & 1 \\
\vdots & \vdots \\
-\frac{1}{2} [x^{(1)}(N) + x^{(1)}(N-1)] & 1
\end{bmatrix}
\begin{bmatrix}
a \\
u
\end{bmatrix}</script><ul>
<li>最小二乘法也就是求 $(Y-BU)^T(Y-BU)$取最小值时的 $U$</li>
<li>求解U的估计值为 $\hat{U} = [\hat{a},\hat{b}]^T = (B^T B)^{-1} B^T Y$，即求出参数 $\hat{a},\hat{b}$ .</li>
</ul>
<p>然后带入原微分方程，求出$\frac{dx^{(1)}}{dt} + \hat{a}x^{(1)} = \hat{b}$ 的解，即 $\hat{x}^{(1)}(k+1) = (x^{(0)}(1)-\frac{\hat{b}}{\hat{a}})e^{-\hat{b}k}+\frac{\hat{b}}{\hat{a}}$</p>
<h3 id="模型检验"><a href="#模型检验" class="headerlink" title="模型检验"></a>模型检验</h3><ul>
<li>模型检验就是看按照 $\hat{x}^{(1)}(k+1)$ 求得的拟合值和实际值相差大不大。</li>
<li><strong>相对误差检验</strong>：$\epsilon(k) = \frac{|x^{(0)}(k)-\hat{x}^{(0)}(k)|}{x^{(0)}(k)}$ ，如果 $\epsilon(k)&lt;0.2$，可认为达到一般要求；如果 $\epsilon(k)&lt;0.1$，即达到较高要求。</li>
<li><strong>级比偏差检验</strong>：$\rho(k)=1-\frac{1-0.5a}{1+0.5a} \lambda(k)$，其中级比 $\lambda(k) = \frac{x^{(0)}(k-1)}{x^{(0)}(k)}$，如果 $|\rho(k)|&lt;0.2$，可认为达到一般要求；如果 $|\rho(k)|&lt;0.1$，即达到较高要求。</li>
</ul>
<h3 id="原始数据的级比检验-在建模最开始进行"><a href="#原始数据的级比检验-在建模最开始进行" class="headerlink" title="原始数据的级比检验(在建模最开始进行)"></a>原始数据的级比检验(在建模最开始进行)</h3><p>为了确定<strong>原始数据</strong>使用GM(1,1)模型的可行性，避免白忙活，需要对原始数据进行级比检验：</p>
<ul>
<li>计算 $\lambda(k) = \frac{x^{(0)}(k-1)}{x^{(0)}(k)},k=2,3,…,n$</li>
</ul>
<p>如果 $\lambda(k)$ 在区间 $(e^{-\frac{2}{n+1}},e^{\frac{2}{n+2}})$，说明可用GM(1,1)模型。</p>
<ul>
<li>如果在区间外，可尝试平移变换。也就是给每个数据都加上任意常数 $c$ 后，观察是否在区间内，求解后再减去 $c$ ；如果尝试多次平移变换后始终无法在区间内，说明题目不适合灰色预测。</li>
</ul>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul>
<li><p>核心就是最小二乘法求参数，再求微分方程。</p>
</li>
<li><p>在最开始要对原始数据进行检验，在最后要对结果进行检验。</p>
<p><img src="/images/Flowchart.png" alt="Flowchart"></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title>Google开源项目风格指南精简版</title>
    <url>/2025/02/23/Google%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97%E7%B2%BE%E7%AE%80%E7%89%88/</url>
    <content><![CDATA[<p><strong>自给自足的头文件</strong></p>
<p>头文件应该<strong>可以独立编译</strong>，并以 <code>.h</code> 为拓展名。给需要被导入但不属于头文件的文件设置为 <code>.inc</code> 拓展名，并尽量避免使用。</p>
<p><strong>#define防护符</strong></p>
<p>所有头文件都应该用 <code>#define</code> 防护符来防止重复导入。防护符的格式是 <code>&lt;项目&gt;_&lt;路径&gt;_&lt;文件名&gt;_H_</code> .</p>
<p><strong>内联函数</strong></p>
<p>只把 10 行以下的小函数定义为内联(inline).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>#include的路径及顺序</strong></p>
<p>推荐按照以下顺序导入头文件：配套的头文件，C语言系统库头文件，C++标准库头文件，其他库的头文件，本项目的头文件。</p>
<p>举例来说, <code>google-awesome-project/src/foo/internal/fooserver.cc</code> 的导入语句如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;foo/server/fooserver.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base/basictypes.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;foo/server/bar.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;third_party/absl/flags/flag.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<p><strong>命名空间</strong></p>
<p>除了少数特殊情况，应该在命名空间 (namespace) 内放置代码。命名空间应该有独一无二的名字，其中包含项目名称，也可以选择性地包含文件路径。禁止使用 using 指令 (例如 <code>using namespace foo</code>). 禁止使用内联 (inline) 命名空间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> mynamespace &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>局部变量</strong></p>
<p>应该尽可能缩小函数变量的作用域 (scope)，并在声明的同时初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line">i = <span class="built_in">f</span>(); <span class="comment">// 不好：初始化和声明分离，</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="built_in">f</span>(); <span class="comment">// 良好：声明时初始化。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> jobs = <span class="built_in">NumJobs</span>();</span><br><span class="line"><span class="comment">// 更多代码...</span></span><br><span class="line"><span class="built_in">f</span>(jobs); <span class="comment">// 不好：初始化和使用位置分离，</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> jobs = <span class="built_in">NumJobs</span>()</span><br><span class="line"><span class="built_in">f</span>(jobs); <span class="comment">// 良好：初始化以后立即(或很快)使用。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>); <span class="comment">// 用花括号初始化更好，</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// 良好：立即初始化 v.</span></span><br></pre></td></tr></table></figure>
<p>通常应该在语句内声明用于 <code>if</code>、<code>while</code> 和 <code>for</code> 语句的变量，这样会把作用域限制在语句内。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while (const char* p = strchr(str, &#x27;/&#x27;)) str = p + 1;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果变量是一个对象，那么它每次进入作用域时会调用构造函数，每次退出作用域时都会调用析构函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 低效的实现：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">    Foo f; <span class="comment">// 调用 1000000 次构造函数和析构函数</span></span><br><span class="line">    f.<span class="built_in">DoSomething</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo f; <span class="comment">// 调用 1 次构造函数和析构函数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">    f.<span class="built_in">DoSomething</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>未完待续</p>
]]></content>
      <tags>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习:字符串</title>
    <url>/2024/10/21/Python%E5%AD%A6%E4%B9%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="字符串的索引与切片"><a href="#字符串的索引与切片" class="headerlink" title="字符串的索引与切片"></a>字符串的索引与切片</h3><ul>
<li><strong>字符串的索引访问</strong>  </li>
</ul>
<p>Python语言中的字符串包括两种符号体系:正向递增序号和反向递减序号。  </p>
<p>如下图所示:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=<span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">0</span>]</span><br><span class="line"><span class="string">&#x27;H&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[-<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;d&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">8</span>]</span><br><span class="line"><span class="string">&#x27;r&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[-<span class="number">3</span>]</span><br><span class="line"><span class="string">&#x27;r&#x27;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>字符串的切片访问</strong></li>
</ul>
<p>具体语法格式为: <code>[头下标：尾下标]</code> ，这种访问方式称之为“切片”。但注意，这是<strong>左闭右开</strong>的区间。在切片方式中，若头下标缺省，表示从字符串的开始取子串；若尾下标缺省，表示取到字符串的最后一个字符；若头下标和尾下标都缺省，则取整个字符串。 </p>
<p>示例:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=<span class="string">&#x27;Hello Mike&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line"><span class="string">&#x27;Hello&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">6</span>:-<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;Mik&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[:<span class="number">5</span>]</span><br><span class="line"><span class="string">&#x27;Hello&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">6</span>:]</span><br><span class="line"><span class="string">&#x27;Mike&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[:]</span><br><span class="line"><span class="string">&#x27;Hello Mike&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>字符串切片还可以设置取子字符串的顺序，格式为 <code>[头下标:尾下标:步长]</code> 。当步长大于0的时候，从左往右取字符；当步长小于0的时候，从右往左取字符。  </p>
<p>示例:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=<span class="string">&#x27;Hello Mike&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">0</span>:<span class="number">5</span>:<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;Hello&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">0</span>:<span class="number">6</span>:<span class="number">2</span>]</span><br><span class="line"><span class="string">&#x27;Hlo&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">0</span>:<span class="number">6</span>:-<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">4</span>:<span class="number">0</span>:-<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;olle&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">4</span>::-<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;olleH&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="字符串的处理与操作"><a href="#字符串的处理与操作" class="headerlink" title="字符串的处理与操作"></a>字符串的处理与操作</h3><ul>
<li><strong>内置字符串处理函数</strong> </li>
</ul>
<p>len(x)   #返回字符串x的长度    </p>
<p>str(x)   #将任意类型的x转化为字符串类型 </p>
<p>chr(x)   #返回Unicode编码为x的字符  </p>
<p>ord(x)   #返回字符x的Unicode编码  </p>
<p>hex(x)   #将整数x转化为十六进制数  </p>
<p>oct(x)   #将整数x转化为八进制数  </p>
<p>示例:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=<span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(s)</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(<span class="number">120</span>)</span><br><span class="line"><span class="string">&#x27;120&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(<span class="number">3</span>+<span class="number">5</span>)</span><br><span class="line"><span class="string">&#x27;8&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(<span class="number">62</span>)</span><br><span class="line"><span class="string">&#x27;0o76&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"><span class="number">65</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">chr</span>(<span class="number">65</span>)</span><br><span class="line"><span class="string">&#x27;A&#x27;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>查找类函数</strong></li>
</ul>
<p>find()   #查找一个字符串在另一个字符串指定范围内（默认是整个字符串）中首次出现的位置，若不存在则返回-1.  </p>
<p>rfind()  #查找一个字符串在另一个字符串指定范围内（默认是整个字符串）中最后一次出现的位置，若不存在则返回-1.  </p>
<p>index()  #查找一个字符串在另一个字符串指定范围内（默认是整个字符串）中首次出现的位置，若不存在则抛出异常.  </p>
<p>rindex() #查找一个字符串在另一个字符串指定范围内（默认是整个字符串）中最后一次出现的位置，若不存在则抛出异常.  </p>
<p>count()  #用来返回一个字符串在另一个字符串中出现的次数，若不存在则返回0.  </p>
<p>示例:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=<span class="string">&#x27;bird,fish,monkey,rabbit&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.find(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.rfind(<span class="string">&#x27;fish&#x27;</span>)</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.rfind(<span class="string">&#x27;tiger&#x27;</span>)</span><br><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.index(<span class="string">&#x27;tiger&#x27;</span>)</span><br><span class="line"> Traceback (most recent call last):</span><br><span class="line">   File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line"> ValueError: substring <span class="keyword">not</span> found</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.count(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>分割类函数</strong>  </li>
</ul>
<p>split()    #以指定字符为分隔符，从原字符串的左端开始将其分割为多个字符串，并返回包含分割结果的列表.  </p>
<p>rsplit()   #以指定字符为分隔符，从原字符串的右端开始将其分割为多个字符串，并返回包含分割结果的列表.  </p>
<p>partition()    #以指定字符串为分隔符将原字符串分割为3个部分，分隔符之前的字符串，分隔符字符串和分隔符之后的字符串.  </p>
<p>rpartition()   #以指定字符串为分隔符将原字符串分割为3个部分，分隔符之前的字符串，分隔符字符串和分隔符之后的字符串. </p>
<p>示例:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=<span class="string">&#x27;bird,fish,monkey,rabbit&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;bird&#x27;</span>,<span class="string">&#x27;fish&#x27;</span>,<span class="string">&#x27;monkey&#x27;</span>,<span class="string">&#x27;rabbit&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=<span class="string">&#x27;I am a girl&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;am&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;girl&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.rsplit(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;am&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;girl&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.split(maxsplit=<span class="number">2</span>)</span><br><span class="line">[<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;am&#x27;</span>,<span class="string">&#x27;a girl&#x27;</span>] <span class="comment">#此时以空白来从左往右分割, &#x27;maxsplit=2&#x27;说明最多分割两次.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.rsplit(maxsplit=<span class="number">2</span>)</span><br><span class="line">[<span class="string">&#x27;I am&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;girl&#x27;</span>] <span class="comment">#此时以空白来从右往左分割.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.partition(<span class="string">&#x27;fish&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;I am a girl&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.partition(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;I &#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;m a girl&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.partition(<span class="string">&#x27;am&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;I &#x27;</span>,<span class="string">&#x27;am&#x27;</span>,<span class="string">&#x27; a girl&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>字符串连接方法</strong>  </li>
</ul>
<p>join()  #将列表中多个字符串进行连接，并在相邻两个字符串之间插入指定字符，返回新字符串. </p>
<p>示例:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=[<span class="string">&#x27;apple&#x27;</span>,<span class="string">&#x27;banana&#x27;</span>,<span class="string">&#x27;pear&#x27;</span>,<span class="string">&#x27;peach&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;:&#x27;</span>.join(s)</span><br><span class="line"><span class="string">&#x27;apple:banana:pear:peach&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;-&#x27;</span>.join(s)</span><br><span class="line"><span class="string">&#x27;apple-banana-pear-peach&#x27;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>大小写字符转换方法</strong>  </li>
</ul>
<p>lower()     #将字符串转换为小写字符串.  </p>
<p>uppper()    #将字符串转换为大写字符串.  </p>
<p>capitalize()    #将字符串首字母变为大写.  </p>
<p>title()         #将字符串中每个单词的首字母都变为大写.  </p>
<p>swapcase()      #将字符串中的字符大小写互换.  </p>
<p>示例:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=<span class="string">&#x27;I have two big eyes&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.lower()</span><br><span class="line"><span class="string">&#x27;i have two big eyes&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.upper()</span><br><span class="line"><span class="string">&#x27;I HAVE TWO BIG EYES&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.capitalize()</span><br><span class="line"><span class="string">&#x27;I have two big eyes&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.title()</span><br><span class="line"><span class="string">&#x27;I Have Two Big Eyes&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.swapcase()</span><br><span class="line"><span class="string">&#x27;i HAVE TWO BIG EYES&#x27;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>替换方法</strong>  </li>
</ul>
<p>replace() #替换字符串中指定字符或子字符串</p>
<p>示例:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=<span class="string">&#x27;I have two big eyes&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.replace(<span class="string">&#x27;big&#x27;</span>,<span class="string">&#x27;大&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;I have two 大 eyes&#x27;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>删除字符串两端、右端或左端连续空白字符和指定字符方法</strong></li>
</ul>
<p>strip()         #删除字符串两端空白字符.   </p>
<p>rstrip()        #删除字符串右端空白字符.  </p>
<p>lstrip()        #删除字符串左端空白字符.<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=<span class="string">&#x27;     abc     &#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.strip()</span><br><span class="line"><span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.rstrip()</span><br><span class="line"><span class="string">&#x27;     abc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.lstrip()</span><br><span class="line"><span class="string">&#x27;abc     &#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=<span class="string">&#x27;====mike====&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.strip(<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;mike&#x27;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>判断字符串是否以指定字符串开始或结束</strong></li>
</ul>
<p>startswith()   #判断字符串是否以指定字符开始.  </p>
<p>endswith()      #判断字符串是否以指定字符结束.<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=<span class="string">&#x27;Python 程序设计.py&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.startswith(<span class="string">&#x27;py&#x27;</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.startswith(<span class="string">&#x27;Python&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.endswith(<span class="string">&#x27;py&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>判断字符串类型方法</strong></li>
</ul>
<p>isupper()       #是否全为大写.  </p>
<p>islower()       #是否全为小写.  </p>
<p>isdigit()       #是否全为数字.  </p>
<p>isalnum()       #是否全为字母或汉字或数字.  </p>
<p>isalpha()       #是否全为字母或汉字.  </p>
<p>示例:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=<span class="string">&#x27;years&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.islower()</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=<span class="string">&#x27;YEARS&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.isupper()</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=<span class="string">&#x27;20241022&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.isdigit()</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=<span class="string">&#x27;I am a girl&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.isalpha()</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=s.replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.isalpha()</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.isalnum()</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>字符串排版方法</strong>  </li>
</ul>
<p>center()         #字符串居中对齐.  </p>
<p>ljust()          #字符串居左对齐.  </p>
<p>rjust()          #字符串居右对齐.  </p>
<p>zfill()          #输出指定宽度，不足的左边填0.  </p>
<p>示例:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=<span class="string">&#x27;hello mike&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.center(<span class="number">30.</span><span class="string">&#x27;=&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;==========hello mike==========&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.rjust(<span class="number">20</span>,<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;**********hello mike&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.zfill(<span class="number">20</span>)</span><br><span class="line"><span class="string">&#x27;0000000000hello mike&#x27;</span></span><br></pre></td></tr></table></figure></p>
<hr>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV简单函数速查(C++)</title>
    <url>/2025/02/27/OpenCV%E7%AE%80%E5%8D%95%E5%87%BD%E6%95%B0%E9%80%9F%E6%9F%A5-C/</url>
    <content><![CDATA[<h1 id="OpenCV-简单函数速查"><a href="#OpenCV-简单函数速查" class="headerlink" title="OpenCV 简单函数速查"></a>OpenCV 简单函数速查</h1><h2 id="读取图片-视频-摄像头"><a href="#读取图片-视频-摄像头" class="headerlink" title="读取图片/视频/摄像头"></a>读取图片/视频/摄像头</h2><p><strong>从文件读取图片</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">cv::imread</span><span class="params">(<span class="type">const</span> String &amp;filename, <span class="type">int</span> flags = IMREAD_COLOR)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>上述代码实现了<strong>从文件加载图像</strong>。函数 <code>imread</code> 从指定文件加载图像并返回。在彩色图像的情况下，解码图像的通道将以 <code>B G R</code> 顺序存储。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::imshow</span><span class="params">(<span class="type">const</span> String &amp;winname, InputArray mat)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>上述代码实现了<strong>在指定窗口中显示图像</strong>。其后应跟 <code>cv::waitKey</code> 函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cv::waitKey</span><span class="params">(<span class="type">int</span> delay = <span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>上述代码实现了<strong>等待按下的键</strong>。<code>waitKey(0)</code> 将无限显示窗口，直到有任何按键。</li>
</ul>
<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span> <span class="comment">// 读写图像文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span> <span class="comment">// 图像处理</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span> <span class="comment">// 高级GUI</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string path = <span class="string">&quot;Resources/test.png&quot;</span>;</span><br><span class="line">	Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line">	<span class="built_in">waitKey</span>(<span class="number">0</span>); <span class="comment">//显示图片不会一闪而过</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终，会显示一个名为 <code>Image</code> 的窗口。(<del>懒得放图了</del>)</p>
<p><strong>从文件读取视频</strong></p>
<p>要捕获视频，需要创建一个 <code>VideoCapture</code> 对象。它的参数可以是视频文件的名称或设备索引。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::VideoCapture::<span class="built_in">VideoCapture</span>()</span><br><span class="line">cv::VideoCapture::<span class="built_in">VideoCapture</span>(<span class="type">const</span> String &amp;filename)</span><br><span class="line">cv::VideoCapture::<span class="built_in">VideoCapture</span>(<span class="type">const</span> String &amp;filename, <span class="type">int</span> apiPreference)</span><br><span class="line">cv::VideoCapture::<span class="built_in">VideoCapture</span>(<span class="type">int</span> index)</span><br><span class="line">cv::VideoCapture::<span class="built_in">VideoCapture</span>(<span class="type">int</span> index, <span class="type">int</span> apiPreference)</span><br></pre></td></tr></table></figure>
<ul>
<li>上述代码实现<strong>打开视频文件或捕获设备或IP视频流进行视频捕获</strong>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">virtual</span> <span class="type">bool</span> cv::VideoCapture::<span class="built_in">isOpened</span>() <span class="type">const</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果视频捕获已经初始化，则返回 <code>true</code> 。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">virtual</span> <span class="type">bool</span> cv::VideoCapture::<span class="built_in">read</span>(OutputArray image)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>抓取、解码并返回下一个视频帧。</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">virtual</span> <span class="type">double</span> cv::VideoCapture::<span class="built_in">get</span>(<span class="type">int</span> proID) <span class="type">const</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回指定的 <code>VideoCapture</code> 属性。<code>&lt;-</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">virtual</span> <span class="type">double</span> cv::VideoCapture::<span class="built_in">set</span>(<span class="type">int</span> proID, <span class="type">double</span> value)</span><br></pre></td></tr></table></figure>
<ul>
<li>在 <code>VideoCapture</code> 中设置一个属性。</li>
</ul>
<p><strong>读摄像头代码实现：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">VideoCapture <span class="title">cap</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	Mat img;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) </span><br><span class="line">    &#123;</span><br><span class="line">		cap.<span class="built_in">read</span>(img);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line">		<span class="built_in">waitKey</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="基础函数"><a href="#基础函数" class="headerlink" title="基础函数"></a>基础函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::cvtColor</span><span class="params">(InputArray src, OutputArray dst, <span class="type">int</span> code, <span class="type">int</span> dstCn = <span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>上述代码实现了<strong>将一种颜色空间转换为另一种颜色空间</strong>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::GaussianBlur</span><span class="params">(InputArray src, OutputArray dst, Size ksize, <span class="type">double</span> sigmaX, <span class="type">double</span> sigmaY = <span class="number">0</span>, <span class="type">int</span> borderType = BORDER_DEFAULT)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>高斯模糊</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::Canny</span><span class="params">(InputArray image, OutputArray edges, <span class="type">double</span> threshold1, <span class="type">double</span> threshold2, <span class="type">int</span> apertureSize = <span class="number">3</span>, <span class="type">bool</span> L2gradient = <span class="literal">false</span>)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用Canny算法在图像中<strong>查找边缘</strong>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">cv::getStructuringElement</span><span class="params">(<span class="type">int</span> shape, Size ksize, Point anchor = Point(<span class="number">-1</span>, <span class="number">-1</span>))</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>返回指定大小和形状的结构元素</strong>，用于形态学操作。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::dilate</span><span class="params">(InputArray src, OutputArray dst, InuputArray kernel, Point anchor = Point(<span class="number">-1</span>, <span class="number">-1</span>), <span class="type">int</span> iterations = <span class="number">1</span>, <span class="type">int</span> borderType = BORDER_CONSTANT, <span class="type">const</span> Scalar &amp;borderValue = morphologyDefaultBorderValue())</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用特定的结构元素<strong>膨胀</strong>图像。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::erode</span><span class="params">(InputArray src, OutputArray dst, InuputArray kernel, Point anchor = Point(<span class="number">-1</span>, <span class="number">-1</span>), <span class="type">int</span> iterations = <span class="number">1</span>, <span class="type">int</span> borderType = BORDER_CONSTANT, <span class="type">const</span> Scalar &amp;borderValue = morphologyDefaultBorderValue())</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用特定的结构元素<strong>腐蚀</strong>图像。</li>
</ul>
<hr>
<h2 id="调整和剪裁"><a href="#调整和剪裁" class="headerlink" title="调整和剪裁"></a>调整和剪裁</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::resize</span><span class="params">(InputArray src, OutputArray dst, Size dsize, <span class="type">double</span> fx=<span class="number">0</span>, <span class="type">double</span> fy=<span class="number">0</span>, <span class="type">int</span> interpolation = INTER_LINEAR)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>调整图像大小</strong>。函数 <code>resize</code> 将图像 <code>src</code> 的大小缩小到或最大到指定的大小。</li>
</ul>
<hr>
<h2 id="绘制形状和文字"><a href="#绘制形状和文字" class="headerlink" title="绘制形状和文字"></a>绘制形状和文字</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Mat</span>(<span class="type">int</span> rows, <span class="type">int</span> cols, <span class="type">int</span> type, <span class="type">const</span> Scalar &amp;s)</span><br></pre></td></tr></table></figure>
<ul>
<li>重载的构造函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::circle</span><span class="params">(InputOutputArray img, Point center, <span class="type">int</span> radius, <span class="type">const</span> Scalar &amp;color, <span class="type">int</span> thickness=<span class="number">1</span>, <span class="type">int</span> lineType=LINE_8, <span class="type">int</span> shift=<span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>函数 <code>cv::circle</code> 用给定的中心和半径绘制一个简单的<strong>实心圆</strong>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::rectangle</span><span class="params">(InputOutputArray img, Point pt1, Point pt2, <span class="type">const</span> Scalar &amp;color, <span class="type">int</span> thickness=<span class="number">1</span>, <span class="type">int</span> lineType=LINE_8, <span class="type">int</span> shift=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::rectangle</span><span class="params">(Mat &amp;img, Rect rec, <span class="type">const</span> Scalar &amp;color, <span class="type">int</span> thickness=<span class="number">1</span>, <span class="type">int</span> lineType=LINE_8, <span class="type">int</span> shift=<span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>绘制一个简单的、粗的或填充的右上<strong>矩形</strong>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::line</span> <span class="params">(InputOutputArray img, Point pt1, Point pt2, <span class="type">const</span> Scalar &amp;color, <span class="type">int</span> thickness=<span class="number">1</span>, <span class="type">int</span> lineType=LINE_8, <span class="type">int</span> shift=<span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>绘制连接两点的<strong>线段</strong>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::putText</span> <span class="params">(InputOutputArray img, <span class="type">const</span> String &amp;text, Point org, <span class="type">int</span> fontFace, <span class="type">double</span> fontScale, Scalar color, <span class="type">int</span> thickness=<span class="number">1</span>, <span class="type">int</span> lineType=LINE_8, <span class="type">bool</span> bottomLeftOrigin=<span class="literal">false</span>)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>绘制一个文本字符串</strong>。</li>
</ul>
<hr>
<h2 id="透视变换"><a href="#透视变换" class="headerlink" title="透视变换"></a>透视变换</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">cv::getPerspectiveTransform</span> <span class="params">(<span class="type">const</span> Point2f src[], <span class="type">const</span> Point2f dst[])</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>返回相应 4 个点对的 <code>3x3</code> 透视变换。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::warpPerspective</span> <span class="params">(InputArray src, OutputArray dst, InputArray M, Size dsize, <span class="type">int</span> flags=INTER_LINEAR, <span class="type">int</span> borderMode=BORDER_CONSTANT, <span class="type">const</span> Scalar &amp;borderValue=Scalar())</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>对图像应用透视变换。</li>
</ul>
<hr>
<h2 id="颜色检测"><a href="#颜色检测" class="headerlink" title="颜色检测"></a>颜色检测</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::inRange</span> <span class="params">(InputArray src, InputArray lowerb, InputArray upperb, OutputArray dst)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>检测数组元素时候位于其他两个数组的元素之间。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::namedWindow</span> <span class="params">(<span class="type">const</span> String &amp;winname, <span class="type">int</span> flags = WINDOW_AUTOSIZE)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>创建一个窗口</strong>。函数创建一个可用作图像和轨迹栏占位符的窗口。创建的窗口由它们的名称引用。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cv::createTrackbar</span> <span class="params">(<span class="type">const</span> String &amp;trackbarname, <span class="type">const</span> String &amp;winname, <span class="type">int</span> *value, <span class="type">int</span> count, TrackbarCallback onChange = <span class="number">0</span>, <span class="type">void</span> *userdata = <span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个 <code>trackbar</code> 并将其附加到指定窗口。函数 <code>createTrackbar</code>创建一个具有指定名称和范围的<code>trackbar</code>（滑块或范围控件），分配一个变量值作为与 <code>trackbar</code> 同步的位置，并指定回调函数<code>onChange</code> 为 在跟踪栏位置变化时被调用。创建的轨迹栏显示在指定的窗口 <code>winname</code> 中。</li>
</ul>
<hr>
<h2 id="形状-轮廓检测"><a href="#形状-轮廓检测" class="headerlink" title="形状/轮廓检测"></a>形状/轮廓检测</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::findContours</span><span class="params">(InputOutputArray image, OutputArrayOfArrays contours, OutputArray hierarchy, <span class="type">int</span> mode, <span class="type">int</span> method, Point offset = Point())</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>在二值图像中查找轮廓</strong>。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">image</td>
<td style="text-align:center">二值输入图像</td>
</tr>
<tr>
<td style="text-align:center">contours</td>
<td style="text-align:center">检测到的轮廓，每个轮廓都存储为点向量（例如 <code>std::vector&lt;std::vector&lt;cv::Point&gt; &gt;</code>）</td>
</tr>
<tr>
<td style="text-align:center">hierarchy</td>
<td style="text-align:center">可选的输出向量（例如 <code>std::vector&lt;cv::Vec4i&gt;</code>），包含有关图像拓扑的信息</td>
</tr>
<tr>
<td style="text-align:center">mode</td>
<td style="text-align:center">轮廓检索模式</td>
</tr>
<tr>
<td style="text-align:center">method</td>
<td style="text-align:center">轮廓近似方式</td>
</tr>
<tr>
<td style="text-align:center">offset</td>
<td style="text-align:center">每个轮廓点移动的可选偏移量</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">cv::contourArea</span><span class="params">(InputArray contour, <span class="type">bool</span> oriented = <span class="literal">false</span>)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>计算轮廓区域</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">cv::arcLength</span><span class="params">(InputArray curve, <span class="type">bool</span> closed)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>计算曲线长度或闭合轮廓周长</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::approxPolyDP</span><span class="params">(InputArray curve, OutputArray approxCurve, <span class="type">double</span> epsilon, <span class="type">bool</span> closed)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>用另一个具有较少顶点的曲线/多边形来<strong>逼近</strong>一条曲线或多边形，以使他们之间的距离小于或等于指定的精度。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::drawContours</span><span class="params">(InputOutputArray image, InputArrayOfArrays contours, <span class="type">int</span> contourIdx, <span class="type">const</span> Scalar &amp;color, <span class="type">int</span> thickness = <span class="number">1</span>, <span class="type">int</span> lineType = LINE_8, InputArray hierarchy = noArray(), <span class="type">int</span> maxLevel = INT_MAX, Point offset = Point())</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>绘制轮廓轮廓或填充轮廓</strong>。如果厚度 ≥ 0，该函数在图像中绘制轮廓轮廓，如果厚度 &lt; 0，则填充轮廓所包围的区域。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Point_&lt; _Tp &gt; <span class="title">tl</span><span class="params">()</span> <span class="type">const</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>左上角</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Point_&lt; _Tp &gt; <span class="title">br</span><span class="params">()</span> <span class="type">const</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>右下角</li>
</ul>
<hr>
<h2 id="人脸检测"><a href="#人脸检测" class="headerlink" title="人脸检测"></a>人脸检测</h2><p>（挖个坑，这里仅给出速查代码，后面写一篇从原理开始分析的人脸检测）</p>
<p>涉及模块 <code>objdetect:Object Detection</code> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">cv</span>::CascadeClassifier</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>用于对象检测的级联分类器类</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">load</span> <span class="params">(<span class="type">const</span> String &amp;filename)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>从文件加载分类器</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>检测分类器是否已加载。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">detectMultiScale</span><span class="params">(InputArray image, std::vector&lt;Rect&gt; &amp;objects, <span class="type">double</span> scaleFactor=<span class="number">1.1</span>, <span class="type">int</span> minNeighbors=<span class="number">3</span>, <span class="type">int</span> flags=<span class="number">0</span>, Size minSize=Size(), Size maxSize=Size())</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>检测输入图像中不同大小的对象。检测到的对象作为矩形列表返回。</li>
</ul>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/objdetect.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string path = <span class="string">&quot;Resources/test.png&quot;</span>;</span><br><span class="line">	Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line"></span><br><span class="line">	CascadeClassifier faceCascade;</span><br><span class="line">	faceCascade.<span class="built_in">load</span>(<span class="string">&quot;Resources/haarcascade_frontalface_default.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (faceCascade.<span class="built_in">empty</span>()) &#123; cout &lt;&lt; <span class="string">&quot;XML file not loaded&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;Rect&gt; faces;</span><br><span class="line">	faceCascade.<span class="built_in">detectMultiScale</span>(img, faces, <span class="number">1.1</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; faces.<span class="built_in">size</span>(); i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">rectangle</span>(img, faces[i].<span class="built_in">tl</span>(), faces[i].<span class="built_in">br</span>(), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line">	<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>Git初步学习</title>
    <url>/2024/11/25/Git%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Git入门学习"><a href="#Git入门学习" class="headerlink" title="Git入门学习"></a>Git入门学习</h1><p><strong>Git</strong> 是一种 <strong>分布式版本控制系统</strong>，主要用于管理源代码的版本历史。它能记录文件的每一次改动，让开发者能够随时回溯、更改和协作，从而极大提高了代码开发的效率和安全性。</p>
<p>如果把代码开发比作写一本书，Git 就像一本“时间机器”，能保存每一版的草稿，不小心删掉的内容可以找回来，还能让多人同时编辑不同的章节，最后合并在一起。</p>
<hr>
<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>本人使用Ubuntu 22.04，直接通过如下代码安装Git:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p><strong>step 1</strong>: 我在<code>/</code>下使用如下命令创建空目录 <code>learngit</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mkdir learngit</span><br></pre></td></tr></table></figure>
<p>然后进入这个目录:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd learngit</span><br></pre></td></tr></table></figure>
<p>然后可以<strong>打印工作目录(print working directory)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pwd</span><br><span class="line">/Users/Samxander/learngit</span><br></pre></td></tr></table></figure>
<p><code>pwd</code> 命令用于显示当前的目录。在我的Ubuntu中，这个仓库位于<code>/Users/Samxander/learngit</code>.</p>
<p><strong>step 2:</strong> 通过 <code>git init</code> 命令把这个目录变成Git可以管理的仓库:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure>
<p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库。</p>
<p><strong>step 3:</strong> 把文件添加到版本库</p>
<p>所有的版本控制系统，只能跟踪文本文件的改动，而无法跟踪图片和视频这类二进制文件（Word也是二进制格式）。</p>
<p>现在编写一个 <code>readme.txt</code> 文件，放在 <code>learngit</code>目录下或子目录下。内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure>
<p>特殊地，为创建这个txt文件，我使用的是 <code>Vim</code> 。首先在终端输入如下代码（<strong>在learngit目录下</strong>！！）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vim readme.txt</span><br></pre></td></tr></table></figure>
<p>随后按下 <code>i</code> 键进入<strong>插入模式</strong>，随后输入内容。输入完成后，按下 <code>Esc</code> 键退出插入模式，输入 <code>:wq</code> 保存并退出。</p>
<p>用命令 <code>git commit</code> 告诉Git，把文件提交到仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;wrote a readme file&quot;</span><br></pre></td></tr></table></figure>
<p>注意：<code>-m</code> 后面输入的是本次提交的说明，可以输入任意内容。内容最好是<strong>有意义的</strong>，这样就能从历史记录里方便地找到改动记录。</p>
<p><code>git commit</code>命令执行成功后会告诉你，<code>1 file changed</code>：1个文件被改动（我们新添加的readme.txt文件）；<code>2 insertions</code>：插入了两行内容（readme.txt有两行内容）。</p>
<hr>
<h2 id="时光机穿梭"><a href="#时光机穿梭" class="headerlink" title="时光机穿梭"></a>时光机穿梭</h2><p>我已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了。于是，我继续修改readme.txt文件，改成如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure>
<p>随后运行 <code>git status</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure>
<p>命令输出告诉我们，<code>readme.txt</code>被修改过了，但还没有准备提交的修改。</p>
<p>如果想看看具体修改了什么，可以使用 <code>git diff</code> 查看修改了什么内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git diff readme.txt </span><br><span class="line"></span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 46d49bf..9247db6 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system.</span><br><span class="line">+Git is a distributed version control system.</span><br><span class="line"> Git is free software.</span><br></pre></td></tr></table></figure>
<p>可以从上面的命令输出看到，我们在第一行添加了一个<code>distributed</code>单词。</p>
<p>知道了对<code>readme.txt</code>作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是<code>git add</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure>
<p>然后我们运行<code>git status</code>查看当前仓库的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line"></span><br><span class="line">位于分支 master</span><br><span class="line">要提交的变更:</span><br><span class="line">   (使用 &quot;git restore --staged &lt;文件&gt;...&quot; 以取消暂存)</span><br><span class="line">		修改:		 readme.txt</span><br></pre></td></tr></table></figure>
<p><code>git status</code>告诉我们，将要被提交的修改包括<code>readme.txt</code>，下一步，就可以放心地使用 <code>git commit</code> 提交了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;add distributed&quot;</span><br></pre></td></tr></table></figure>
<p>提交后，我们再用<code>git status</code>命令看看仓库的当前状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line"></span><br><span class="line">位于分支master</span><br><span class="line">无文件要提交，干净的工作区</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>（练习：将第二行加上GPL，并提交)</p>
<p>现在共进行了三个版本的提交，分别是 <code>wrote a readme file</code>, <code>add distributed</code>, <code>append GPL</code>.</p>
<p>在实际工作中，版本控制系统肯定有命令可以告诉我们历史记录。在Git中，我们用 <code>git log</code> 查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log</span><br><span class="line"></span><br><span class="line">commit 9e000ba1df429c0aa9d972325d9847368ed1c584 (HEAD -&gt; master)</span><br><span class="line">Author: Samxander &lt;weijiazhe123@mail.nwpu.edu.cn&gt;</span><br><span class="line">Date:   Mon Nov 25 18:38:53 2024 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit d7c8172e14e38f27ccb901e01bf3c7e4eee8c35f</span><br><span class="line">Author: Samxander &lt;weijiazhe123@mail.nwpu.edu.cn&gt;</span><br><span class="line">Date:   Mon Nov 25 18:30:46 2024 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit 0998895744bfbd854f6d74792da039c0d3b2c7de</span><br><span class="line">Author: Samxander &lt;weijiazhe123@mail.nwpu.edu.cn&gt;</span><br><span class="line">Date:   Mon Nov 25 17:25:26 2024 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure>
<p><code>git log</code>命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是<code>append GPL</code>，上一次是<code>add distributed</code>，最早的一次是<code>wrote a readme file</code>。</p>
<p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line"></span><br><span class="line">9e000ba1df429c0aa9d972325d9847368ed1c584 (HEAD -&gt; master) attend GPL</span><br><span class="line">d7c8172e14e38f27ccb901e01bf3c7e4eee8c35f add distributed</span><br><span class="line">0998895744bfbd854f6d74792da039c0d3b2c7de wrote a readme file</span><br></pre></td></tr></table></figure>
<p>好了，现在我们启动时光穿梭机，准备把<code>readme.txt</code>回退到上一个版本，也就是<code>add distributed</code>的那个版本，怎么做呢？</p>
<p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>9e000ba1df429c0aa9d972325d9847368ed1c584</code> , 上一个版本是<code>HEAD^</code>，上上一个版本是<code>HEAD^^</code>，往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p>
<p>现在，我们要把当前版本<code>append GPL</code>回退到上一个版本<code>add distributed</code>，就可以使用<code>git reset</code>命令：</p>
<figure class="highlight plaintext"><figcaption><span>git</span></figcaption><table><tr><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line"></span><br><span class="line">HEAD 现在位于 d7c8172 add distributed</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong><code>--hard</code>会回退到上个版本的<strong>已提交</strong>状态，而<code>--soft</code>会回退到上个版本的<strong>未提交</strong>状态，<code>--mixed</code>会回退到上个版本<strong>已添加但未提交</strong>的状态。现在，先放心使用<code>--hard</code>。</p>
<p>现在看看<code>readme.txt</code> 的内容是不是版本 <code>add distributed</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line"></span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure>
<p>果然被还原了。</p>
<p>让我们用<code>git log</code>再看看现在版本库的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log</span><br><span class="line"></span><br><span class="line">commit d7c8172e14e38f27ccb901e01bf3c7e4eee8c35f (HEAD -&gt; master)</span><br><span class="line">Author: Samxander &lt;weijiazhe123@mail.nwpu.edu.cn&gt;</span><br><span class="line">Date:   Mon Nov 25 18:30:46 2024 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit 0998895744bfbd854f6d74792da039c0d3b2c7de</span><br><span class="line">Author: Samxander &lt;weijiazhe123@mail.nwpu.edu.cn&gt;</span><br><span class="line">Date:   Mon Nov 25 17:25:26 2024 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure>
<p>最新的那个版本<code>append GPL</code>已经看不到了。若要回到那个版本，只要上面的命令行窗口还没有被关掉，就可以找到那个 <code>append GPL</code> 的 <code>commit id</code>是 <code>9e000ba1...</code>，于是就可以指定回到未来的某个版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reset --hard 9e000ba1</span><br><span class="line"></span><br><span class="line">HEAD 现在位于 9e000ba attend GPL</span><br></pre></td></tr></table></figure>
<p>再查看<code>readme.txt</code> 的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure>
<p>若回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的<code>commit id</code>怎么办？</p>
<p>在Git中，总是有后悔药可以吃的。当用<code>$ git reset --hard HEAD^</code>回退到<code>add distributed</code>版本时，再想恢复到<code>append GPL</code>，就必须找到<code>append GPL</code>的commit id。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line"> </span><br><span class="line">9e000ba (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 9e000ba1</span><br><span class="line">d7c8172 HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">9e000ba (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: attend GPL</span><br><span class="line">d7c8172 HEAD@&#123;3&#125;: commit: add distributed</span><br><span class="line">0998895 HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><p><strong>工作区</strong></p>
<p>个人理解，工作区就是电脑里面能直接看到的目录。例如创建的 <code>learngit</code> 文件夹就是一个工作区。</p>
<p><strong>版本库</strong></p>
<p>工作区里有一个隐藏的目录 <code>.git</code>，这不算工作区，而是Git的版本库。这里面存了很多东西，其中最重要的就是称为 <code>stage</code> 的<strong>暂存区</strong>，还有Git自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针 <code>HEAD</code>。</p>
<p><code>git add</code> 命令实际上就是把要提交的所有修改放到暂存区，然后执行 <code>git commit</code>就可以一次性地把暂存区的所有修改提交到分支。</p>
<p><strong>实践验证：</strong></p>
<p>先对 <code>readme.txt</code> 做出修改：在后面添加一行内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br></pre></td></tr></table></figure>
<p>然后，在工作区新建一个 <code>LICENSE</code> 文本文件。</p>
<p>先用 <code>git status</code> 查看一下状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line"></span><br><span class="line">位于分支 master</span><br><span class="line">尚未暂存以备提交的变更：</span><br><span class="line">  （使用 &quot;git add &lt;文件&gt;...&quot; 更新要提交的内容）</span><br><span class="line">  （使用 &quot;git restore &lt;文件&gt;...&quot; 丢弃工作区的改动）</span><br><span class="line">	修改：     readme.txt</span><br><span class="line"></span><br><span class="line">未跟踪的文件:</span><br><span class="line">  （使用 &quot;git add &lt;文件&gt;...&quot; 以包含要提交的内容）</span><br><span class="line">	LICENSE</span><br><span class="line"></span><br><span class="line">修改尚未加入提交（使用 &quot;git add&quot; 和/或 &quot;git commit -a&quot;）</span><br></pre></td></tr></table></figure>
<p>Git说，<code>readme.txt</code> 被修改了，而 <code>LICENSE</code> 还从来没有被添加过，所以显示他是<strong>未跟踪的</strong>。</p>
<p>现在，使用两次 <code>git add</code>，把 <code>readme.txt</code> 和 <code>LICENSE</code> 都添加后，用 <code>git status</code> 再查看一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line"></span><br><span class="line">位于分支 master</span><br><span class="line">要提交的变更：</span><br><span class="line">  （使用 &quot;git restore --staged &lt;文件&gt;...&quot; 以取消暂存）</span><br><span class="line">	新文件：   LICENSE</span><br><span class="line">	修改：     readme.txt</span><br></pre></td></tr></table></figure>
<p>所以，<code>git add</code>命令实际上就是把要提交的所有修改放到暂存区，然后执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;understand how stage works&quot;</span><br><span class="line"></span><br><span class="line">[master d25e97f] understand how stage works</span><br><span class="line"> 2 files changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 LICENSE</span><br></pre></td></tr></table></figure>
<p>一旦提交后，如果没有对工作区做任何修改，那么工作区就是“干净”的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line"></span><br><span class="line">位于分支 master</span><br><span class="line">无文件要提交，干净的工作区</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h3><p>Git跟踪并管理的是<strong>修改而非文件</strong>。若要提交二次修改，要遵循以下流程：</p>
<p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git add</code> -&gt; <code>git commit</code></p>
<hr>
<h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p>场景1：当改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p>
<p>场景2：当不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p>
<p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，使用<strong>版本回退</strong>，不过前提是没有推送到远程库。</p>
<hr>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>在Git中，删除也是一个修改操作。先添加一个新文件<code>test.txt</code>到Git并提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;add test.txt&quot;</span><br><span class="line"></span><br><span class="line">[master a511415] add test.txt</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 test.txt</span><br></pre></td></tr></table></figure>
<p>一般情况下，直接在文件管理器中把没用的文件删除，或者用<code>rm</code>命令删除：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ rm test.txt</span><br></pre></td></tr></table></figure>
<p>这个时候，Git知道删除了文件，因此，工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line"></span><br><span class="line">位于分支 master</span><br><span class="line">尚未暂存以备提交的变更：</span><br><span class="line">  （使用 &quot;git add/rm &lt;文件&gt;...&quot; 更新要提交的内容）</span><br><span class="line">  （使用 &quot;git restore &lt;文件&gt;...&quot; 丢弃工作区的改动）</span><br><span class="line">	删除：     test.txt</span><br><span class="line"></span><br><span class="line">修改尚未加入提交（使用 &quot;git add&quot; 和/或 &quot;git commit -a&quot;）</span><br></pre></td></tr></table></figure>
<p>现在有两个选择，一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git rm test.txt</span><br><span class="line"></span><br><span class="line">rm &#x27;test.txt&#x27;</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;remove test.txt&quot;</span><br><span class="line"></span><br><span class="line">[master 67c1822] remove test.txt</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 test.txt</span><br></pre></td></tr></table></figure>
<p>现在，文件就从版本库中被删除了。</p>
<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout -- test.txt</span><br></pre></td></tr></table></figure>
<p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>
<p>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么永远不用担心误删。但是要小心，只能恢复文件到最新版本，会丢失<strong>最近一次提交后你修改的内容</strong>。</p>
<hr>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h3 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h3><p>现在，在本地创建了一个 <code>Git</code> 仓库后，我们要在 <code>Github</code> 上创建一个 <code>Git</code> 仓库，并且让两个仓库进行远程同步。</p>
<p>首先，登录 <code>Github</code> ，然后创建一个新仓库。创建完成之后，复制网址，输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote add origin git@github.com:&lt;Github账户名&gt;/&lt;仓库名&gt;.git</span><br></pre></td></tr></table></figure>
<p>使用 <code>git push</code> 命令，将本地库的内容推送到远程，使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure>
<p>也就是把当前分支 <code>master</code> 推送到远程。因为远程库是空的，所以加上了 <code>-u</code> 参数。以后的推送或拉取时，就可以简化命令。于是，只要本地做了提交，就可以通过如下命令，把本地分支的最新修改推送到 <code>Github</code> ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
<p><strong>删除远程库</strong></p>
<p>如果添加的时候地址写错了，或者就是想删除远程库，可以用 <code>git remote rm &lt;name&gt;</code> 命令。</p>
<hr>
<h3 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h3><p>首先，我们需要知道仓库的地址，随后使用 <code>git clone</code> 进行克隆。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:&lt;Github账户名&gt;/&lt;仓库名&gt;.git</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2>]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>TOPSIS法</title>
    <url>/2025/01/17/TOPSIS%E6%B3%95/</url>
    <content><![CDATA[<h1 id="TOPSIS法"><a href="#TOPSIS法" class="headerlink" title="TOPSIS法"></a>TOPSIS法</h1><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p><strong>1.指标类型：</strong></p>
<ul>
<li><strong>效益型</strong>属性：<strong>越大越好</strong>的属性，例如上述人均专著、科研经费。</li>
<li><strong>成本型</strong>属性：<strong>越小越好</strong>的属性，例如逾期毕业率。</li>
<li><strong>区间型</strong>属性：<strong>在某一区间内最好</strong>，过大或过小都不好，例如师生比。</li>
</ul>
<p>显然的是，求<strong>效益型</strong>属性无需处理；而对于<strong>成本型</strong>属性，求<strong>正理想解</strong>时对其取<strong>最小值</strong>，求<strong>负理想解</strong>时对其取<strong>最大值</strong>；而对于<strong>区间型</strong>属性，根据<strong>数据与最优区间</strong>的<strong>差异</strong>进行处理。</p>
<p><strong>2.区间型属性的变换</strong></p>
<ul>
<li>设第 $j$ 个指标的最优属性区间为 $[ a_j^0, a_j^*]$ ， $a_j^{\prime}$ 为无法容忍下限， $a_j^{\prime\prime}$ 为无法容忍上限，则：</li>
<li>若在最优属性区间内，值<strong>设为1</strong>；超出可容忍的范围，值<strong>设为0</strong>。</li>
<li>不在最优区间内，但是还在可接受的范围内，按公式改为<strong>0到1之间的值</strong>。</li>
</ul>
<p><strong>3.向量规范化</strong>：</p>
<ul>
<li><p>无论成本型属性还是效益型属性，都用相同公式进行变换：</p>
<p>$b_{ij} = \frac{a_{ij}}{\sqrt{\sum_{i=1}^{m} a_{ij}^2}}$</p>
</li>
<li><p>规范化后的数值，同一属性值(评价指标)的<strong>平方和为1</strong>。</p>
</li>
<li><p>确保不同评价指标在同一数量级(0到1之间)。</p>
</li>
<li><p><strong>变换前后，每个属性值</strong>(评价指标)中的数据的<strong>大小排序不变</strong>。</p>
</li>
</ul>
<h2 id="加权处理"><a href="#加权处理" class="headerlink" title="加权处理"></a>加权处理</h2><p><strong>不同指标的重要性不同</strong></p>
<ul>
<li>与AHP的两两比较不同，TOPSIS法直接给每个指标加上权重。</li>
<li>因为TOPSIS法充分利用了数据的差异，只要权重设置的不是太离谱，对结果影响不会太大。</li>
</ul>
<h2 id="最终求解"><a href="#最终求解" class="headerlink" title="最终求解"></a>最终求解</h2><p><strong>求解思路</strong></p>
<ul>
<li><p>对第 $j$ 个属性(指标)的正理想解：</p>
<script type="math/tex; mode=display">c_j^* =  \begin{cases}  \max_i c_{ij}, & \text{ } j \text{ 是效益型属性} \\ \min_i c_{ij}, & \text{ } j \text{ 是成本型属性} \end{cases}</script></li>
<li><p>对第 $j$ 个属性(指标)的负理想解：</p>
<script type="math/tex; mode=display">c_j^0 =  \begin{cases}  \min_i c_{ij}, & \text{ } j \text{ 是效益型属性} \\ \max_i c_{ij}, & \text{ } j \text{ 是成本型属性} \end{cases}</script></li>
<li><p>第 $i$ 个方案到正理想解的距离：</p>
<p>  $s_i^{*} = \sqrt{\sum_{j=1}^n (c_{ij}-c_j^{*})^2}$</p>
</li>
<li><p>第 $j$个方案到负理想解的距离：</p>
<p>  $s_i^{0} = \sqrt{\sum_{j=1}^n (c_{ij}-c_j^0)^2}$</p>
</li>
</ul>
<p><strong>最终求解：</strong></p>
<ul>
<li><p>各方案的<strong>综合评价指数</strong>：$f_i^{*} = \frac{s_i^0}{s_i^0+s_i^{*}} = \frac{1}{1+\frac{s_i^*}{s_i^0}}$</p>
</li>
<li><p>显然，距离正理想解越近 ($s_i^*$ 越小)，距离负理想解越远 ($s_i^0$ 越大)越好。</p>
</li>
<li><p>按 $f_i^*$ 从大到小排序方案的优劣，即为所求。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title>五种排序方法(冒泡、选择、插入、归并和快排)</title>
    <url>/2024/10/19/%E4%BA%94%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95-%E5%86%92%E6%B3%A1%E3%80%81%E9%80%89%E6%8B%A9%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E5%BD%92%E5%B9%B6%E5%92%8C%E5%BF%AB%E6%8E%92/</url>
    <content><![CDATA[<h2 id="冒泡排序-稳定"><a href="#冒泡排序-稳定" class="headerlink" title="冒泡排序(稳定)"></a>冒泡排序(稳定)</h2><p><strong>特点</strong>:从后<strong>两两对比</strong>,更小的往前放.  </p>
<p><strong>时间复杂度</strong>:最坏情况<code>O(n)</code>,最好情况<code>O(n^2)</code>.  </p>
<h2 id="选择排序-不稳定"><a href="#选择排序-不稳定" class="headerlink" title="选择排序(不稳定)"></a>选择排序(不稳定)</h2><p><strong>特点</strong>:每次从待排序列中选出一个<strong>最小值</strong>,然后放在序列的起始位置,直至排完.</p>
<p><strong>时间复杂度</strong>:<code>O(n^2)</code>.  </p>
<h2 id="插入排序-稳定"><a href="#插入排序-稳定" class="headerlink" title="插入排序(稳定)"></a>插入排序(稳定)</h2><p><strong>特点</strong>:从<strong>第下个元素开始</strong>,从已排序的元素序列<strong>从后往前</strong>扫描,如果该元素<strong>大于</strong>tem,<strong>则将该元素移至下一位</strong>.重复该步骤,直到找到已排序元素中<strong>小于等于</strong>tem的元素.tem插入到该元素的<strong>后面</strong>,如果已排序所有元素都大于tem,则将tem插入到下标为0的位置.<br><strong>一直重复上述步骤,直至排序完成</strong>.   </p>
<p><strong>时间复杂度</strong>:最坏情况<code>O(n^2)</code>,最好情况<code>O(n)</code>.</p>
<h2 id="归并排序-稳定"><a href="#归并排序-稳定" class="headerlink" title="归并排序(稳定)"></a>归并排序(稳定)</h2><p><strong>特点</strong>:采用<strong>分治算法</strong>.  </p>
<ul>
<li><strong>分</strong>:将待排序的线性表不断地<strong>切分</strong>成若干个子表,直到每个子表<strong>只包含一个元素</strong>,这时,可以认为只包含一个元素的子表是有序表.  </li>
<li><strong>治</strong>:将子表<strong>两两合并</strong>,每合并一次,就会产生一个新的且更长的有序表,<strong>重复这一步骤,直到最后只剩下一个子表</strong>,这个子表就是排好序的线性表.  </li>
</ul>
<p><strong>时间复杂度</strong>:<code>O(nlogn)</code>.</p>
<h2 id="快速排序-不稳定"><a href="#快速排序-不稳定" class="headerlink" title="快速排序(不稳定)"></a>快速排序(不稳定)</h2><blockquote>
<p>是对<strong>冒泡排序</strong>的一种改进  </p>
</blockquote>
<p><strong>特点</strong>:通过一趟排序将要排序的数据分割成<strong>独立的两部分</strong>，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以<strong>递归</strong>进行，以此达到整个数据变成有序序列。  </p>
<ul>
<li><p>排序流程:  </p>
<ol>
<li>首先设定一个<strong>分界值Key</strong>,通过该分界值将数组分成左右两部分.</li>
<li>将<em>大于或等于Key的数据集中到数组右边,小于分界值的数据集中到数组的左边</em>.此时,左边部分中各元素都小于或等于分界值,而右边部分中各元素都大于或等于分界值.</li>
<li>然后,左边和右边的数据可以独立排序.对于左侧的数组数据,又可以取一个分界值,将该部分数据分成左右两部分,同样在左边放置较小值,右边放置较大值.右侧的数组数据也可以做类似处理.</li>
<li>重复上述过程,可以看出,这是一个<strong>递归定义</strong>.通过递归将左侧部分排好序后,再递归排好右侧部分的顺序.当左右两个部分各数据排序完成后,整个数组的排序也就完成了.</li>
</ol>
</li>
</ul>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>一些感想</title>
    <url>/2025/04/14/%E4%B8%80%E4%BA%9B%E6%84%9F%E6%83%B3/</url>
    <content><![CDATA[<h2 id="第二学期过半的一些感想"><a href="#第二学期过半的一些感想" class="headerlink" title="第二学期过半的一些感想"></a>第二学期过半的一些感想</h2><p>一眨眼已经过去了一个半学期，不得不感慨时间过得如此之快。在这一个半学期的学习和探索中，我对未来的方向也有了一点初步的规划。当然，这些规划能否实现，最终还是基于自己的付出，否则一切目标都是空中楼阁。</p>
<h3 id="一、第一学期的学业成绩"><a href="#一、第一学期的学业成绩" class="headerlink" title="一、第一学期的学业成绩"></a>一、第一学期的学业成绩</h3><p>总的来说，我第一学期的绩点处于一个不上不下的位置 (35%)，<strong>离保研</strong> (15%) <strong>仍有不少距离</strong>，也与我的预期<strong>相差甚远</strong>。</p>
<p>分析一下，可以得出一些结论：</p>
<ol>
<li>错误的估计了微积分的难度。我对微积分期末的重视程度不如期中，导致我在难度稍大的期末中遇到了很多做起来吃力的题，最终导致这门大课绩点只有 3.7。</li>
<li>对所谓”水课”的重视程度不够。我军理的成绩只有 2.7，大心的成绩只有 3.7，史纲的成绩只有 3.3。这些学分也不算少，但是的的确确成为了拖分的科目。</li>
</ol>
<p>总的来说，第一学期可以作为一个“<strong>试错</strong>”的学期。通过参照这个学期，我可以在今后改善自己的学习方式，优化自己的选课策略等等。学业成绩是不可忽视的一个东西，它是保研的垫脚石，是保外的敲门砖。如果绩点不够高，即使拿到了保内资格，也难以通过外校参营的机筛。</p>
<p>因此，这一学期，在诸多 “水课” 以及优化后学习方法的加持下，希望我能在绩点上实现新的突破。</p>
<h3 id="二、技术学习"><a href="#二、技术学习" class="headerlink" title="二、技术学习"></a>二、技术学习</h3><p>在这一个半学期的学习当中，我学习并探索了很多学习路径和方向。总的来说，我精进了我的<strong>编程能力</strong>，学习了一些<strong>ROS</strong>的基础知识，学习了 <code>SLAM</code> 建图和 <code>ACML</code> 导航，也进行了 <code>YOLO v8</code> 的初步训练(当然，内部结构还不是很了解)。</p>
<p>接下来，我渴望尝试的方向包括且不限于以下这些：</p>
<ol>
<li><strong>ML</strong>和<strong>DL</strong></li>
<li><strong>计算机视觉</strong></li>
<li><strong>嵌入式开发</strong></li>
</ol>
<p>当然，这些内容要想都熟稔于心的话，难度是非常大的。</p>
<p>单论DL而言，模型之多，内部结构之复杂都让学习的过程充满困难，并且网上很多所谓“入门”教程都并不全然适合初学者。因此，挑选一个适合自己的教程是非常重要的。目前，我在B站上看到 <strong>3Blue1Brown</strong> 的深度学习教程还算不错，简要介绍了神经网络的<strong>结构</strong>、<strong>梯度下降</strong>、<strong>反向传播</strong>以及 <strong>Transformer</strong> 等等。希望自己能够跟着学下来。</p>
<h3 id="三、未来方向的规划"><a href="#三、未来方向的规划" class="headerlink" title="三、未来方向的规划"></a>三、未来方向的规划</h3><p>在这些时间里，我对自己想要 dive into 的领域，以及将来想要从事的方向有了一些初步的想法。</p>
<p>首先，我最想从事的是<strong>计算机视觉方向</strong>，也就是<strong>CV</strong>。不过随着计算机领域热潮迭起，CV方向已经成了超级大热门，比如南大的 Lamda，这个组里只有几个老师做CV，他们每年的名额都是爆满。其他学校的情况也大差不差。因此，选择CV，意味着竞争会非常激烈，因此，还是斟酌一下是否确定要选择这个方向。</p>
<p>其次，由于我成功加入了<strong>舞蹈机器人基地</strong>和<strong>智能无人系统创新实践基地</strong>，我在接下来的一两年内必然会致力于机器人相关的开发，因此，我也可以考虑做<strong>机器人方向</strong>。当然，机器人与自动化强绑定，而西工大的自动化似乎并没有计算机好 (机器人工程也是不久前开设的专业，确实不够了解)，所以如果要做机器人方向，我可能需要考虑保外，寻找一个自动化/机器人不错的学校。</p>
<p>最后，对于本专业的内容，我似乎<strong>并没有那么感兴趣</strong>。但是至于转专业与否，也有待商榷。不过，电信是全学校最卷的专业，对于同一百分比的rank，可能电信需要比别的学院更高的绩点，因此，我仍然需要好好考虑一下本专业的具体情况，再做出抉择。</p>
<h3 id="四、学业知识拓展"><a href="#四、学业知识拓展" class="headerlink" title="四、学业知识拓展"></a>四、学业知识拓展</h3><p>关于我想要主攻计算机并保外的打算，对应的是我需要学习一些额外的课程。</p>
<p>计算机专业需要学习但电信不学的课程包括且不限于：<strong>数据结构</strong>、<strong>计算机组成原理</strong>、<strong>操作系统</strong>、<strong>计算机网络</strong>、离散数学和编译原理等等。</p>
<p>其中，前四个课程组成了<strong>408</strong>。因为我有保外的想法，故408必然会成为学习的重点 (当然，微积分和线性代数也极其重要)。所以，我打算在下半个学期和暑假大致过掉 408 中至少两门课程，并且优先学习<strong>数据结构</strong>和<strong>操作系统</strong>。</p>
<p>对于<strong>数据结构</strong>，我有一些初步的了解，比如 <code>bfs</code> 需要用到的队列，比如二叉树的遍历，又比如图论里的 <code>Dijkstra</code> 算法等等。但是我学过的大多与 <code>C++</code> 的 <code>STL</code> 相关，而我要学习的是严蔚敏的 C 语言版数据结构，因此，在实际的学习过程中，仍需注意把握与 <code>C++</code> 写法的区别和联系。</p>
<p>对于<strong>操作系统</strong>，我的了解不多<del>，仅限于 Windows 和 Linux 的使用</del>。但是，在网上冲浪的过程中，我了解到了南大的<strong>蒋炎岩</strong>老师，他在 B 站上长期发布自己教授操作系统的实录。今天 (4.11) 我听了一节，感觉老师对很多东西的把握鞭辟入里也不落窠臼，希望自己能够跟着他，把操作系统大致过一遍。</p>
<p>我对剩下几门课的了解并不多，但也希望自己到时候能够积极去寻找资源，争取扎实地过一遍或几遍。</p>
<h3 id="五、竞赛相关"><a href="#五、竞赛相关" class="headerlink" title="五、竞赛相关"></a>五、竞赛相关</h3><p>在这一个半学期，我并没有参加过多的竞赛。一方面是精力实在不足，另一方面自己的实力也确实没有到打各种比赛的水平。我目前参加的竞赛只有：<strong>美赛</strong>和<strong>大英赛</strong>。</p>
<p>因此，在后期，我可以着手考虑要参加哪些竞赛：</p>
<p>计算机方面：先把<strong>比较基础的算法</strong>系统性的学习并梳理，比如最简单的<strong>贪心、分治、二分、深搜广搜、二叉树、dp、图论</strong>等等。学习完成后，可以从基础的<strong>蓝桥杯</strong>开始，甚至参加 <strong><code>XCPC</code></strong> 的比赛。这个学习的成本相当高，不过相应地，如果能够获得一些奖项，对于保外的帮助会是<strong>非常可观</strong>的。</p>
<p>其余方面：由于进入了基地，打一些<strong>机器人</strong>的比赛是水到渠成的，这无需多言。此外，可以考虑参加<strong>电赛</strong>，当然，这要看我未来的打算。如果不在本专业待的话，电赛的收益不大。</p>
<p>剩下就是诸如<strong>数学建模比赛、数学竞赛、英语竞赛</strong>等等。</p>
<p><strong>数模比赛</strong>仍需要一定的算法知识，甚至牵扯到 ML 和 DL 这些。对于 NP-hard 问题，可能会用到诸如<strong>模拟退火算法</strong>；对于图论相关问题，可能用到<strong>单源最短路径</strong>相关；而对于经典的时间序列预测，可能会用到 <code>GM</code> <code>ARIMA</code> 这类传统算法，也可能会用到 <code>LSTM</code> <code>GNN</code> 这些<strong>深度学习</strong>算法。因此，我认为这是有必要打的一个比赛。</p>
<p>而至于<strong>数学英语竞赛</strong>，就随缘打了。数学并不是我的强项，但是有机会的话可以尝试 (说不定就获奖了呢哈哈)；而英语是我<strong>擅长并喜爱</strong>的学科，并且参加大英赛也是一种英语能力的证明 (英语能力在保外中的重要性无需多言)。因此，每年的大英赛希望我都能参加。</p>
<p>剩下的比赛，感兴趣的话可以参加，不过优先级可能不如上面列出的那些。</p>
<h3 id="六、科研实习"><a href="#六、科研实习" class="headerlink" title="六、科研实习"></a>六、科研实习</h3><p>科研实习，在保外的重要性无需多言。如果没有一个完整跟进过的项目，抑或如果没有一篇署名的论文，那么在夏令营或预推免的面试中，你无法证明你的科研能力，甚至可能会出现面试官与你聊不起来的情况。那么，你又谈何从众多参营者中脱颖而出，拿到优营呢？</p>
<p>因此，我需要<strong>在升大二前的那个暑假</strong>，联系一位本校的老师做<strong>科研实习</strong>。目前，我有几个人选，他们都是做计算机视觉相关的方向：</p>
<ul>
<li>lb，电子信息学院。</li>
<li>yjq，计算机学院。</li>
<li>qxl，自动化学院。</li>
</ul>
<p>不过，这些老师也不一定会成为我最终实习的老师。具体情况还是到时候再看，多多咨询学长学姐，去教师主页查看相关信息，打破信息差。</p>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><blockquote>
<p>Had I not seen the sun, I could have borne the shade.</p>
<p>若非见过阳光，我本可忍受黑暗。</p>
</blockquote>
<p>在上大学之前，我从未认真思虑过我的未来。可当我真正踯躅于大学校园，我却看见了更多不曾见过的风景，触碰到了曾遥不可及的光明。</p>
<p>我曾无数次厌弃于自己对理科的全无禀赋，也对自己的懒惰嗤之以鼻；但如今，我完整地跟进了持续一个半学期的舞基考核，也最终进入了梦寐以求的基地；尽管过程曲折，但也终究抵至彼岸。</p>
<p>希望这份对技术的好奇心和热情能永驻我心，届时，我的心灵崖壁上必能掷一树之芳华。</p>
]]></content>
      <tags>
        <tag>闲谈</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法入门(舞萌DX特别版)</title>
    <url>/2024/10/20/Markdown%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8-%E8%88%9E%E8%90%8CDX%E7%89%B9%E5%88%AB%E7%89%88/</url>
    <content><![CDATA[<h2 id="0-1介绍"><a href="#0-1介绍" class="headerlink" title="0.1介绍"></a>0.1介绍</h2><p><code>Markdown</code>是一种轻量级的标记语言，它允许人们使用<strong>纯文本格式</strong>编写文档。因其简单的语法、较少的常用标记符号，以及较短的学习时间(<del>易于速成</del>)，被越来越多的学做爱好者及工作者使用。一旦掌握这种标记语言，将极大地提高效率。 </p>
<p><code>Markdown</code>使用简洁的语法代替排版。相较<code>Word</code>等文字处理软件，<code>Markdown</code>可以做到<strong>手不离开键盘</strong>即可改变字体大小，插入表格、图片、超链接、脚注等。  </p>
<p>但若要实现复杂排版(如左右对齐缩进等)，建议选择<code>Word</code>、<code>Pages</code>等专业软件。  </p>
<h2 id="0-2常用编辑器介绍"><a href="#0-2常用编辑器介绍" class="headerlink" title="0.2常用编辑器介绍"></a>0.2常用编辑器介绍</h2><ol>
<li><code>Typora</code>是一款广受欢迎的轻量级Markdown编辑器。它凭借其优秀的性能和卓越的用户体验，在众多文本编辑工具中脱颖而出。<br><code>Typora</code>采用了所见即所得（WYSIWYG）的设计理念，用户在编辑过程中可实时预览排版效果，无需切换到预览模式，极大地提升了工作效率和编辑体验。<br>但是，Typora已开始收费阶段，价格14.99美元，可供三台设备使用。(<del>建议在csdn等平台多搜搜，你懂的(doge)</del>)</li>
<li><code>vscode</code>不必多说，安装了Markdown扩展即可。可分屏，边写边预览，也很直观。<del>并且vscode免费</del></li>
</ol>
<h2 id="1-标题语法"><a href="#1-标题语法" class="headerlink" title="1.标题语法"></a>1.标题语法</h2><p>要创建标题时，只需在井号(#)后面<strong>空一格</strong>，然后输入要作为标题的文字即可。<strong>#的数量代表了标题的级别</strong>。其中一级标题文字<em>最大</em>，六级<em>最小</em>。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例:#### 舞萌2024</span><br><span class="line">##### Lv.14+</span><br><span class="line">###### VERTEX(rintaro soma deconstructed remix)</span><br></pre></td></tr></table></figure><br><strong>实际效果</strong>:</p>
<h4 id="舞萌2024"><a href="#舞萌2024" class="headerlink" title="舞萌2024"></a>舞萌2024</h4><h5 id="Lv-14"><a href="#Lv-14" class="headerlink" title="Lv.14"></a>Lv.14</h5><h6 id="VERTEX-rintaro-soma-deconstructed-remix"><a href="#VERTEX-rintaro-soma-deconstructed-remix" class="headerlink" title="VERTEX(rintaro soma deconstructed remix)"></a>VERTEX(rintaro soma deconstructed remix)</h6><p>是不是很简单？  </p>
<h2 id="2-字体设置斜体、粗体、删除线"><a href="#2-字体设置斜体、粗体、删除线" class="headerlink" title="2.字体设置斜体、粗体、删除线"></a>2.字体设置斜体、粗体、删除线</h2><p>这里需要用到这几个字符:<code>*</code> <code>_</code>  <code>~</code>  </p>
<p><strong>斜体</strong>  </p>
<ul>
<li><p>只需在要变为斜体的语句前后各添加一个 * 或 _ 即可。  </p>
<p>示例:<code>*PANDORA PARADOXXX*</code>或<code>_PANDORA PARADOXXX_</code></p>
</li>
<li><p><strong>实际效果</strong>:<br> <em>PANDORA PARADOXXX</em>  </p>
</li>
</ul>
<p><strong>粗体</strong>  </p>
<ul>
<li><p>只需在要变为粗体的语句前后各添加两个 * 即可。   </p>
<p>示例:<code>**Qzkago Requiem**</code></p>
</li>
<li><p><strong>实际效果</strong>:<br> <strong>Qzkago Requiem</strong></p>
</li>
</ul>
<p><strong>倾斜加粗</strong></p>
<ul>
<li><p>只需在要变为倾斜加粗的语句前后各添加三个 * 即可。</p>
<p>示例:<code>***Garakuta Doll Play***</code></p>
</li>
<li><p><strong>实际效果</strong>:<br> <strong><em>Garakuta Doll Play</em></strong>  </p>
</li>
</ul>
<p><strong>删除线</strong>  </p>
<ul>
<li>只需在要添加删除线的语句前后各添加两个 ~ 即可。</li>
</ul>
<p>示例:<code>~~白茄子是15~~</code>  </p>
<ul>
<li><strong>实际效果</strong>:<br><del>白茄子是15</del>  <h2 id="3-代码块"><a href="#3-代码块" class="headerlink" title="3.代码块"></a>3.代码块</h2></li>
</ul>
]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型:结构体</title>
    <url>/2024/10/20/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>在实际问题中，仅仅使用整型(<code>int</code> <code>long long</code>)，浮点型(<code>float</code> <code>double</code>)，字符型(<code>char</code>)以及数组、字符串这些数据类型经常不够。有时候我们需要其中的几种<strong>一起</strong>来修饰某个变量，例如一个学生的信息就需要<code>学号</code>(字符串)，<code>姓名</code>(字符串)，<code>年龄</code>(整型)等等。这些数据类型都不同，但是它们又要表示一个整体，要存在联系，那么我们就需要一个新的数据类型。   </p>
<p><strong>结构体</strong>就能将不同类型的数据存放在一起，作为个整体进行处理。  </p>
<p>结构体的声明：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tag</span><span class="comment">//申明一个结构体</span></span><br><span class="line">&#123;</span><br><span class="line">    member1;</span><br><span class="line">    member2;</span><br><span class="line">&#125;variable-list;</span><br><span class="line"><span class="comment">//▶ struct是结构体关键字</span></span><br><span class="line"><span class="comment">//▶ tag是结构体的标签名，是自定义的</span></span><br><span class="line"><span class="comment">//▶ struct tag就是结构体类型</span></span><br><span class="line"><span class="comment">//▶ &#123;&#125;里面放的是成员列表</span></span><br><span class="line"><span class="comment">//▶ variable-list是变量</span></span><br><span class="line"><span class="comment">//▶ member1 , member2 是结构体成员</span></span><br></pre></td></tr></table></figure><br>结构体也是一种数据类型，它由程序员自己定义，可以包含多个其他类型的数据。</p>
<p>像 int、float、char 等是由C语言本身提供的数据类型，不能再进行分拆，我们称之为<strong>基本数据类型</strong>。  </p>
<p>而结构体可以包含多个基本类型的数据，也可以包含其他的结构体，我们将它称为<strong>复杂数据类型</strong>。  </p>
<p><strong>结构体的基础结构</strong><br>1.先定义结构体类型，再定义结构体变量。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">20</span>];<span class="comment">//结构体成员</span></span><br><span class="line">  <span class="type">char</span> sex;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">float</span> score;</span><br><span class="line">  <span class="type">char</span> addr[<span class="number">30</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> stu1,stu2;<span class="comment">//结构体变量</span></span><br></pre></td></tr></table></figure><br>2.直接定义结构体变量(匿名结构体)。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">  <span class="type">char</span> sex;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="type">float</span> score[<span class="number">3</span>];</span><br><span class="line">&#125;person1,person2;</span><br></pre></td></tr></table></figure><br><strong><em>注意:使用匿名结构体，只能使用一次。无法多次使用一个结构体模块！</em></strong>  </p>
<p><strong>Typedef的引入</strong>:<br>以此为例:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> id;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">float</span> score;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br>在其他地方定义变量时，需要用到<em>数据类型+变量名</em>，如<code>int a;</code> <code>float b;</code> <code>char c;</code>。   </p>
<p>而若要定义结构体变量<code>stu</code>时，利用<em>数据类型+变量名</em>，我们可以自然而然地写出<code>Student stu;</code>。但这样写，编译器可能会报错，提示我们需要在前面加上<code>struct</code>，于是我们应写为：<code>struct Student stu;</code>。  </p>
<p>为方便起见，我们添加一行代码:<code>typedef struct Student Student</code>。或者，可以将上述代码改为:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span><span class="comment">//使用链表等数据类型时，struct后面要加Student.</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> id;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">float</span> score;</span><br><span class="line">&#125;Student;</span><br></pre></td></tr></table></figure></p>
<p>这样我们就可以直接用<code>Student stu</code>来定义结构体变量。  </p>
<p><strong>结构体的嵌套</strong><br>例如，在学生的信息中，需要添加学生的生日信息，则可以使用结构体嵌套。示例代码如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">birthday</span><span class="comment">//可加可不加</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> year;</span><br><span class="line">  <span class="type">int</span> month;</span><br><span class="line">  <span class="type">int</span> day;</span><br><span class="line">&#125;Birthday;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> id;</span><br><span class="line">  <span class="type">char</span> *name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">float</span> score;</span><br><span class="line">  Birthday birthday;<span class="comment">//嵌套使用</span></span><br><span class="line">&#125;Student;</span><br></pre></td></tr></table></figure><br>这样，学生信息里面就包含了学生的生日信息。</p>
<p><strong>结构体变量的赋值</strong><br>录入一个学生的信息，可以通过以下代码实现。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Student stu1=&#123;<span class="number">1001</span>,<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span>,&#123;<span class="number">2006</span>,<span class="number">1</span>,<span class="number">24</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><br><strong>访问结构体成员变量</strong><br>使用点(<code>.</code>)操作符号</p>
<p>e.g.访问学号:<code>stu1.id</code>.<br>访问生日信息中的月份:<code>stu1.birthday.month</code>.   </p>
<p><strong>结构体作为函数的参数</strong><br>例如，要写一个函数，来打印学生信息，写法是:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudentInfo</span><span class="params">(Student stu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;学号:&quot;</span>&lt;&lt;stu.id&lt;&lt;<span class="string">&quot;   &quot;</span>;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;姓名:&quot;</span>&lt;&lt;stu.name&lt;&lt;<span class="string">&quot;   &quot;</span>; </span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;年龄:&quot;</span>&lt;&lt;stu.age&lt;&lt;<span class="string">&quot;   &quot;</span>;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;生日:&quot;</span>&lt;&lt;stu.birthday.year&lt;&lt;<span class="string">&quot;-&quot;</span>;</span><br><span class="line">  cout&lt;&lt;stu.birthday.month&lt;&lt;<span class="string">&quot;-&quot;</span>;</span><br><span class="line">  cout&lt;&lt;stu.birthday.day&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>基于OpenGL的迷宫小游戏</title>
    <url>/2024/11/30/%E5%9F%BA%E4%BA%8EOpenGL%E7%9A%84%E8%BF%B7%E5%AE%AB%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>基于OpenGL库，我使用C语言编写了一个简单的迷宫游戏。游戏具有以下特点：</p>
<ul>
<li>具有简单的图形化界面，使得与用户间有一定的的交互性。</li>
<li>有两张地图可供选择，玩家需在 60 秒内通过键盘上的 <code>W A S D</code> 移动，走到目标点。</li>
<li><del>是我的C语言大作业</del></li>
</ul>
<p>游戏界面如下：</p>
<p><img src="/images/maze1.png" alt="Maze1"></p>
<p><img src="/images/maze2.png" alt="Maze2"></p>
<p>源代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glut.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义迷宫大小和时间限制</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAZE_WIDTH  10 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAZE_HEIGHT 10 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TILE_SIZE   40 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_LIMIT  60 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义多个迷宫地图</span></span><br><span class="line"><span class="type">int</span> maze1[MAZE_HEIGHT][MAZE_WIDTH] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个迷宫地图</span></span><br><span class="line"><span class="type">int</span> maze2[MAZE_HEIGHT][MAZE_WIDTH] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储所有的迷宫地图</span></span><br><span class="line"><span class="comment">// 声明一个指向二维数组的指针数组mazes，每个元素是一个指向二维数组的指针，数组大小为numMazes</span></span><br><span class="line"><span class="built_in">int</span> (*mazes[])[MAZE_HEIGHT][MAZE_WIDTH] = &#123;&amp;maze1, &amp;maze2&#125;;</span><br><span class="line"><span class="type">int</span> numMazes = <span class="built_in">sizeof</span>(mazes) / <span class="built_in">sizeof</span>(mazes[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前选择的迷宫地图索引</span></span><br><span class="line"><span class="type">int</span> selectedMazeIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 玩家起始位置</span></span><br><span class="line"><span class="type">int</span> playerX = <span class="number">1</span>, playerY = <span class="number">1</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于存储玩家按键</span></span><br><span class="line"><span class="type">int</span> keyPress = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 0: 未开始, 1: 游戏中, 2: 游戏胜利, 3: 游戏失败</span></span><br><span class="line"><span class="type">int</span> gameState = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录游戏开始时间</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> startTime; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标点坐标</span></span><br><span class="line"><span class="type">int</span> targetX = MAZE_WIDTH - <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> targetY = MAZE_HEIGHT - <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制单个迷宫格</span></span><br><span class="line"><span class="comment">//x和y为坐标，r为红色，g为绿色，b为蓝色</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawTile</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">float</span> r, <span class="type">float</span> g, <span class="type">float</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">glColor3f</span>(r, g, b);  </span><br><span class="line">    <span class="built_in">glBegin</span>(GL_QUADS);  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绘制一个四边形</span></span><br><span class="line">        <span class="built_in">glVertex2i</span>(x, y);</span><br><span class="line">        <span class="built_in">glVertex2i</span>(x + TILE_SIZE, y);</span><br><span class="line">        <span class="built_in">glVertex2i</span>(x + TILE_SIZE, y + TILE_SIZE);</span><br><span class="line">        <span class="built_in">glVertex2i</span>(x, y + TILE_SIZE);</span><br><span class="line">    <span class="built_in">glEnd</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制整个迷宫</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawMaze</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">int</span> (*maze)[MAZE_HEIGHT][MAZE_WIDTH] = mazes[selectedMazeIndex];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; MAZE_HEIGHT; ++y) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; MAZE_WIDTH; ++x) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*maze)[y][x] == <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 墙壁是黑色的</span></span><br><span class="line">                <span class="built_in">drawTile</span>(x * TILE_SIZE, y * TILE_SIZE, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);  </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 路径是白色的</span></span><br><span class="line">                <span class="built_in">drawTile</span>(x * TILE_SIZE, y * TILE_SIZE, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制玩家</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawPlayer</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 玩家是红色的</span></span><br><span class="line">    <span class="built_in">drawTile</span>(playerX * TILE_SIZE, playerY * TILE_SIZE, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制目标点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawTarget</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 目标点是绿色的</span></span><br><span class="line">    <span class="built_in">drawTile</span>(targetX * TILE_SIZE, targetY * TILE_SIZE, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示游戏剩余时间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayTime</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//声明一个timeval结构体变量currentTime，用于存储当前时间</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> currentTime;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用mingw_gettimeofday函数获取当前时间         </span></span><br><span class="line">    <span class="built_in">mingw_gettimeofday</span>(&amp;currentTime, <span class="literal">NULL</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算经过的秒数       </span></span><br><span class="line">    <span class="type">long</span> secondsElapsed = currentTime.tv_sec - startTime.tv_sec;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算剩余时间</span></span><br><span class="line">    <span class="type">int</span> remainingTime = TIME_LIMIT - (<span class="type">int</span>)secondsElapsed;  </span><br><span class="line"></span><br><span class="line">     <span class="comment">// 定义一个字符数组timeText，用于存储时间文本      </span></span><br><span class="line">    <span class="type">char</span> timeText[<span class="number">16</span>];                     </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 格式化时间文本                     </span></span><br><span class="line">    <span class="built_in">sprintf</span>(timeText, <span class="string">&quot;Time left: %02d&quot;</span>, remainingTime); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置文本颜色为红色        </span></span><br><span class="line">    <span class="built_in">glColor3f</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置文本位置</span></span><br><span class="line">    <span class="built_in">glRasterPos2i</span>(<span class="number">10</span>, <span class="number">10</span>);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; timeText[i]!= <span class="string">&#x27;\0&#x27;</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 逐个绘制字符</span></span><br><span class="line">        <span class="built_in">glutBitmapCharacter</span>(GLUT_BITMAP_HELVETICA_18, timeText[i]);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理键盘输入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processKeys</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> key, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (gameState == <span class="number">1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 下移</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="string">&#x27;s&#x27;</span> || key == <span class="string">&#x27;S&#x27;</span>) </span><br><span class="line">        &#123;                                 </span><br><span class="line">            <span class="keyword">if</span> (playerY &gt; <span class="number">0</span> &amp;&amp; (*mazes[selectedMazeIndex])[playerY - <span class="number">1</span>][playerX] == <span class="number">1</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                playerY--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">&#x27;w&#x27;</span> || key == <span class="string">&#x27;W&#x27;</span>) </span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="comment">// 上移                        </span></span><br><span class="line">            <span class="keyword">if</span> (playerY &lt; MAZE_HEIGHT - <span class="number">1</span> &amp;&amp; (*mazes[selectedMazeIndex])[playerY + <span class="number">1</span>][playerX] == <span class="number">1</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                playerY++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">&#x27;a&#x27;</span> || key == <span class="string">&#x27;A&#x27;</span>) </span><br><span class="line">        &#123;       </span><br><span class="line">        <span class="comment">// 左移                   </span></span><br><span class="line">            <span class="keyword">if</span> (playerX &gt; <span class="number">0</span> &amp;&amp; (*mazes[selectedMazeIndex])[playerY][playerX - <span class="number">1</span>] == <span class="number">1</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                playerX--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">&#x27;d&#x27;</span> || key == <span class="string">&#x27;D&#x27;</span>) </span><br><span class="line">        &#123;      </span><br><span class="line">            <span class="comment">// 右移                    </span></span><br><span class="line">            <span class="keyword">if</span> (playerX &lt; MAZE_WIDTH - <span class="number">1</span> &amp;&amp; (*mazes[selectedMazeIndex])[playerY][playerX + <span class="number">1</span>] == <span class="number">1</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                playerX++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否到达目标点</span></span><br><span class="line">        <span class="keyword">if</span> (playerX == targetX &amp;&amp; playerY == targetY) </span><br><span class="line">        &#123;</span><br><span class="line">            gameState = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查是否超过时间限制</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">timeval</span> currentTime;</span><br><span class="line">        <span class="built_in">mingw_gettimeofday</span>(&amp;currentTime, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 时间耗尽，游戏失败</span></span><br><span class="line">        <span class="keyword">if</span> (currentTime.tv_sec - startTime.tv_sec &gt;= TIME_LIMIT) </span><br><span class="line">        &#123;</span><br><span class="line">            gameState = <span class="number">3</span>;      </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求重绘</span></span><br><span class="line">        <span class="built_in">glutPostRedisplay</span>();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (gameState == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 显示游戏开始界面</span></span><br><span class="line">        <span class="comment">// 设置文本颜色为黑色</span></span><br><span class="line">        <span class="built_in">glColor3f</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);     </span><br><span class="line">        <span class="comment">// 居中显示                                               </span></span><br><span class="line">        <span class="built_in">glRasterPos2i</span>(MAZE_WIDTH * TILE_SIZE / <span class="number">2</span> - <span class="number">100</span>, MAZE_HEIGHT * TILE_SIZE / <span class="number">2</span>);   </span><br><span class="line">        <span class="type">char</span> startText[] = <span class="string">&quot;Press &#x27;S&#x27; to Start. Choose map: 1-2&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; startText[i]!= <span class="string">&#x27;\0&#x27;</span>; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">glutBitmapCharacter</span>(GLUT_BITMAP_HELVETICA_18, startText[i]);            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (gameState == <span class="number">1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 绘制迷宫</span></span><br><span class="line">        <span class="built_in">drawMaze</span>(); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绘制玩家   </span></span><br><span class="line">        <span class="built_in">drawPlayer</span>(); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绘制目标点 </span></span><br><span class="line">        <span class="built_in">drawTarget</span>(); </span><br><span class="line">        <span class="built_in">displayTime</span>(); </span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (gameState == <span class="number">2</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 显示游戏胜利界面</span></span><br><span class="line">        <span class="built_in">glColor3f</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">        <span class="built_in">glRasterPos2i</span>(MAZE_WIDTH * TILE_SIZE / <span class="number">2</span> - <span class="number">100</span>, MAZE_HEIGHT * TILE_SIZE / <span class="number">2</span>);</span><br><span class="line">        <span class="type">char</span> winText[] = <span class="string">&quot;Congratulations! You Win!&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; winText[i]!= <span class="string">&#x27;\0&#x27;</span>; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">glutBitmapCharacter</span>(GLUT_BITMAP_HELVETICA_18, winText[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (gameState == <span class="number">3</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 显示游戏失败界面</span></span><br><span class="line">        <span class="comment">// 设置文本颜色为黑色</span></span><br><span class="line">        <span class="built_in">glColor3f</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 居中显示</span></span><br><span class="line">        <span class="built_in">glRasterPos2i</span>(MAZE_WIDTH * TILE_SIZE / <span class="number">2</span> - <span class="number">100</span>, MAZE_HEIGHT * TILE_SIZE / <span class="number">2</span>);</span><br><span class="line">        <span class="type">char</span> loseText[] = <span class="string">&quot;Time Out! You Lose!&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; loseText[i]!= <span class="string">&#x27;\0&#x27;</span>; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">glutBitmapCharacter</span>(GLUT_BITMAP_HELVETICA_18, loseText[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glFlush</span>();                           </span><br><span class="line">    <span class="comment">// 刷新缓冲区</span></span><br><span class="line">    <span class="built_in">glutSwapBuffers</span>();                   </span><br><span class="line">    <span class="comment">// 交换缓冲区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 背景色为白色</span></span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置正投影矩阵</span></span><br><span class="line">    <span class="built_in">glOrtho</span>(<span class="number">0</span>, MAZE_WIDTH * TILE_SIZE, <span class="number">0</span>, MAZE_HEIGHT * TILE_SIZE, <span class="number">-1</span>, <span class="number">1</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理游戏开始界面键盘输入,输入S或s开始游戏（不过有缓冲，需要等几秒按S才有用）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processStartKeys</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> key, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (gameState == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="string">&#x27;1&#x27;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            selectedMazeIndex = <span class="number">0</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">&#x27;2&#x27;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            selectedMazeIndex = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key ==<span class="string">&#x27;s&#x27;</span> || key == <span class="string">&#x27;S&#x27;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            gameState = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">glutDisplayFunc</span>(display);             </span><br><span class="line">            <span class="built_in">glutKeyboardFunc</span>(processKeys);     </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 记录游戏开始时间</span></span><br><span class="line">            <span class="built_in">mingw_gettimeofday</span>(&amp;startTime, <span class="literal">NULL</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化GLUT库</span></span><br><span class="line">    <span class="built_in">glutInit</span>(&amp;argc, argv);      </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置显示模式为双缓冲和RGB颜色模式                                             </span></span><br><span class="line">    <span class="built_in">glutInitDisplayMode</span>(GLUT_DOUBLE | GLUT_RGB);       </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置窗口大小                      </span></span><br><span class="line">    <span class="built_in">glutInitWindowSize</span>(MAZE_WIDTH * TILE_SIZE, MAZE_HEIGHT * TILE_SIZE);    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建窗口(其中的maze game为窗口名称)</span></span><br><span class="line">    <span class="built_in">glutCreateWindow</span>(<span class="string">&quot;maze game&quot;</span>);                                           </span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="comment">// 初始显示游戏开始界面</span></span><br><span class="line">    <span class="built_in">glutDisplayFunc</span>(display);</span><br><span class="line">    <span class="built_in">glutKeyboardFunc</span>(processStartKeys);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入主循环</span></span><br><span class="line">    <span class="built_in">glutMainLoop</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>熵权法</title>
    <url>/2025/01/19/%E7%86%B5%E6%9D%83%E6%B3%95/</url>
    <content><![CDATA[<h1 id="熵权法"><a href="#熵权法" class="headerlink" title="熵权法"></a>熵权法</h1><p><strong>熵的概念：</strong></p>
<ul>
<li>信息论中，熵是对<strong>不确定性</strong>的一种度量，可判断一个事件的<strong>随机性</strong>及<strong>无序</strong>程度。</li>
<li>用熵值判断某个指标的<strong>离散程度</strong>，指标的<strong>离散程度越大</strong>，<strong>该指标对综合评价的影响越大</strong>。</li>
</ul>
<h3 id="适用赛题"><a href="#适用赛题" class="headerlink" title="适用赛题"></a>适用赛题</h3><ul>
<li>数据全面，但缺少文献或主观依据的题目<ul>
<li>例如，<strong>评价河流的水质</strong>，已知河流的含氧量、pH值、细菌密度、生物密度等数据</li>
<li>但<strong>缺乏评价水质的文献资料</strong>，或者文献内的<strong>说法不一</strong></li>
<li>即文献很难帮助我们确定影响水质最重要的因素是哪一个，也很难告诉我们其余指标的重要程度如何衡量</li>
<li>此时即可使用熵权法，<strong>根据数据本身建立评价体系</strong></li>
</ul>
</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>熵权法与其他方法 (如AHP、TOPSIS法等) 最大的区别就是<strong>完全客观</strong></li>
<li><strong>难以将数据之外的因素考虑进去</strong></li>
</ul>
<p><strong>1.数据标准化</strong></p>
<p>标准化的原因：</p>
<ul>
<li>评价体系中，存在数值越大越好的<strong>正向指标</strong>，和数值越小越好的<strong>负向指标</strong></li>
<li>不同指标数量级也可能不同；且求熵的公式中用到对数函数，变量不允许有负值</li>
</ul>
<p><strong>正向指标标准化：</strong></p>
<p>$ a_{ij} = \frac{ x_{ij}- \min(x_{1j},…,x_{nj} )}{\max(x_{1j},…,x_{nj})-\min(x_{1j},…,x_{nj})}  $</p>
<p><strong>负向指标标准化：</strong></p>
<p>$ a_{ij} = \frac{ \max(x_{1j},…,x_{nj}) - x_{ij} }{\max(x_{1j},…,x_{nj})-\min(x_{1j},…,x_{nj})}  $</p>
<p>不难发现，标准化之后，$a_{ij}$ 所有值在 $[0,1] $ 区间之内，且都是数值越大、现实意义越好。</p>
<p><strong>2.指标的熵值和变异程度</strong></p>
<p>①每个评价对象在各个指标中的比重：</p>
<ul>
<li><p>可理解为统计意义上某种情况出现的概率</p>
<p>$p_{ij} = \frac{a_{ij}}{\sum_{i=1}^{n} a_{ij}}$</p>
</li>
</ul>
<p>②熵值</p>
<ul>
<li><p>对于第 $i$ 个指标，其熵值 $e_j$ 为：</p>
<p>$e_j = -\frac{1}{\ln n} \sum_{i=1}^{n} p_{ij} \ln p_{ij}$</p>
</li>
</ul>
<p>③变异系数</p>
<ul>
<li>第 $j$ 个指标的变异系数： $g_j = 1 - e_j$ .</li>
<li>显然熵值越大、变异系数越小，代表该指标越有序，该指标的信息量也就越小。</li>
</ul>
<p><strong>3.权重与评分</strong></p>
<p><strong>变异系数求权重</strong></p>
<ul>
<li>计算第 $j$ 个指标的权重： $w_j = \frac{g_j}{\sum_{j=1}^{m} g_j} $ .</li>
<li>指标的变异系数越大、信息量越大，相应指标的权重也越大。</li>
</ul>
<p><strong>综合评分</strong></p>
<ul>
<li><p>计算第 $i$ 个评价对象的综合评价值</p>
<p>$s_i = \sum_{j=1}^{m} w_j p_{ij}$</p>
</li>
<li><p>该公式对不同科目加权求和，得到每个人的平均值，评价值越大越好。</p>
</li>
<li><p>$p_{ij}$ 和 $w_j$ 都是原始数据 (成绩) 求得的，完全客观，不掺杂主观成分。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS1初步学习</title>
    <url>/2024/11/19/ROS1%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="ROS-1"><a href="#ROS-1" class="headerlink" title="ROS 1"></a>ROS 1</h1><p>在 <code>ROS-Wiki</code> 上，我们可以得知ROS到底是个啥：</p>
<p> <strong>简介：</strong>ROS 是一个适用于机器人的开源的元操作系统。它提供了操作系统应有的服务，包括硬件抽象，底层设备控制，常用函数的实现，进程间消息传递，以及包管理。它也提供用于获取、编译、编写、和跨计算机运行代码所需的工具和库函数。在某些方面ROS相当于一种”机器人框架“。（<del>复制粘贴的</del>）</p>
<p><strong>ROS1的安装</strong></p>
<p>我已经在虚拟机上准备了一个已经换好源的 Ubuntu 20.04 ，我们将在这个系统上运行 ROS。</p>
<p>根据csdn上的教程，我根据我的乌班图版本选择了 <code>ROS Noetic Ninjemys</code> 这个ROS版本</p>
<p>安装完 <code>ros</code> 之后，这篇博客还推荐配置 <code>rosdep</code> ，我也顺手搞定了。(<em>不知道为什么，博主推荐的一键安装失效了，还是我手动配置的</em>)</p>
<h2 id="ROS1-初级教程学习"><a href="#ROS1-初级教程学习" class="headerlink" title="ROS1 初级教程学习"></a>ROS1 初级教程学习</h2><p><strong>配置ROS环境</strong></p>
<p>由于我安装的是 <code>ROS Noetic Ninjemys</code>  这个版本，得先输入如下指令才能访问ROS相关的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /opt/ros/noetic/setup.bash</span><br></pre></td></tr></table></figure>
<p>每次都输太麻烦，所以直接使用 <code>vim ~/.bashrc</code> 这条指令，在文件末尾插入上述命令(<del>我用的小鱼一键安装，搞半天像傻子一样打开才发现人家已经在文件末尾写好了</del>)</p>
<p><strong>创建ROS工作空间</strong></p>
<p>我们要使用wiki里面给出的指令创建和构建一个 <code>catkin工作空间</code> 。wiki还告诉我们，<code>catkin_make</code>命令在 <code>catkin工作空间</code> 中是一个非常方便的工具。在工作空间中第一次运行它时，它会在<code>src</code>目录下创建一个 <code>CMakeLists.txt</code> 的链接。</p>
<p>然后继续根据要求，<code>source</code>一下新生成的 <code>setup.*sh</code> 文件，再确定一下那个环境变量包括我当前的工作目录就行了。</p>
<hr>
<h3 id="ROS-文件系统导览"><a href="#ROS-文件系统导览" class="headerlink" title="ROS 文件系统导览"></a>ROS 文件系统导览</h3><ul>
<li>软件包(Packages)：wiki告诉我们，包是ROS代码的<strong>软件组织单元</strong>，每个软件包都可以包含程序库、可执行文件、脚本或者其他构件。</li>
<li>清单(Manifests)：清单是对软件包的描述。他用于定义软件包之间的依赖关系，并记录有关软件包的元信息，比如版本、维护者、许可证之类的。</li>
</ul>
<p>程序的代码散落在许多ROS包里头，如果使用<code>ls</code> <code>cd</code> 这些来进行查找和导航比较繁琐，因此ROS提供了专门的命令工具来简化这些操作。</p>
<p><strong>rospack</strong></p>
<p>这个命令允许我们获取软件包的有关信息，wiki给我们讲了 <code>find</code> 这个参数：</p>
<p>使用如下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rospack find roscpp</span><br></pre></td></tr></table></figure>
<p>它输出的是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/opt/ros/noetic/share/roscpp</span><br></pre></td></tr></table></figure>
<p>所以显然，这个选项能够返回软件包的所在路径。</p>
<p><strong>roscd</strong></p>
<p><code>roscd</code> 由 <code>ros</code> 和 <code>cd</code> 组成，所以显然，这个命令可以让我们直接切换目录到某个软件包或者软件包集。</p>
<p>依次输入如下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ roscd roscpp</span><br><span class="line">$ <span class="built_in">pwd</span></span><br></pre></td></tr></table></figure>
<p>它输出的是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/opt/ros/noetic/share/roscpp</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>子目录</strong></li>
</ul>
<p>​    <code>roscd</code> 也可以切换到一个软件包或软件包集的子目录中。</p>
<p>​    执行如下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ roscd roscpp/cmake</span><br><span class="line">$ <span class="built_in">pwd</span></span><br></pre></td></tr></table></figure>
<p>​    结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/opt/ros/noetic/share/roscpp/cmake</span><br></pre></td></tr></table></figure>
<ul>
<li>roscd log</li>
</ul>
<p>​    这个命令会进入存储 <code>ROS</code> 日志文件的目录。</p>
<p>​    如果没有执行过任何 <code>ROS</code> 程序，系统会报错说该目录不存在。即如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">No active roscore</span><br><span class="line">bash: <span class="built_in">cd</span>: /home/wjz2024302124/.ros/log: No such file or directory</span><br></pre></td></tr></table></figure>
<p><strong>rosls</strong></p>
<p>这个命令允许直接按软件包的名称执行 <code>ls</code> 命令，而不需要繁琐地输入绝对路径。</p>
<p>执行如下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosls roscpp_tutorials</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake launch package.xml  srv</span><br></pre></td></tr></table></figure>
<p><strong>Tab 补全</strong></p>
<p>总是输入完整的软件包名称比较繁琐，而一些ROS工具支持<strong>Tab补全</strong>这个功能</p>
<p>输入如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ roscd roscpp_tut&lt;&lt;&lt;按TAB键&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>它会自动补全如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ roscd roscpp_tutorials/</span><br></pre></td></tr></table></figure>
<p>然而，当输入的东西不完整，并且有许多软件包以输入的东西作为开头，再次按下TAB键会列出所有以其开头的ROS软件包。</p>
<hr>
<h3 id="创建ROS软件包"><a href="#创建ROS软件包" class="headerlink" title="创建ROS软件包"></a>创建ROS软件包</h3><p><strong>一个catkin软件包的组成</strong>：</p>
<ul>
<li>一个符合 <code>catkin</code> 规范的 <code>package.xml</code> 文件，用于提供该软件包的元信息</li>
<li>一个 <code>catkin</code> 版本的 <code>CMakeLists.txt</code> 文件或文件的相关样板</li>
<li>目录（同一个目录下不能有嵌套的或者多个软件包存在）</li>
</ul>
<p>最简单的软件包看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_package/</span><br><span class="line">  CMakeLists.txt</span><br><span class="line">  package.xml</span><br></pre></td></tr></table></figure>
<p><strong>catkin工作空间中的软件包</strong></p>
<p>开发 <code>catkin</code> 软件包的推荐方法是使用 <code>catkin工作空间</code>，但也可以单独开发 <code>catkin</code> 软件包。</p>
<p><strong>创建catkin软件包</strong></p>
<p>先切换到创建的空白catkin工作空间中的源文件空间目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/catkin_ws/src</span><br></pre></td></tr></table></figure>
<p>然后使用 <code>catkin_create_pkg</code> 命令创建一个名为 <code>beginner_tutorials</code> 的新软件包，这个软件包依赖于 <code>std_msgs</code>、<code>roscpp</code> 和 <code>rospy</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ catkin_create_pkg beginner_tutorials std_msgs rospy roscpp</span><br></pre></td></tr></table></figure>
<p>这样搞的话就会创建一个名为 <code>beginner_tutorials</code> 的文件夹，这个文件夹里面包含一个 <code>package.xml</code> 文件和一个<code>CMakeLists.txt</code> 文件，这两个文件都已经部分填写了在执行 <code>catkin_create_pkg</code> 命令时提供的信息。</p>
<p><code>catkin_create_pkg</code> 命令会要求输入 <code>package_name</code> ，如有需要还可以在后面添加一些需要依赖的其它软件包。</p>
<p><strong>构建一个catkin工作区并生效配置文件</strong></p>
<p>现在咱们在catkin工作区中构建软件包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ catkin_make</span><br></pre></td></tr></table></figure>
<p>工作空间构建完成后，在 <code>devel</code> 子目录下创建了一个与通常在 <code>/opt/ros/$ROSDISTRO_NAME</code> 下看到的目录结构类似的结构。</p>
<p>要将这个工作空间添加到ROS环境中，需要<code>source</code>一下生成的配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ . ~/catkin_ws/devel/setup.bash</span><br></pre></td></tr></table></figure>
<p><strong>软件包依赖关系</strong></p>
<p><strong>一级依赖</strong></p>
<p>之前在使用 <code>catkin_create_pkg</code> 命令时提供了几个软件包作为依赖关系，现在我们可以使用 <code>rospack</code> 命令工具来查看这些<strong>一级依赖</strong>包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rospack depends1 beginner_tutorials</span><br></pre></td></tr></table></figure>
<p>结果是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roscpp</span><br><span class="line">rospy</span><br><span class="line">std_msgs</span><br></pre></td></tr></table></figure>
<p>诶，这不就是前面咱们加的东西吗？</p>
<p><code>rospack</code>列出了在运行 <code>catkin_create_pkg</code> 命令时作为参数的依赖包，这些依赖关系存储在 <code>package.xml</code> 文件中。</p>
<p><strong>间接依赖</strong></p>
<p>一个依赖还会有自己的依赖关系，譬如 <code>rospy</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rospack depends1 rospy</span><br><span class="line"></span><br><span class="line">genpy</span><br><span class="line">roscpp</span><br><span class="line">rosgraph</span><br><span class="line">rosgraph_msgs</span><br><span class="line">roslib</span><br><span class="line">std_msgs</span><br></pre></td></tr></table></figure>
<p>一个软件包可以有相当多间接的依赖关系，使用 <code>rospack</code> 就可以递归检测出所有嵌套的依赖包。</p>
<p><strong>自定义软件包</strong></p>
<p><strong>自定义<code>package.xml</code></strong></p>
<ul>
<li><p>描述标签</p>
<p>注意到 <code>description</code> 标签 <code>&lt;description&gt;The beginner_tutorials package&lt;/description&gt;</code> ，可以将描述信息修改为任何内容。</p>
</li>
<li><p>维护者标签</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- One maintainer tag required, multiple allowed, one person per tag --&gt;</span><br><span class="line">&lt;!-- Example:  --&gt;</span><br><span class="line">&lt;!-- &lt;maintainer email=<span class="string">&quot;jane.doe@example.com&quot;</span>&gt;Jane Doe&lt;/maintainer&gt; --&gt;</span><br><span class="line">&lt;maintainer email=<span class="string">&quot;wjz2024302124@todo.todo&quot;</span>&gt;wjz2024302124&lt;/maintainer&gt;</span><br></pre></td></tr></table></figure>
<p>从wiki中我们可以知道，这是 <code>package.xml</code> 中的一个重要标签，因为它能够让其他人联系到软件包的相关人员。这里至少需要填写一个维护者，但如果想的话可以添加多个。除了在标签里面填写维护者的名字外，还应该在标签的<code>email</code>属性中填写电子邮件地址。</p>
</li>
<li><p>许可证标签</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- One license tag required, multiple allowed, one license per tag --&gt;</span><br><span class="line">&lt;!-- Commonly used license strings: --&gt;</span><br><span class="line">&lt;!--   BSD, MIT, Boost Software License, GPLv2, GPLv3, LGPLv2.1, LGPLv3 --&gt;</span><br><span class="line">&lt;license&gt;TODO&lt;/license&gt;</span><br></pre></td></tr></table></figure>
<p>在wiki中提到，我们应使用BSD。</p>
</li>
<li><p>依赖项标签</p>
</li>
</ul>
<p>​    接下来的标签描述了软件包的依赖关系，这些依赖项分为<code>build_depend</code>、<code>buildtool_depend</code>、<code>run_depend</code>、<code>test_depend</code>。</p>
<pre><code>    <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- The *depend tags are used to specify dependencies --&gt;</span><br><span class="line">&lt;!-- Dependencies can be catkin packages or system dependencies --&gt;</span><br><span class="line">&lt;!-- Examples: --&gt;</span><br><span class="line">&lt;!-- Use depend as a shortcut <span class="keyword">for</span> packages that are both build and <span class="built_in">exec</span> dependencies --&gt;</span><br><span class="line">&lt;!--   &lt;depend&gt;roscpp&lt;/depend&gt; --&gt;</span><br><span class="line">&lt;!--   Note that this is equivalent to the following: --&gt;</span><br><span class="line">&lt;!--   &lt;build_depend&gt;roscpp&lt;/build_depend&gt; --&gt;</span><br><span class="line">&lt;!--   &lt;exec_depend&gt;roscpp&lt;/exec_depend&gt; --&gt;</span><br><span class="line">&lt;!-- Use build_depend <span class="keyword">for</span> packages you need at compile time: --&gt;</span><br><span class="line">&lt;!--   &lt;build_depend&gt;message_generation&lt;/build_depend&gt; --&gt;</span><br><span class="line">&lt;!-- Use build_export_depend <span class="keyword">for</span> packages you need <span class="keyword">in</span> order to build against this package: --&gt;</span><br><span class="line">&lt;!--   &lt;build_export_depend&gt;message_generation&lt;/build_export_depend&gt; --&gt;</span><br><span class="line">&lt;!-- Use buildtool_depend <span class="keyword">for</span> build tool packages: --&gt;</span><br><span class="line">&lt;!--   &lt;buildtool_depend&gt;catkin&lt;/buildtool_depend&gt; --&gt;</span><br><span class="line">&lt;!-- Use exec_depend <span class="keyword">for</span> packages you need at runtime: --&gt;</span><br><span class="line">&lt;!--   &lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; --&gt;</span><br><span class="line">&lt;!-- Use test_depend <span class="keyword">for</span> packages you need only <span class="keyword">for</span> testing: --&gt;</span><br><span class="line">&lt;!--   &lt;test_depend&gt;gtest&lt;/test_depend&gt; --&gt;</span><br><span class="line">&lt;!-- Use doc_depend <span class="keyword">for</span> packages you need only <span class="keyword">for</span> building documentation: --&gt;</span><br><span class="line">&lt;!--   &lt;doc_depend&gt;doxygen&lt;/doc_depend&gt; --&gt;</span><br><span class="line">&lt;buildtool_depend&gt;catkin&lt;/buildtool_depend&gt;</span><br><span class="line">&lt;build_depend&gt;roscpp&lt;/build_depend&gt;</span><br><span class="line">&lt;build_depend&gt;rospy&lt;/build_depend&gt;</span><br><span class="line">&lt;build_depend&gt;std_msgs&lt;/build_depend&gt;</span><br><span class="line">&lt;build_export_depend&gt;roscpp&lt;/build_export_depend&gt;</span><br><span class="line">&lt;build_export_depend&gt;rospy&lt;/build_export_depend&gt;</span><br><span class="line">&lt;build_export_depend&gt;std_msgs&lt;/build_export_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;roscpp&lt;/exec_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;rospy&lt;/exec_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt;</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>最终的 <code>package.xml</code></p>
<p>去掉注释和未使用标签即可。</p>
</li>
</ul>
<hr>
<h3 id="构建ROS软件包"><a href="#构建ROS软件包" class="headerlink" title="构建ROS软件包"></a>构建ROS软件包</h3><p>只要安装了这个包的所有系统依赖项，就可以开始编译软件包了。</p>
<p><code>catkin_make</code> 的用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ catkin_make [make_targets] [-DCMAKE_VARIABLES=...]</span><br></pre></td></tr></table></figure>
<p><strong>开始构建软件包</strong></p>
<p>输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/catkin_ws/</span><br><span class="line">$ <span class="built_in">ls</span> src</span><br><span class="line"></span><br><span class="line">beginner_tutorials  CMakeLists.txt</span><br></pre></td></tr></table></figure>
<p>现在我们可以使用catkin_make来构建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ catkin_make</span><br></pre></td></tr></table></figure>
<p>这样的话就成功构建了一个ROS软件包。</p>
<hr>
<h3 id="理解ROS节点"><a href="#理解ROS节点" class="headerlink" title="理解ROS节点"></a>理解ROS节点</h3><p><strong>图概念</strong></p>
<p>(概念来自wiki)计算图是一个由ROS进程组成的点对点网络，它们能够共同处理数据。</p>
<p>ROS的基本计算图概念：</p>
<ul>
<li>节点：一个可执行文件，可通过ROS来与其他节点进行通信</li>
<li>消息：订阅或发布话题时所使用的ROS数据类型</li>
<li>话题：节点可以将消息发布到话题，或通过订阅话题来接收消息</li>
<li>主节点：ROS的命名服务，例如帮助节点发现彼此</li>
<li>rosout：在ROS中相当于 <code>stdout/stderr</code> </li>
<li>roscore：主节点 + rosout + 参数服务器(wiki提到后面会进行介绍)</li>
</ul>
<p><strong>节点</strong></p>
<p>正如上面提到的，它是一个可执行文件。ROS节点使用ROS客户端库与其他节点通信。节点可以发布或订阅话题，也可以提供或使用服务。</p>
<p>（wiki里面的例子，是把遥控器和机器人当做两个节点来理解）</p>
<p><strong>客户端库</strong></p>
<p>ROS客户端库可以让用不同编程语言编写的节点进行相互通信：</p>
<ul>
<li>rospy=Python数据库</li>
<li>roscpp=C++数据库</li>
</ul>
<p><strong>roscore</strong></p>
<p>wiki提到，这个命令是在运行所有ROS程序前首先要运行的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ roscore</span><br></pre></td></tr></table></figure>
<p>我这边并没有按照预期显示，有可能网络配置出问题了，所以我输入了如下代码，保证其能够完成单机配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> ROS_HOSTNAME=localhost</span><br><span class="line">$ <span class="built_in">export</span> ROS_MASTER_URI=http://localhost:11311</span><br></pre></td></tr></table></figure>
<p>最终成功。</p>
<p><strong>rosnode</strong></p>
<p>在保持原来终端开着的情况下，打开一个新终端。 <code>rosnode</code>显示当前正在运行的ROS节点信息。<code>rosnode list</code>命令会列出这些活动的节点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosnode list</span><br><span class="line"></span><br><span class="line">/rosout</span><br></pre></td></tr></table></figure>
<p>表示当前只有一个节点在运行：<code>rosout</code> 。这个节点用于收集和记录节点的调试输出，所以总是运行着的。</p>
<p><code>rosnode info</code>命令返回的是某个指定节点的信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosnode info /rosout</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">Node [/rosout]</span><br><span class="line">Publications: </span><br><span class="line"> * /rosout_agg [rosgraph_msgs/Log]</span><br><span class="line"></span><br><span class="line">Subscriptions: </span><br><span class="line"> * /rosout [unknown <span class="built_in">type</span>]</span><br><span class="line"></span><br><span class="line">Services: </span><br><span class="line"> * /rosout/get_loggers</span><br><span class="line"> * /rosout/set_logger_level</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contacting node http://localhost:35183/ ...</span><br><span class="line">Pid: 11688</span><br></pre></td></tr></table></figure>
<p>wiki表示，这给了我们更多关于<code>rosout</code>的信息，比如说实际上它是发布了一个<code>/rosout_agg</code>话题。</p>
<p><strong>rosrun</strong></p>
<p>这个指令可以让咱们用包名直接运行软件包内的节点，不需要知道包的路径。</p>
<p>它的用法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosrun [package_name] [node_name]</span><br></pre></td></tr></table></figure>
<p>wiki指引我们运行一个运行 <code>turtlesim</code> 包中的 <code>turtlesim_node</code> ，跟随wiki的指引，我们能够看到一个蓝底的窗口上有一只乌龟。</p>
<p>咱们还可以通过命令行重新分配名称，例如输入以下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosrun turtlesim turtlesim_node __name:=my_turtle</span><br></pre></td></tr></table></figure>
<p>节点的名称就被更改了。</p>
<hr>
<h3 id="理解ROS话题"><a href="#理解ROS话题" class="headerlink" title="理解ROS话题"></a>理解ROS话题</h3><p>先把roscore运行着，然后打开一个<strong>新终端</strong>就行，输入如下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosrun turtlesim turtlesim_node</span><br></pre></td></tr></table></figure>
<p><strong>通过键盘遥控turtle</strong></p>
<p>这时候已经有一个乌龟窗口被打开了，<strong>再</strong>打开一个<strong>新终端</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosrun turtlesim turtle_teleop_key</span><br></pre></td></tr></table></figure>
<p>这时候就可以用方向键来控制乌龟了 (↑是向头指向的方向移动，←→是调整方向)</p>
<p><strong>ROS话题</strong></p>
<p>wiki告诉我们，刚才提到的 <code>turtlesim_node</code> 节点和 <code>turtle_teleop_key</code> 节点之间是通过一个ROS<strong>话题</strong>来相互通信的。<code>turtle_teleop_key</code>在话题上<strong>发布</strong>键盘按下的消息，<code>turtlesim</code>则<strong>订阅</strong>该话题以接收消息。</p>
<p><strong>rqt_graph</strong></p>
<p><code>rqt_graph</code> 用动态的图显示了系统中正在发生的事情。</p>
<p>安装完 <code>rqt_graph</code> 之后，再打开一个<strong>新</strong>终端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosrun rqt_graph rqt_graph</span><br></pre></td></tr></table></figure>
<p>此时会弹出一个新的窗口，把鼠标放在 <code>/turtle1/command_velocity</code> 上方，ROS节点会变为蓝and绿色，话题会变成红色。</p>
<p>wiki告诉我们，<code>turtlesim_node</code> 和 <code>turtle_teleop_key</code> 节点正通过一个名为 <code>/turtle1/command_velocity</code> 的话题来相互通信。</p>
<p><strong>rostopic</strong></p>
<p>这个命令可以让我们来获取ROS话题的信息，可以使用 <code>$ rostopic -h</code> 来查看可用的子命令。</p>
<p><strong>rostopic echo</strong></p>
<p>这个命令可以显示在某个话题上发布的数据，用法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rostopic <span class="built_in">echo</span> [topic]</span><br></pre></td></tr></table></figure>
<p>现在让我们看看由 <code>turtle_teleop_key</code> 节点发布的“指令、速度”数据。再打开一个<strong>新</strong>终端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rostopic <span class="built_in">echo</span> /turtlel/cmd_vel</span><br><span class="line"></span><br><span class="line">linear: </span><br><span class="line">  x: 2.0</span><br><span class="line">  y: 0.0</span><br><span class="line">  z: 0.0</span><br><span class="line">angular: </span><br><span class="line">  x: 0.0</span><br><span class="line">  y: 0.0</span><br><span class="line">  z: 0.0</span><br><span class="line">---</span><br><span class="line">linear: </span><br><span class="line">  x: 0.0</span><br><span class="line">  y: 0.0</span><br><span class="line">  z: 0.0</span><br><span class="line">angular: </span><br><span class="line">  x: 0.0</span><br><span class="line">  y: 0.0</span><br><span class="line">  z: 2.0</span><br></pre></td></tr></table></figure>
<p>我随便点了两下，就有上述的输出。</p>
<p>再看一下 <code>rqt_graph</code> ，按下左上角的刷新按钮显示新的节点：现在 <code>rostopic echo</code>（红色）现在也<strong>订阅</strong>了 <code>turtle1/command_velocity</code>这个话题。</p>
<p><strong>rostopic list</strong></p>
<p>这个命令能够列出当前已经被订阅和发布的所有话题。</p>
<p>咱们继续打开一个<strong>新</strong>终端：（向上面一样，可以通过 <code>$ rostopic list -h</code> 命令打开帮助页面）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rostopic list -v</span><br><span class="line"></span><br><span class="line">Published topics:</span><br><span class="line"> * /rosout_agg [rosgraph_msgs/Log] 1 publisher</span><br><span class="line"> * /rosout [rosgraph_msgs/Log] 5 publishers</span><br><span class="line"> * /turtle1/pose [turtlesim/Pose] 1 publisher</span><br><span class="line"> * /turtle1/color_sensor [turtlesim/Color] 1 publisher</span><br><span class="line"> * /turtle1/cmd_vel [geometry_msgs/Twist] 1 publisher</span><br><span class="line"></span><br><span class="line">Subscribed topics:</span><br><span class="line"> * /rosout [rosgraph_msgs/Log] 1 subscriber</span><br><span class="line"> * /turtle1/cmd_vel [geometry_msgs/Twist] 2 subscribers</span><br><span class="line"> * /statistics [rosgraph_msgs/TopicStatistics] 1 subscriber</span><br></pre></td></tr></table></figure>
<p>如输出所示，这样会列出所有发布和订阅的主题及其类型的详细信息。</p>
<p><strong>ROS 消息</strong></p>
<p>wiki告诉我们，话题的通信是通过节点间发送<strong>ROS消息</strong>实现的。</p>
<p>为了使发布者（<code>turtle_teleop_key</code>）和订阅者（<code>turtulesim_node</code>）进行通信，发布者和订阅者必须发送和接收相同<strong>类型</strong>的消息。这意味着话题的<strong>类型</strong>是由发布在它上面消息的<strong>类型</strong>决定的。使用<code>rostopic type</code>命令可以查看发布在话题上的消息的<strong>类型</strong>。</p>
<p><strong>rostopic type</strong></p>
<p>这个命令是用来查看所发布话题的消息类型。</p>
<p>用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rostopic <span class="built_in">type</span> [topic]</span><br></pre></td></tr></table></figure>
<p>根据wiki，我们运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rostopic <span class="built_in">type</span> /turtle1/cmd_vel</span><br><span class="line"></span><br><span class="line">geometry_msgs/Twist</span><br></pre></td></tr></table></figure>
<p>继续用rosmsg查看消息的详细信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosmsg show geometry_msgs/Twist</span><br><span class="line"></span><br><span class="line">geometry_msgs/Vector3 linear</span><br><span class="line">  float64 x</span><br><span class="line">  float64 y</span><br><span class="line">  float64 z</span><br><span class="line">geometry_msgs/Vector3 angular</span><br><span class="line">  float64 x</span><br><span class="line">  float64 y</span><br><span class="line">  float64 z</span><br></pre></td></tr></table></figure>
<p>所以，现在我们已经知道了 <code>turtlesim</code> 节点想要的消息类型，然后就可以发布命令给 <code>turtle</code> 了。</p>
<p><strong>rostopic pub</strong></p>
<p>这个命令可以把数据发布到当前某个正在广播的话题上。</p>
<p>用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rostopic pub [topic] [msg_type] [args]</span><br></pre></td></tr></table></figure>
<p>继续跟着wiki的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rostopic pub -1 /turtle1/cmd_vel geometry_msgs/Twist -- <span class="string">&#x27;[2.0, 0.0, 0.0]&#x27;</span> <span class="string">&#x27;[0.0, 0.0, 1.8]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>根据wiki上的解释，我们得知这个命令会发送一条消息给 <code>turtlesim</code> ，告诉它要以2.0的线速度和1.8的角速度移动。</p>
<p>逐步解析：</p>
<ul>
<li><code>rostopic pub</code> 将消息发布到指定的话题；</li>
<li><code>-1</code> 这个选项会让 <code>rostopic</code> 只发布一条消息，然后退出；</li>
<li><code>/turtle1/cmd_vel</code> 是要发布到的话题的名称；</li>
<li><code>geometry_mags/Twist</code> 是发布到话题时要使用的消息的类型；</li>
<li><code>--</code> 用来告诉选项解析器，表明之后的参数都不是选项。如果参数前有破折号（-）比如负数，那么这是必需的；</li>
<li><code>&#39;[2.0, 0.0, 0.0]&#39; &#39;[0.0, 0.0, 1.8]&#39;</code> ：如前所述，一个 <code>turtlesim/Velocity</code> 消息有两个浮点型元素：<code>linear</code>和<code>angular</code>。在本例中，<code>&#39;[2.0, 0.0, 0.0]&#39;</code>表示 <code>linear</code> 的值为 <code>x=2.0</code>, <code>y=0.0</code>, <code>z=0.0</code>，而<code>&#39;[0.0, 0.0, 1.8]&#39;</code> 是说 <code>angular</code> 的值为 <code>x=0.0</code>, <code>y=0.0</code>, <code>z=1.8</code>。而且根据wiki我们得知，这些参数使用的是YAML语法。</li>
</ul>
<p>我们发现，小乌龟动了一小下就停止移动了。wiki告诉我们，<code>turtle</code> 需要一个稳定的频率为1Hz的指令流才能保持移动状态。我们可以使用 <code>rostopic pub -r</code>命令来发布源源不断的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rostopic pub /turtle1/cmd_vel geometry_msgs/Twist -r 1 -- <span class="string">&#x27;[2.0, 0.0, 0.0]&#x27;</span> <span class="string">&#x27;[0.0, 0.0, -1.8]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>诶，这样的话小乌龟就一直在动了！</p>
<p><strong>rostopic hz</strong></p>
<p>这个命令呢，是用来报告数据发布的速率的~</p>
<p>用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rostopic hz [topic]</span><br></pre></td></tr></table></figure>
<p>比如，咱们看一下 <code>turtlesim_node</code> 发布 <code>/turtle/pose</code> 的速率：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rostopic hz /turtle1/pose</span><br><span class="line"></span><br><span class="line">average rate: 62.477</span><br><span class="line">	min: 0.015s max: 0.017s std dev: 0.00050s window: 63</span><br><span class="line">average rate: 62.480</span><br><span class="line">	min: 0.015s max: 0.017s std dev: 0.00053s window: 125</span><br><span class="line">average rate: 62.485</span><br><span class="line">	min: 0.015s max: 0.017s std dev: 0.00054s window: 188</span><br><span class="line">average rate: 62.493</span><br><span class="line">	min: 0.015s max: 0.017s std dev: 0.00054s window: 251</span><br><span class="line">average rate: 62.485</span><br><span class="line">	min: 0.014s max: 0.017s std dev: 0.00057s window: 313</span><br><span class="line">average rate: 62.487</span><br><span class="line">	min: 0.014s max: 0.017s std dev: 0.00057s window: 376</span><br></pre></td></tr></table></figure>
<p>由上可知，<code>turtlesim</code> 正以大约 <code>60Hz</code> 的频率发布有关乌龟的数据。</p>
<p><strong>rqt_plot</strong></p>
<p>这个命令可以在<strong>滚动时间图上</strong>显示发布到某个话题上的数据。这里我们将使用 <code>rqt_plot</code> 命令来绘制正被发布到 <code>/turtle1/pose</code> 话题上的数据。</p>
<p>再再再再次打开一个<strong>新</strong>终端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosrun rqt_plot rqt_plot</span><br></pre></td></tr></table></figure>
<p>然后就弹出了一个新窗口，咱们在左上角这个文本框里头添加任何想要绘制的话题</p>
<p><img src="/images/ROS_pic1.png" alt="ROS_pic1"></p>
<p>咱们输入 <code>/turtle1/pose/x</code> 之后，按一下变亮的加号按钮；对 <code>turtle1/pose/y</code> 重复这样的过程，咱们就能看到龟龟的 <code>x-y</code> 位置力~</p>
<p>按下减号按钮会显示一组菜单，可以在图中隐藏指定的话题。</p>
<p>到此为止，咱们已经理解了ROS话题是如何工作的了~</p>
<hr>
<h3 id="理解ROS服务和参数"><a href="#理解ROS服务和参数" class="headerlink" title="理解ROS服务和参数"></a>理解ROS服务和参数</h3><p><strong>ROS服务</strong></p>
<p>wiki告诉我们，<em>服务</em> 是节点之间通讯的另一种方式，服务允许节点发送一个<strong>请求</strong>并获得一个<strong>响应</strong>。</p>
<p><strong>rosservice</strong></p>
<p><code>rosservice</code> 可以通过服务附加到ROS客户端/服务器框架上。</p>
<p>用法：(摘自wiki)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosservice list         输出活跃服务的信息</span><br><span class="line">rosservice call         用给定的参数调用服务</span><br><span class="line">rosservice <span class="built_in">type</span>         输出服务的类型</span><br><span class="line">rosservice find         按服务的类型查找服务</span><br><span class="line">rosservice uri          输出服务的ROSRPC uri</span><br></pre></td></tr></table></figure>
<p><strong>rosservice list</strong></p>
<p>在终端输入这个命令 (注意要打开小乌龟的窗口)，它会显示 <code>turtlesim</code> 节点提供了哪些服务，比如 <code>clear</code> <del>就不一一列举了</del></p>
<p><strong>rosservice type</strong></p>
<p>以 <code>clear</code> 服务为例，我们来查看它的类型：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosservice <span class="built_in">type</span> /clear</span><br><span class="line"></span><br><span class="line">std_srvs/Empty</span><br></pre></td></tr></table></figure>
<p>wiki告诉我们，服务的类型为 <code>empty</code>（空），这表明调用这个服务时不需要参数（即，它在发出<strong>请求</strong>时不发送数据，在接收<strong>响应</strong>时也不接收数据）。</p>
<p><strong>rosservice call</strong></p>
<p>这个命令就是用来调用服务的，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosservice call /clear</span><br></pre></td></tr></table></figure>
<p>在终端输入后，我们不难发现，小乌龟窗口中背景的轨迹被清除了</p>
<p>我们再来试试有参数的服务 <code>spawn</code> ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosservice <span class="built_in">type</span> /spawn | rossrv show</span><br><span class="line"></span><br><span class="line">float32 x</span><br><span class="line">float32 y</span><br><span class="line">float32 theta</span><br><span class="line">string name</span><br><span class="line">---</span><br><span class="line">string name</span><br></pre></td></tr></table></figure>
<p>咱们来观察一下返回的东西：显然，这个服务能让我们可以在给定的位置和角度生成一只新的乌龟，还可以给它起名字。</p>
<p><strong>rosparam</strong></p>
<p>这个命令可以让我们在 <code>ROS参数服务器</code> 上<strong>存储</strong>和<strong>操作</strong>数据。</p>
<p>参数服务器能够存储整型、浮点型、布尔、字典和列表这些数据类型。<code>rosparam</code> 使用YAML标记语言的语法。一般而言，YAML的表述很自然，<code>1</code> 是整型，<code>1.0</code> 是浮点型，<code>one</code> 是字符串，<code>true</code> 是布尔型，<code>[1, 2, 3]</code> 是整型组成的列表…</p>
<p><code>rosparam</code> 有很多命令可以用来操作参数，wiki告诉了我们这些命令的用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosparam <span class="built_in">set</span>            设置参数</span><br><span class="line">rosparam get            获取参数</span><br><span class="line">rosparam load           从文件中加载参数</span><br><span class="line">rosparam dump           向文件中转储参数</span><br><span class="line">rosparam delete         删除参数</span><br><span class="line">rosparam list           列出参数名</span><br></pre></td></tr></table></figure>
<p><strong>rosparam list</strong></p>
<p>我们使用这个命令之后，可以看到参数服务器上有3个参数用于设定背景颜色：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/rosdistro</span><br><span class="line">/roslaunch/uris/host_nxt__43407</span><br><span class="line">/rosversion</span><br><span class="line">/run_id</span><br><span class="line">/turtlesim/background_b</span><br><span class="line">/turtlesim/background_g</span><br><span class="line">/turtlesim/background_r</span><br></pre></td></tr></table></figure>
<p><strong>rosparam set &amp; rosparam get</strong></p>
<p>这俩的用法都是后头加上 <code>[param_name]</code></p>
<p>比如使用如下命令修改背景颜色：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosparam <span class="built_in">set</span> /turtlesim/background_r 150</span><br><span class="line">$ rosservice call /clear <span class="comment">#需要调用clear才能让参数的修改得以生效</span></span><br></pre></td></tr></table></figure>
<p>我们就会发现背景颜色变紫了~</p>
<p>然后我们可以使用 <code>get</code> 来获取其它参数的值，比如获取背景绿色通道的值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosparam get /turtlesim/background_g</span><br><span class="line"></span><br><span class="line">86</span><br></pre></td></tr></table></figure>
<p>我们甚至还能用 <code>rosparam get /</code> 来显示参数服务器上的所有内容</p>
<p><strong>rosparam dump &amp; rosparam load</strong></p>
<p>这俩的用法都是在后头加上 <code>[file_name] [namespace]</code></p>
<p>比如，我们将所有的参数写入 <code>params.yaml</code> 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosparam dump params.yaml</span><br></pre></td></tr></table></figure>
<p>甚至可以将 <code>yaml</code> 文件重载入新的命令空间，比如 <code>copy_turtle</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosparam load params.yaml copy_turtle</span><br><span class="line">$ rosparam get /copy_turtle/turtlesim/background_b</span><br><span class="line"></span><br><span class="line">255</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="使用rqt-console和roslaunch"><a href="#使用rqt-console和roslaunch" class="headerlink" title="使用rqt_console和roslaunch"></a>使用rqt_console和roslaunch</h3><p><strong>rqt_console &amp; rqt_logger_level</strong></p>
<p>wiki告诉我们，<code>rqt_console</code> 连接到了ROS的日志框架，以显示节点的输出信息。<code>rqt_logger_level</code> 允许我们在节点运行时改变输出信息的详细级别。</p>
<p><code>rqt_logger_level</code>允许我们在节点运行时改变输出信息的详细级别，包括<code>Debug</code>、<code>Info</code>、<code>Warn</code> 和<code>Error</code>。</p>
<p><strong>日志记录器级别</strong></p>
<p>日志级别的优先级按以下顺序排列：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fatal  Error  Warn  Info  Debug</span><br></pre></td></tr></table></figure>
<p>wiki告诉我们，通过设置日志级别，咱们可以获得所有优先级级别，或只是更高级别的消息。比如，将日志级别设为<code>Warn</code>时，咱会得到<code>Warn</code>、<code>Error</code>和<code>Fatal</code>这三个等级的日志消息。</p>
<p><strong>roslaunch</strong></p>
<p>这个命令可以用来启动定义在 <code>launch</code> 文件中的节点，用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ roslaunch [package] [filename.launch]</span><br></pre></td></tr></table></figure>
<p>wiki引导我们切换到我们之前的 <code>beginner_tutorials</code> 软件包目录下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ roscd beginner_tutorials</span><br></pre></td></tr></table></figure>
<p>继续创建一个 <code>launch</code> 目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> launch</span><br><span class="line">$ <span class="built_in">cd</span> launch</span><br></pre></td></tr></table></figure>
<p><strong>launch文件</strong></p>
<p>wiki让我们现在创建一个名为 <code>turtlemimic.launch</code> 的launch文件并复制粘贴这些东西进去：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> 1 <span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"> 2 # 首先用launch标签开头，以表明这是一个launch文件</span><br><span class="line"> </span><br><span class="line"> 3   <span class="tag">&lt;<span class="name">group</span> <span class="attr">ns</span>=<span class="string">&quot;turtlesim1&quot;</span>&gt;</span></span><br><span class="line"> 4     <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sim&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtlesim_node&quot;</span>/&gt;</span></span><br><span class="line"> 5   <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"> 6 </span><br><span class="line"> 7   <span class="tag">&lt;<span class="name">group</span> <span class="attr">ns</span>=<span class="string">&quot;turtlesim2&quot;</span>&gt;</span></span><br><span class="line"> 8     <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sim&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtlesim_node&quot;</span>/&gt;</span></span><br><span class="line"> 9   <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"> # 此处我们创建了两个分组，并以命名空间（namespace）标签来区分，其中一个名为turtulesim1，另一个名为turtlesim2，两个分组中都有相同的名为sim的turtlesim节点。这样可以让我们同时启动两个turtlesim模拟器，而不会产生命名冲突。</span><br><span class="line"> </span><br><span class="line">10 </span><br><span class="line">11   <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span> <span class="attr">name</span>=<span class="string">&quot;mimic&quot;</span> <span class="attr">type</span>=<span class="string">&quot;mimic&quot;</span>&gt;</span></span><br><span class="line">12     <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;input&quot;</span> <span class="attr">to</span>=<span class="string">&quot;turtlesim1/turtle1&quot;</span>/&gt;</span></span><br><span class="line">13     <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;output&quot;</span> <span class="attr">to</span>=<span class="string">&quot;turtlesim2/turtle1&quot;</span>/&gt;</span></span><br><span class="line">14   <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line">#在这里我们启动模仿节点，话题的输入和输出分别重命名为turtlesim1和turtlesim2，这样就可以让turtlesim2模仿turtlesim1了。</span><br><span class="line"></span><br><span class="line">15 </span><br><span class="line">16 <span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br><span class="line"># 这一行使得launch文件的XML标签闭合。</span><br></pre></td></tr></table></figure>
<p><strong>使用roslaunch</strong></p>
<p>咱们通过 <code>roslaunch</code> 命令来运行launch文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ roslaunch beginner_tutorials turtlemimic.launch</span><br></pre></td></tr></table></figure>
<p>现在将会有两个turtlesim被启动，然后我们在一个<strong>新</strong>终端中使用<code>rostopic</code>命令发送：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rostopic pub /turtlesim1/turtle1/cmd_vel geometry_msgs/Twist -r 1 -- <span class="string">&#x27;[2.0, 0.0, 0.0]&#x27;</span> <span class="string">&#x27;[0.0, 0.0, -1.8]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>诶，咱们就会惊奇地发现，咱们只让 <code>turtle1</code> 运动了，但是 <code>turtle2</code> 也跟随它一起运动了！</p>
<hr>
<h3 id="使用rosed在ROS中编辑文件"><a href="#使用rosed在ROS中编辑文件" class="headerlink" title="使用rosed在ROS中编辑文件"></a>使用rosed在ROS中编辑文件</h3><p><strong>rosed</strong></p>
<p>利用这个命令可以直接通过软件包名编辑包中文件，无需键入完整路径。</p>
<p>用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosed [package_name] [filename]</span><br></pre></td></tr></table></figure>
<p><strong>Tab补全</strong></p>
<p>使用这个方法，在不知道准确文件名的情况下，也可以轻松地查看和编辑包中的所有文件，用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosed [package_name] &lt;tab&gt;&lt;tab&gt;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosed roscpp &lt;tab&gt;&lt;tab&gt;</span><br><span class="line"></span><br><span class="line">Empty.srv                   roscpp.cmake</span><br><span class="line">genmsg_cpp.py               roscppConfig.cmake</span><br><span class="line">gensrv_cpp.py               roscppConfig-version.cmake</span><br><span class="line">GetLoggers.srv              roscpp-msg-extras.cmake</span><br><span class="line">Logger.msg                  roscpp-msg-paths.cmake</span><br><span class="line">msg_gen.py                  SetLoggerLevel.srv</span><br><span class="line">package.xml</span><br></pre></td></tr></table></figure>
<p><strong>编辑器</strong></p>
<p>rosed默认的编译器是vim~</p>
<hr>
<h3 id="创建ROS消息和服务"><a href="#创建ROS消息和服务" class="headerlink" title="创建ROS消息和服务"></a>创建ROS消息和服务</h3><p><strong>msg 和 srv</strong></p>
<ul>
<li><code>msg</code>：<code>msg</code> 文件是文本文件，用于描述ROS消息的字段。它们用于为不同编程语言编写的消息生成源代码。</li>
<li><code>srv</code>：一个 <code>srv</code> 文件描述一个服务。它由两部分组成：请求和响应。</li>
</ul>
<hr>
<h3 id="编写简单的发布者和订阅者-Python"><a href="#编写简单的发布者和订阅者-Python" class="headerlink" title="编写简单的发布者和订阅者 (Python)"></a>编写简单的发布者和订阅者 (Python)</h3><p><strong>编写发布者节点</strong></p>
<p>wiki告诉我们，<code>节点</code> 是连接到ROS网络的可执行文件。我们要创建 <code>talker</code> (发布者) 节点，该节点将不断广播消息。</p>
<p>跟着wiki上的步骤，先创建一个 <code>scripts</code> 目录来存放 <code>Python</code> 脚本，然后下载示例脚本 <code>talker.py</code> 放到 <code>scripts</code> 目录中并给执行权限；最后把相关内容添加到 <code>CMakeLists.txt</code> 里头，就能确保正确安装 <code>Python</code>脚本，并使用合适的 <code>Python</code> 解释器了~</p>
<p><strong>解释</strong></p>
<p>跟着wiki分解一下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># (每个Python ROS节点的最开头都有这个声明。第一行确保脚本作为Python脚本执行。)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"><span class="comment"># 如果要编写ROS节点，则需要导入rospy。std_msgs.msg的导入则是为了使我们能够重用std_msgs/String消息类型（即一个简单的字符串容器）来发布。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">talker</span>():</span><br><span class="line">    pub = rospy.Publisher(<span class="string">&#x27;chatter&#x27;</span>, String, queue_size=<span class="number">10</span>)</span><br><span class="line">    rospy.init_node(<span class="string">&#x27;talker&#x27;</span>, anonymous=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 这部分代码定义了talker与其他ROS部分的接口。pub = rospy.Publisher(&quot;chatter&quot;, String, queue_size=10)声明该节点正在使用String消息类型发布到chatter话题。这里的String实际上是std_msgs.msg.String类。queue_size参数是在ROS Hydro及更新版本中新增的，用于在订阅者接收消息的速度不够快的情况下，限制排队的消息数量。对于ROS Groovy及早期版本来说，只需省略即可。下一行的rospy.init_node(NAME, ...)非常重要，因为它把该节点的名称告诉了rospy——只有rospy掌握了这一信息后，才会开始与ROS主节点进行通信。在本例中，节点将使用talker名称。</span></span><br><span class="line">    </span><br><span class="line">    rate = rospy.Rate(<span class="number">10</span>) <span class="comment"># 10hz</span></span><br><span class="line">    <span class="comment"># 此行创建一个Rate对象rate。借助其方法sleep()，它提供了一种方便的方法，来以想要的速率循环。它的参数是10，即表示希望它每秒循环10次（只要我们的处理时间不超过十分之一秒）！</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> rospy.is_shutdown():</span><br><span class="line">        hello_str = <span class="string">&quot;hello world %s&quot;</span> % rospy.get_time()</span><br><span class="line">        rospy.loginfo(hello_str)</span><br><span class="line">        pub.publish(hello_str)</span><br><span class="line">        rate.sleep()</span><br><span class="line">    <span class="comment"># 这个循环是一个相当标准的rospy结构：检查rospy.is_shutdown()标志，然后执行代码逻辑。必须查看is_shutdown()以检查程序是否应该退出（例如有Ctrl+C或其他）。在本例中，代码逻辑即对public .publish(hello_str)的调用，它将一个字符串发布到chatter话题。循环的部分还调用了rate.sleep()，它在循环中可以用刚刚好的睡眠时间维持期望的速率。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        talker()</span><br><span class="line">    <span class="keyword">except</span> rospy.ROSInterruptException:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 除了标准的Python __main__检查，它还会捕获一个rospy.ROSInterruptException异常，当按下Ctrl+C或节点因其他原因关闭时，这一异常就会被rospy.sleep()和rospy.Rate.sleep()抛出。引发此异常的原因是不会意外地在sleep()之后继续执行代码。</span></span><br></pre></td></tr></table></figure>
<p><strong>编写订阅者节点</strong></p>
<p>继续跟着wiki，下载示例脚本 <code>listener.py</code> 放到 <code>scripts</code> 目录中并给执行权限，然后编辑<code>CMakeLists.txt</code> 中的 <code>catkin_install_python()</code> 调用。(此处省略命令和代码)</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">rospy.init_node(<span class="string">&#x27;listener&#x27;</span>, anonymous=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">rospy.Subscriber(<span class="string">&#x27;chatter&#x27;</span>, String, callback)</span><br><span class="line"></span><br><span class="line"><span class="comment"># spin() simply keeps python from exiting until this node is stopped</span></span><br><span class="line">rospy.spin()</span><br></pre></td></tr></table></figure>
<p>wiki对这段代码的解释是：<em>这声明节点订阅了 <code>chatter</code> 话题，类型是 <code>std_msgs.msgs.String</code>。当接收到新消息时，<code>callback</code> 函数被调用，消息作为第一个参数。</em></p>
<p><em>我们还稍微更改了对<code>rospy.init_node()</code>的调用。我们添加了  <code>anonymous=True</code> 关键字参数。ROS要求每个节点都有一个唯一的名称，如果出现具有相同名称的节点，则会与前一个节点发生冲突，这样一来，出现故障的节点很容易地被踢出网络。<code>anonymous=True</code> 标志会告诉 <code>rospy</code> 为节点生成唯一的名称，这样就很容易可以有多个 <code>listener.py</code> 一起运行。</em></p>
<p><em>最后再补充一下，<code>rospy.spin()</code> 只是不让节点退出，直到节点被明确关闭。与 <code>roscpp</code> 不同，<code>rospy.spin()</code> 不影响订阅者回调函数，因为它们有自己的线程。</em></p>
<p><strong>构建节点</strong></p>
<p>咱们使用CMake作为构建系统，这是为了确保能为创建的<strong>消息</strong>和<strong>服务</strong>自动生成Python代码。</p>
<p>回到catkin工作空间，然后运行 <code>catkin_make</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">$ catkin_make</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="检验简单的发布者和订阅者"><a href="#检验简单的发布者和订阅者" class="headerlink" title="检验简单的发布者和订阅者"></a>检验简单的发布者和订阅者</h3><p><strong>运行发布者</strong></p>
<p>咱们运行刚才制作的叫做 <code>talker</code> 的发布者：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun beginner_tutorials talker.py</span><br><span class="line"></span><br><span class="line">[INFO] [1734609185.705253]: hello world 1734609185.7051988</span><br><span class="line">[INFO] [1734609185.806596]: hello world 1734609185.8064554</span><br><span class="line">[INFO] [1734609185.906493]: hello world 1734609185.9063175</span><br><span class="line">[INFO] [1734609186.005546]: hello world 1734609186.0053947</span><br><span class="line">[INFO] [1734609186.106381]: hello world 1734609186.1062553</span><br><span class="line">[INFO] [1734609186.206608]: hello world 1734609186.2064044</span><br><span class="line">[INFO] [1734609186.305868]: hello world 1734609186.3057268</span><br><span class="line">[INFO] [1734609186.406142]: hello world 1734609186.4059968</span><br><span class="line">[INFO] [1734609186.505583]: hello world 1734609186.5054214</span><br><span class="line">[INFO] [1734609186.606951]: hello world 1734609186.6068125</span><br><span class="line">[INFO] [1734609186.705764]: hello world 1734609186.7056243</span><br><span class="line">[INFO] [1734609186.805870]: hello world 1734609186.8057344</span><br><span class="line">[INFO] [1734609186.905890]: hello world 1734609186.9057145</span><br><span class="line">[INFO] [1734609187.006627]: hello world 1734609187.0064893</span><br></pre></td></tr></table></figure>
<p>wiki告诉我们，发布者节点已启动并运行。现在我们需要一个订阅者以接收来自发布者的消息。</p>
<p><strong>运行订阅者</strong></p>
<p>咱们运行刚才制作的叫做 <code>listener</code> 的订阅者：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosrun beginner_tutorials listener</span><br><span class="line"></span><br><span class="line">[INFO] [1734609563.673116]: /listener_14824_1734609563066I heard hello world 1734609563.671003</span><br><span class="line">[INFO] [1734609563.773131]: /listener_14824_1734609563066I heard hello world 1734609563.7711043</span><br><span class="line">[INFO] [1734609563.873401]: /listener_14824_1734609563066I heard hello world 1734609563.8712664</span><br><span class="line">[INFO] [1734609563.973288]: /listener_14824_1734609563066I heard hello world 1734609563.9714963</span><br><span class="line">[INFO] [1734609564.073304]: /listener_14824_1734609563066I heard hello world 1734609564.0710852</span><br><span class="line">[INFO] [1734609564.173103]: /listener_14824_1734609563066I heard hello world 1734609564.1708713</span><br><span class="line">[INFO] [1734609564.273282]: /listener_14824_1734609563066I heard hello world 1734609564.2709982</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="编写简单的服务器和客户端-Python"><a href="#编写简单的服务器和客户端-Python" class="headerlink" title="编写简单的服务器和客户端 (Python)"></a>编写简单的服务器和客户端 (Python)</h3><p><strong>编写服务节点</strong></p>
<p>跟着wiki的指引，我们将创建简单的服务节点 <code>add_two_ints_server</code>，该节点将接收两个整数，并返回它们的和。</p>
<p><strong>代码</strong></p>
<p>在beginner_tutorials包中创建 <code>scripts/add_two_ints_server.py</code> 文件并粘贴以下内容进去：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> beginner_tutorials.srv <span class="keyword">import</span> AddTwoInts,AddTwoIntsResponse</span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_add_two_ints</span>(<span class="params">req</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Returning [%s + %s = %s]&quot;</span>%(req.a, req.b, (req.a + req.b)))</span><br><span class="line">    <span class="keyword">return</span> AddTwoIntsResponse(req.a + req.b)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_two_ints_server</span>():</span><br><span class="line">    rospy.init_node(<span class="string">&#x27;add_two_ints_server&#x27;</span>)</span><br><span class="line">    s = rospy.Service(<span class="string">&#x27;add_two_ints&#x27;</span>, AddTwoInts, handle_add_two_ints)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Ready to add two ints.&quot;</span>)</span><br><span class="line">    rospy.spin()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    add_two_ints_server()</span><br></pre></td></tr></table></figure>
<p><strong>解释</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">s = rospy.Service(<span class="string">&#x27;add_two_ints&#x27;</span>, AddTwoInts, handle_add_two_ints)</span><br></pre></td></tr></table></figure>
<p>wiki告诉我们：<em>这声明了一个名为 <code>add_two_ints</code> 的新服务，其服务类型为 <code>AddTwoInts</code>。所有的请求（request）都传递给了 <code>handle_add_two_ints</code> 函数。<code>handle_add_two_ints</code> 被 <code>AddTwoIntsRequest</code> 的实例调用，返回 <code>AddTwoIntsResponse</code> 实例。</em></p>
<p><em>就像订阅者中的例子一样，<code>rospy.spin()</code> 可以防止代码在服务关闭之前退出。</em></p>
<p><strong>编写客户端节点</strong></p>
<p><strong>代码</strong></p>
<p>继续跟随wiki指引，在 <code>beginner_tutorials</code> 包中创建 <code>scripts/add_two_ints_client.py</code>文件并粘贴以下内容进去：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> beginner_tutorials.srv <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_two_ints_client</span>(<span class="params">x, y</span>):</span><br><span class="line">    rospy.wait_for_service(<span class="string">&#x27;add_two_ints&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        add_two_ints = rospy.ServiceProxy(<span class="string">&#x27;add_two_ints&#x27;</span>, AddTwoInts)</span><br><span class="line">        resp1 = add_two_ints(x, y)</span><br><span class="line">        <span class="keyword">return</span> resp1.<span class="built_in">sum</span></span><br><span class="line">    <span class="keyword">except</span> rospy.ServiceException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Service call failed: %s&quot;</span>%e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">usage</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;%s [x y]&quot;</span>%sys.argv[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) == <span class="number">3</span>:</span><br><span class="line">        x = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line">        y = <span class="built_in">int</span>(sys.argv[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(usage())</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Requesting %s+%s&quot;</span>%(x, y))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s + %s = %s&quot;</span>%(x, y, add_two_ints_client(x, y)))</span><br></pre></td></tr></table></figure>
<p><strong>解释</strong></p>
<p>wiki的解释如下：</p>
<p><em>客户端（用来调用服务）的代码也很简单。对于客户端来说不需要调用<code>init_node()</code>。我们首先调用：</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rospy.wait_for_service(&#x27;add_two_ints&#x27;)</span><br></pre></td></tr></table></figure>
<p><em>这是一种很方便的方法，可以让在<code>add_two_ints</code>服务可用之前一直阻塞。</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_two_ints = rospy.ServiceProxy(&#x27;add_two_ints&#x27;, AddTwoInts)</span><br></pre></td></tr></table></figure>
<p><em>这里我们为服务的调用创建了一个句柄（handle）。</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resp1 = add_two_ints(x, y)</span><br><span class="line">return resp1.sum</span><br></pre></td></tr></table></figure>
<p><em>然后我们可以使用这个句柄，就像普通的函数一样调用它。</em></p>
<p><em>因为我们已经将服务的类型声明为 <code>AddTwoInts</code>，它会生成 <code>AddTwoIntsRequest</code> 对象 (you’re free to pass in your own instead)。如果调用失败，<code>rospy.ServiceException</code>将会抛出，所以应该弄一个合适的 <code>try/except</code> 部分。</em></p>
<p><strong>构建节点</strong></p>
<p>继续使用CMake作为构建系统，跟前面一模一样，不再赘述~</p>
<hr>
<h3 id="检验简单的服务和客户端"><a href="#检验简单的服务和客户端" class="headerlink" title="检验简单的服务和客户端"></a>检验简单的服务和客户端</h3><p><strong>运行服务</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosrun beginner_tutorials add_two_ints_server,py</span><br><span class="line"></span><br><span class="line">Ready to add two ints.</span><br></pre></td></tr></table></figure>
<p><strong>运行客户端</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosrun beginner_tutorials add_two_ints_client.py 1 3</span><br><span class="line"></span><br><span class="line">Requesting 1+3</span><br><span class="line">1 + 3 = 4</span><br></pre></td></tr></table></figure>
<p>至此，成功地运行了第一个服务和客户端~</p>
<hr>
<h3 id="录制和回放数据"><a href="#录制和回放数据" class="headerlink" title="录制和回放数据"></a>录制和回放数据</h3><p><strong>录制数据 (创建bag文件) </strong></p>
<p>wiki告诉我们，这一部分将指导咱如何从正在运行的ROS系统中记录话题数据，话题数据将被积累到一个 <code>bag</code> 文件中。</p>
<p>咱打开三个新终端，分别输入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ roscore</span><br><span class="line"></span><br><span class="line">$ rosrun turtlesim turtlesim_node</span><br><span class="line"></span><br><span class="line">$ rosrun turtlesim turtle_teleop_key</span><br></pre></td></tr></table></figure>
<p>这三个命令就是咱之前用来控制小乌龟运动的命令。</p>
<p><strong>录制所有发布的话题</strong></p>
<p>咱们打开一个新终端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> ~/bagfiles</span><br><span class="line">$ <span class="built_in">cd</span> ~/bagfiles</span><br><span class="line">$ rosbag record -a</span><br></pre></td></tr></table></figure>
<p>wiki告诉我们，这里我们只是创建了一个临时目录来记录数据，然后运行 <code>rosbag record</code> 带选项 <code>-a</code>，表明所有发布的话题都应该积累在一个 <code>bag</code> 文件中。</p>
<p>咱们回到 <code>turtle_teleop</code> 节点所在的终端窗口，控制乌龟移动10秒左右。然后咱在运行 <code>rosbag record</code> 的窗口中按 <code>Ctrl + C</code> 退出，然后查看 <code>~/bagfiles</code> 里的内容，咱们就能发现一个以<strong>年份、日期和时间</strong>开头，并且扩展名是 <code>.bag</code> 的文件，这就是咱们所说的袋文件，它包含 <code>rosbag record</code> 运行期间由任何节点发布的所有话题。</p>
<p><strong>检查并回放bag文件</strong></p>
<p>刚才咱已经使用 <code>rosbag record</code> 命令录制了一个 <code>bag</code> 文件，接下来我们可以使用 <code>rosbag info</code> 查看它的内容，或者使用 <code>rosbag play</code> 命令回放。</p>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosbag info &lt;your bagfile&gt;</span><br></pre></td></tr></table></figure>
<p>用观察大法知，这些信息告诉了咱 <code>bag</code> 文件中所包含话题的名称、类型和消息数量。</p>
<p>下一步咱们回放 <code>bag</code> 文件以再现系统运行过程。首先用<code>Ctrl+C</code>杀死之前运行的 <code>turtle_teleop_key</code> ，但让 <code>turtlesim</code> 继续运行。在终端中 <code>bag</code> 文件所在目录下运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosbag play &lt;your bagfile&gt;</span><br></pre></td></tr></table></figure>
<p>wiki上写到：<em>默认模式下，<strong>rosbag play</strong>命令在公告每条消息后会等待一小段时间（0.2秒）才真正开始发布bag文件中的内容。等待一段时间是为了可以通知订阅者，消息已经公告且数据可能会马上到来。如果<strong>rosbag play</strong>在公告消息后立即发布，订阅者可能会接收不到几条最先发布的消息。等待时间可以通过 <code>-d</code> 选项来指定。</em></p>
<p><em>最终 <code>/turtle1/cmd_vel</code> 话题将会被发布，同时在turtuelsim中乌龟应该会像之前用turtle_teleop_key控制它那样开始移动。从运行<strong>rosbag play</strong>到乌龟开始移动时所经历时间应该近似等于之前在本教程开始部分运行<strong>rosbag record</strong>后到开始按下键盘发出控制命令时所经历时间。</em></p>
<p><strong>录制数据子集</strong></p>
<p>wiki告诉我们，当运行一个复杂的系统时，比如 <code>PR2</code> 软件套装，会有几百个话题被发布，有些话题亦会发布大量数据（比如包含摄像头图像流的话题）。在这种系统中，将包含所有话题的日志写入一个bag文件到磁盘通常是不切实际的。<strong>rosbag record</strong>命令支持只录制特定的话题到bag文件中，这样就可以只录制用户感兴趣的话题。</p>
<p>在bag文件所在目录下执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rosbag record -O subset /turtle1/cmd_vel /turtle1/pose</span><br></pre></td></tr></table></figure>
<p>上述命令中的 <code>-O</code> 参数告诉 <code>rosbag record</code> 将数据记录到名为 <code>subset.bag</code> 的文件中，而后面的 <code>topic</code> 参数告诉<code>rosbag record</code>只能订阅这两个指定的话题。然后通过键盘控制乌龟随意移动几秒钟，最后按 <code>Ctrl+C</code> 退出 <code>rosbag record</code> 命令。</p>
<p>现在看看bag文件中的内容（<code>rosbag info subset.bag</code>），里面就只包含指定的话题了~</p>
<p><strong>rosbag 录制和回放的局限性</strong></p>
<p>仔细观察发现，乌龟的路径可能并没有完全地映射到原先通过键盘控制时产生的路径上——整体形状应该是差不多的，但没有完全一样。wiki告诉我们，<em>这是因为 <code>turtlesim</code> 的移动路径对系统定时精度的变化非常敏感。<code>rosbag</code> 受制于其本身的性能无法完全复制录制时的系统运行行为，<code>rosplay</code> 也一样。对于像 <code>turtlesim</code> 这样的节点，当处理消息的过程中系统定时发生极小变化时也会使其行为发生微妙变化，用户不应该期望能够完美地模仿系统行为。</em></p>
<hr>
<h3 id="从bag文件中读取信息"><a href="#从bag文件中读取信息" class="headerlink" title="从bag文件中读取信息"></a>从bag文件中读取信息</h3><p><strong>立即回放信息并在多个终端中查看输出</strong></p>
<p>在终端里头使用下面这个命令，来手动检查所有已经发布的话题，以及向每个话题发布了多少信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ time rosbag info demo.bag</span><br><span class="line"><span class="comment"># 或者已经知道话题名称的话：</span></span><br><span class="line">$ time rosbag info mybag.bag | grep -E <span class="string">&quot;(topic1|topic2|topic3)&quot;</span></span><br></pre></td></tr></table></figure>
<p>咱们就能看到有多少条消息发布在什么话题上了~</p>
<p>有30条消息发布在 <code>/obs1/gps/fix</code> 话题上，有40条消息发布在 <code>/diagnostics_agg</code> 话题上。</p>
<p>跟着wiki，咱们还是先运行 <code>roscore</code> ，然后订阅 <code>/obs1/gps/fix</code> 话题并复读该话题发布的所有内容，同时用tee命令转储到一个 <code>yaml</code> 格式的文件中以遍之后查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rostopic <span class="built_in">echo</span> /obs1/gps/fix | <span class="built_in">tee</span> topic1.yaml</span><br></pre></td></tr></table></figure>
<p>再打开一个新终端，订阅另一个话题 <code>/diagnostics_agg</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rostopic <span class="built_in">echo</span> /diagnostics_agg | <span class="built_in">tee</span> topic2.yaml</span><br></pre></td></tr></table></figure>
<p>然后咱们还得再打开另一个新终端来回放 <code>bag</code> 文件。这一次我们将尽可能快地回放 <code>bag</code> 文件（使用 <code>--immediate</code> 选项），<strong>只</strong>会发布我们感兴趣的话题。格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">time rosbag play --immediate demo.bag --topics /obs1/gps/fix /diagnostics_agg</span><br></pre></td></tr></table></figure>
<p>现在看一下咱的两个终端，每个终端都订阅了一个话题，每个话题类型的所有消息都用 <code>YAML</code> 格式输出，每条消息之间用 <code>---</code> 分割。咱们用任意文本编辑器（我用的 <code>vscode</code>）就能查看文件中的消息了~</p>
<p><strong>使用 ros_readbagfile 脚本提取感兴趣的话题</strong></p>
<p>下载并安装 <code>ros_readbag.py</code> :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Download the file</span></span><br><span class="line">wget https://raw.githubusercontent.com/ElectricRCAircraftGuy/eRCaGuy_dotfiles/master/useful_scripts/ros_readbagfile.py</span><br><span class="line"><span class="comment"># Make it executable</span></span><br><span class="line"><span class="built_in">chmod</span> +x ros_readbagfile.py</span><br><span class="line"><span class="comment"># Ensure you have the ~/bin directory for personal binaries</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/bin</span><br><span class="line"><span class="comment"># Move this executable script into that directory as `ros_readbagfile`, so that it will</span></span><br><span class="line"><span class="comment"># be available as that command</span></span><br><span class="line"><span class="built_in">mv</span> ros_readbagfile.py ~/bin/ros_readbagfile</span><br><span class="line"><span class="comment"># Re-source your ~/.bashrc file to ensure ~/bin is in your PATH, so you can use this</span></span><br><span class="line"><span class="comment"># new `ros_readbagfile` command you just installed</span></span><br><span class="line">. ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>先通过 <code>rosbag info</code> 命令确定要从bag文件中读取的<strong>准确</strong>话题名，然后使用 <code>ros_readbagfile</code> ，格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ros_readbagfile &lt;mybagfile.bag&gt; [topic1] [topic2] [topic3] [...]</span><br></pre></td></tr></table></figure>
<p>要阅读信息，就输入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ time ros_readbagfile demo.bag /obs1/gps/fix /diagnostics_agg | <span class="built_in">tee</span> topics.yaml</span><br></pre></td></tr></table></figure>
<p>这样之后，咱们就能看到它快速打印出来了所有信息~</p>
<p>咱们用任意文本编辑器 (我用的vim) 来打开 <code>topics.yaml</code> ，就能看到它从 <code>bag</code> 文件中提取的所有信息了~</p>
<hr>
<h3 id="roswtf入门"><a href="#roswtf入门" class="headerlink" title="roswtf入门"></a>roswtf入门</h3><p>首先咱们要确保 <code>roscore</code> 没有运行</p>
<p><strong>安装检查</strong></p>
<p>这个命令可以检查我的系统，并且尝试发现问题，咱们输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ roscd rosmaster</span><br><span class="line">$ roswtf</span><br><span class="line"></span><br><span class="line">Package: rosmaster <span class="comment"># roswtf使用当前目录中的任何内容来确定其执行的检查。这个输出告诉我们是在包rosmaster的目录中启动了roswtf。</span></span><br><span class="line">================================================================================</span><br><span class="line">Static checks summary: <span class="comment"># 它会报告任何关于文件系统或非运行时（比如无需roscore的场景）的问题。本例显示我们没有错误。</span></span><br><span class="line"></span><br><span class="line">No errors or warnings</span><br><span class="line">================================================================================</span><br><span class="line"></span><br><span class="line">ROS Master does not appear to be running. <span class="comment"># roscore未在运行。roswtf不会做任何ROS在线检查。</span></span><br><span class="line">Online graph checks will not be run.</span><br><span class="line">ROS_MASTER_URI is [http://localhost:11311]</span><br></pre></td></tr></table></figure>
<p><strong>在线检查</strong></p>
<p>依照wiki，接下来咱们要启动一个 <code>Master</code> ，在新终端启动 <code>roscore</code> ，然后继续</p>
<p>现在咱们按照相同的顺序运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ roscd</span><br><span class="line">$ roswtf</span><br><span class="line"></span><br><span class="line">No package or stack <span class="keyword">in</span> context</span><br><span class="line">======================================================</span><br><span class="line">Static checks summary:</span><br><span class="line"></span><br><span class="line">No errors or warnings</span><br><span class="line">======================================================</span><br><span class="line">Beginning tests of your ROS graph. These may take awhile...</span><br><span class="line">analyzing graph...</span><br><span class="line">... <span class="keyword">done</span> analyzing graph</span><br><span class="line">running graph rules...</span><br><span class="line">... <span class="keyword">done</span> running graph rules</span><br><span class="line"></span><br><span class="line">Online checks summary:</span><br><span class="line"></span><br><span class="line">Found 1 warning(s).</span><br><span class="line">Warnings are things that may be just fine, but are sometimes at fault</span><br><span class="line"></span><br><span class="line">WARNING The following node subscriptions are unconnected:</span><br><span class="line"> * /rosout:</span><br><span class="line">   * /rosout</span><br></pre></td></tr></table></figure>
<p>显然，在输出末尾， <code>roswtf</code> 发出了警告，<code>rosout</code> 节点订阅了一个没有节点向其发布的话题。wiki告诉我们，在本例中，这正是所期望看到的，因为除了 <code>roscore</code> 没有任何其它节点在运行，所以我们就可以忽略这个警告了~</p>
<p><strong>错误</strong></p>
<p>wiki告诉我们， <code>roswtf</code> <em>会对一些系统中看起来异常但可能是正常的运行情况发出警告。也会对确实有问题的情况报告错误。</em></p>
<p>接下来按照wiki的步骤，给 <code>ROS_PACKAGE_PATH</code> 环境变量设置一个 <code>bad</code> 值，并退出 <code>roscore</code> 以简化检查输出信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ roscd</span><br><span class="line">$ ROS_PACKAGE_PATH=bad:<span class="variable">$ROS_PACKAGE_PATH</span> roswtf</span><br><span class="line"></span><br><span class="line">Stack: ros</span><br><span class="line">================================================================================</span><br><span class="line">Static checks summary:</span><br><span class="line"></span><br><span class="line">Found 1 error(s).</span><br><span class="line"></span><br><span class="line">ERROR Not all paths <span class="keyword">in</span> ROS_PACKAGE_PATH [bad] point to an existing directory: </span><br><span class="line"> * bad</span><br><span class="line"></span><br><span class="line">================================================================================</span><br><span class="line"></span><br><span class="line">Cannot communicate with master, ignoring graph checks</span><br></pre></td></tr></table></figure>
<p>显然，<code>roswtf</code> 发现了一个有关 <code>ROS_PACKAGE_PATH</code> 设置的错误。</p>
<p><code>roswtf</code> 还可以发现很多其它类型的问题。如果发现自己被构建或通信的问题难住了，可以尝试运行<code>roswtf</code>看能否指明正确的方向。</p>
<hr>
<p>至此，ROS 1学习结束~</p>
]]></content>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟退火算法</title>
    <url>/2025/01/22/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="模拟退火算法"><a href="#模拟退火算法" class="headerlink" title="模拟退火算法"></a>模拟退火算法</h1><p><strong>模拟退火思想</strong>(以寻找山的最高峰为例)</p>
<ul>
<li><p>显然，此时朴素<strong>贪心</strong>算法会<strong>失效</strong></p>
</li>
<li><p>首先在可见范围内，<strong>随机</strong>选择一点</p>
</li>
<li>若该点比当前位置更高，就<strong>直接去</strong>该点</li>
<li>如果该点更低，那么<strong>有一定概率</strong>去该点</li>
<li>在刚才的<strong>局部最优解的</strong>峰，会有一定概率走下了当前山峰，从而发现另一个山峰的上坡</li>
<li>从而就有可能走上新的更高峰</li>
</ul>
<p><strong>算法关键点</strong></p>
<ul>
<li>时间有限，需要设置终止条件 (“退火”过程中<strong>温度不断降低，剩余时间不多时就别乱跑</strong>)</li>
<li>若当前所处的山峰越高，前往低点的概率越低 (<strong>概率的表达式</strong>)</li>
</ul>
<h3 id="适用赛题"><a href="#适用赛题" class="headerlink" title="适用赛题"></a>适用赛题</h3><ul>
<li><strong>可行解过多</strong><ul>
<li>有些规划类问题的<strong>可行解过多</strong>，传统算法运算时间过长</li>
<li>能够列出可行解的任意排列</li>
</ul>
</li>
<li><strong>NP-hard问题</strong><ul>
<li>旅行推销员问题 (TSP)：给定一系列城市和每对城市之间的距离，求解访问<strong>每一座</strong>城市<strong>一次</strong>并回到<strong>起始城市</strong>的<strong>最短</strong>回路</li>
<li>TSP问题是组合优化中的一个<strong>NP-hard</strong>问题，该问题的可行解是<strong>所有顶点的全排列</strong>，随着点数的增加，会产生组合爆炸，传统算法难以求解</li>
<li>此时就适合用模拟退火等启发式算法求近似解</li>
</ul>
</li>
</ul>
<h3 id="原理与求解思路"><a href="#原理与求解思路" class="headerlink" title="原理与求解思路"></a>原理与求解思路</h3><p><strong>例题：</strong></p>
<ul>
<li>已知全国34个省会城市（包括直辖市、自治区首府和港澳台）的经纬度坐标（第一个为北京） </li>
<li>现在需要从北京出发，到所有城市视察 </li>
<li>要求每个城市只能到达一次，并最终回到北京 </li>
<li>求视察路线方案，使得总路径最短</li>
</ul>
<p>令北京为1号城市 $x_1$，剩下33个城市依次设为 $x_2,x_3,…,x_{34}$；</p>
<p>设第 $i$ 号城市 $x_i$ 与第 $i+1$ 号城市 $x_{i+1}$ 之间的路径长度为 $d_{x_i x_{i+1}}$，则目标函数： $min \ f(x_1,x_2,…,x_{35}) = \sum_{i=1}^{34} d_{x_i x_{i+1}}$</p>
<h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h4><ul>
<li>在最开始，需设定一个初始温度 $T_0$ 和问题的一个初始解 $x(0)$</li>
<li>也可用<strong>蒙特卡洛法</strong>求一个较好的初始解</li>
</ul>
<h4 id="2-随机产生新解"><a href="#2-随机产生新解" class="headerlink" title="2.随机产生新解"></a>2.随机产生新解</h4><ul>
<li>在当前温度 $T_i$ 下<strong>随机</strong>求一个解 $x’$，制定产生新解的准则 (准则不唯一，能确保<strong>随机</strong>即可)</li>
<li>假设上一步的解为： $x_1x_2…x_{u-1} x_{u} x_{u+1} … x_{v-1} x_{v} x_{v+1}…x_{35}$</li>
<li>随机选序号 $u,v$ ，将 $u$ 到 $v$ 这部分转为逆序，得到解： $x_1x_2…x_{u-1} x_{v} x_{v-1} … x_{u+1} x_{u} x_{v+1}…x_{35}$</li>
</ul>
<h4 id="3-计算目标函数差值"><a href="#3-计算目标函数差值" class="headerlink" title="3.计算目标函数差值"></a>3.计算目标函数差值</h4><ul>
<li><p>随机得到的解 $x’$ 和当前解 $x(i)$ ，两种方案总路径的差值记为 $\Delta f$ :</p>
<p>$ \Delta f = (d_{x_{u-1} x_{v}} + d_{x_{u} x_{v+1}}) - (d_{x_{u-1} x_{u}} + d_{x_{v} x_{v+1}})$</p>
</li>
</ul>
<h4 id="4-是否接受新解"><a href="#4-是否接受新解" class="headerlink" title="4.是否接受新解"></a>4.是否接受新解</h4><ul>
<li><p>接受准则：</p>
<script type="math/tex; mode=display">
P=\begin{cases}  1, & \text{ } \Delta f < 0, \\ exp(- \Delta f/T_i), & \text{ } \Delta f \geq 0. \end{cases}</script></li>
<li><p>显然，$\Delta f$ 越小，意味着随机解的总路径比原解的总路径短更多，那么接受 $x’$ 的概率就越大</p>
</li>
</ul>
<h4 id="5-马尔科夫过程"><a href="#5-马尔科夫过程" class="headerlink" title="5.马尔科夫过程"></a>5.马尔科夫过程</h4><ul>
<li>在当前温度 $T_i$ 下，重复2、3、4步</li>
<li><strong>新解 $x(i+1)$ 只与 $x(i)$ 有关</strong>，而与更早的 $x(i-1),x(i-2),…,x(0)$<strong>无关</strong></li>
<li>这是个马尔科夫过程，$x’$ 在原解 $x(i)$ 的邻域中符合<strong>均匀分布</strong></li>
</ul>
<h4 id="6-退火过程"><a href="#6-退火过程" class="headerlink" title="6. 退火过程"></a>6. 退火过程</h4><ul>
<li>选定降温系数 $\alpha$，求得新温度 $T_{i+1} = \alpha T_i$，此处设为0.999</li>
<li>再重复2、3、4、5步；然后继续降低温度</li>
</ul>
<h4 id="7-结束条件"><a href="#7-结束条件" class="headerlink" title="7.结束条件"></a>7.结束条件</h4><ul>
<li>直到温度足够小，设终止温度为 $ e = 10^{-30}$，当 $T &lt; e$ 时终止迭代，输出最终解</li>
<li>退火过程足够慢、每个温度下寻找新解的次数足够多，则最终解是全局最优解的概率越大</li>
</ul>
<p><strong>理论上，模拟退火可以找到全局最优</strong></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设的目标函数 f(x)，我们要最小化该函数</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">objective_function</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x - <span class="number">4</span> * x + <span class="number">4</span>; <span class="comment">// 例如 f(x) = x^2 - 4x + 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟退火算法</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">simulated_annealing</span><span class="params">(<span class="type">double</span> (*obj_func)(<span class="type">double</span>), <span class="type">double</span> start, <span class="type">double</span> end, <span class="type">double</span> temp, <span class="type">double</span> cooling_rate, <span class="type">int</span> iterations)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> current_solution = start + (end - start) * ((<span class="type">double</span>) <span class="built_in">rand</span>() / RAND_MAX); <span class="comment">// 随机初始解</span></span><br><span class="line">    <span class="type">double</span> current_energy = <span class="built_in">obj_func</span>(current_solution);</span><br><span class="line">    <span class="type">double</span> best_solution = current_solution;</span><br><span class="line">    <span class="type">double</span> best_energy = current_energy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">        <span class="comment">// 生成一个邻域解</span></span><br><span class="line">        <span class="type">double</span> neighbor = current_solution + (<span class="built_in">rand</span>() % <span class="number">2</span> == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>) * ((<span class="type">double</span>) <span class="built_in">rand</span>() / RAND_MAX) * <span class="number">0.1</span>; <span class="comment">// 邻域解</span></span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> neighbor_energy = <span class="built_in">obj_func</span>(neighbor);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算接受概率</span></span><br><span class="line">        <span class="keyword">if</span> (neighbor_energy &lt; current_energy || <span class="built_in">exp</span>((current_energy - neighbor_energy) / temp) &gt; ((<span class="type">double</span>) <span class="built_in">rand</span>() / RAND_MAX)) &#123;</span><br><span class="line">            current_solution = neighbor;</span><br><span class="line">            current_energy = neighbor_energy;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新最优解</span></span><br><span class="line">        <span class="keyword">if</span> (current_energy &lt; best_energy) &#123;</span><br><span class="line">            best_solution = current_solution;</span><br><span class="line">            best_energy = current_energy;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 降温</span></span><br><span class="line">        temp *= cooling_rate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> best_solution; <span class="comment">// 返回最优解</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>)); <span class="comment">// 随机数种子</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置模拟退火的参数</span></span><br><span class="line">    <span class="type">double</span> start = <span class="number">-10.0</span>;         <span class="comment">// 搜索空间的起始点</span></span><br><span class="line">    <span class="type">double</span> end = <span class="number">10.0</span>;            <span class="comment">// 搜索空间的结束点</span></span><br><span class="line">    <span class="type">double</span> initial_temperature = <span class="number">1000.0</span>;  <span class="comment">// 初始温度</span></span><br><span class="line">    <span class="type">double</span> cooling_rate = <span class="number">0.99</span>;   <span class="comment">// 降温速率</span></span><br><span class="line">    <span class="type">int</span> iterations = <span class="number">10000</span>;       <span class="comment">// 迭代次数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行模拟退火算法</span></span><br><span class="line">    <span class="type">double</span> result = <span class="built_in">simulated_annealing</span>(objective_function, start, end, initial_temperature, cooling_rate, iterations);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;最优解: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;最优目标函数值: &quot;</span> &lt;&lt; <span class="built_in">objective_function</span>(result) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title>简单扫雷游戏实现</title>
    <url>/2025/02/24/%E7%AE%80%E5%8D%95%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>如题，我编写了一个简单的C++程序，即一个简单扫雷游戏的实现。</p>
<p><strong>游戏</strong>具有以下特点：</p>
<ul>
<li>每次输入时，会有输入提示，便于确定想打开的地块对应的行和列。</li>
<li>基于 <code>bfs</code> 实现了连锁挖开地块，即点开一个无雷地块时，会连锁挖开其周围所有相邻的无雷地块，直到地块周围出现雷为止。</li>
<li>可以自定义地图大小和地雷数量。</li>
</ul>
<p><strong>程序</strong>具有以下特点：</p>
<ul>
<li>游戏功能被封装在 <code>Game</code> 类中，使得代码具有更好的可维护性和扩展性。</li>
<li>类的成员函数实现了扫雷游戏的核心逻辑，如放置地雷、计算周围地雷数量、处理连锁挖掘等。</li>
<li>使用随机数生成，确保每次游戏的地雷位置不同</li>
<li>进行边界的检查。当玩家输入不合法的位置时，会进行提示，让其重新输入。</li>
</ul>
<p>对游戏的<strong>期望</strong>：</p>
<ul>
<li>考虑增加图形化界面，使得与用户的交互性更好。</li>
<li>引入插旗功能，使得用户能对疑似地雷的方块有更清晰的记录。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Game</span> &#123;          <span class="comment">// 创建一个 Game 类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Game</span>(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> mines);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showMap</span><span class="params">()</span></span>; <span class="comment">// 函数声明，用于展示地图</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Play</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> row, col, mines;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; if_mine; </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; mine_num;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; if_dig;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">putMines</span><span class="params">()</span></span>;  <span class="comment">// 函数声明，用于放置地雷</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">countSurroundings</span><span class="params">()</span></span>;  <span class="comment">// 函数声明，用于计算每个地块周围一圈的地雷数量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">digSurroundings</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>; <span class="comment">// 函数声明，用于连锁挖开地块</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkMines</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;  <span class="comment">// 函数声明，用于检查是否踩雷</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkWin</span><span class="params">()</span></span>;  <span class="comment">// 函数声明，用于检测是否胜利</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showFinalMap</span><span class="params">()</span></span>;  <span class="comment">// 函数声明，用于展示游戏结束后的地图</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Game::<span class="built_in">Game</span>(<span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> m) : <span class="built_in">row</span>(r), <span class="built_in">col</span>(c), <span class="built_in">mines</span>(m) &#123;  <span class="comment">// 构造函数，初始化两个数组并展示地图</span></span><br><span class="line">    if_mine.<span class="built_in">resize</span>(row, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(col, <span class="literal">false</span>)); <span class="comment">// 有雷为true，没雷为false</span></span><br><span class="line">    mine_num.<span class="built_in">resize</span>(row, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(col, <span class="number">0</span>)); <span class="comment">// 记录每个地块周围8个块的雷数量</span></span><br><span class="line">    if_dig.<span class="built_in">resize</span>(row, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(col, <span class="literal">false</span>)); <span class="comment">// 记录地块是否挖开</span></span><br><span class="line">    <span class="built_in">putMines</span>();</span><br><span class="line">    <span class="built_in">countSurroundings</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Game::putMines</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &lt; mines)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">rand</span>() % row; <span class="comment">// 随机生成行和列，如果没有雷就放置雷，直到放置指定数量</span></span><br><span class="line">        <span class="type">int</span> c = <span class="built_in">rand</span>() % col;</span><br><span class="line">        <span class="keyword">if</span> (if_mine[r][c] == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            if_mine[r][c] = <span class="literal">true</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Game::countSurroundings</span><span class="params">()</span> <span class="comment">// 检测周围 8 个地块中(或 5 个、3 个)雷的数量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mineCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> di = <span class="number">-1</span>; di &lt;= <span class="number">1</span>; ++di) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> dj = <span class="number">-1</span>; dj &lt;= <span class="number">1</span>; ++dj) &#123;</span><br><span class="line">                    <span class="type">int</span> ni = i + di, nj = j + dj;</span><br><span class="line">                    <span class="keyword">if</span> (ni &gt;= <span class="number">0</span> &amp;&amp; ni &lt; row &amp;&amp; nj &gt;= <span class="number">0</span> &amp;&amp; nj &lt; col &amp;&amp; if_mine[ni][nj]) &#123;</span><br><span class="line">                        mineCount++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mine_num[i][j] = mineCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Game::digSurroundings</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="comment">// 要开始bfs挖地块了~</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mine_num[x][y] != <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">// 如果当前格子不是空的，直接返回</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;; <span class="comment">// 方向，分别是上、右上、右、右下、下、左下、左、左上</span></span><br><span class="line">    <span class="type">int</span> dy[<span class="number">8</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visit</span>(row, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(col, <span class="literal">false</span>)); <span class="comment">// 记录访问二维数组</span></span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q; <span class="comment">// 队列</span></span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x, y&#125;); <span class="comment">// 先把挖开的方块插入队尾</span></span><br><span class="line">    visit[x][y] = <span class="literal">true</span>;</span><br><span class="line">    if_dig[x][y] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; curr = q.<span class="built_in">front</span>();  <span class="comment">// 记录第一个元素，从你开始bfs</span></span><br><span class="line">        q.<span class="built_in">pop</span>();  <span class="comment">// 出队</span></span><br><span class="line">        x = curr.first; </span><br><span class="line">        y = curr.second;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> newX = x + dx[i];  </span><br><span class="line">            <span class="type">int</span> newY = y + dy[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newX &gt;= <span class="number">0</span> &amp;&amp; newX &lt; row &amp;&amp; newY &gt;= <span class="number">0</span> &amp;&amp; newY &lt; col &amp;&amp; !visit[newX][newY])</span><br><span class="line">            &#123;</span><br><span class="line">                visit[newX][newY] = <span class="literal">true</span>;  <span class="comment">// 访问后设为true</span></span><br><span class="line">                if_dig[newX][newY] = <span class="literal">true</span>;  <span class="comment">// 挖之后，将数组改为true，以便于其他函数能正常运行</span></span><br><span class="line">                <span class="keyword">if</span> (mine_num[newX][newY] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;newX, newY&#125;);  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Game::showMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>; <span class="comment">// 每次输入行列的提示</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; col; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输出列提示</span></span><br><span class="line">        cout &lt;&lt; i;</span><br><span class="line">    &#125; </span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; num; <span class="comment">// 输出行提示</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (if_dig[i][j] == <span class="literal">true</span> &amp;&amp; if_mine[i][j] != <span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; mine_num[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (if_dig[i][j] == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;*&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Game::showFinalMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (if_dig[i][j] == <span class="literal">true</span> &amp;&amp; if_mine[i][j] == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; mine_num[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (if_mine[i][j] == <span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;X&quot;</span>; <span class="comment">// 把雷全输出</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;*&quot;</span>; <span class="comment">// 未挖开的就先不挖了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Game::checkMines</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> if_mine[x][y]; <span class="comment">// 检测是不是雷</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Game::checkWin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (if_dig[i][j] == <span class="literal">false</span> &amp;&amp; if_mine[i][j] == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Game::Play</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ro, co;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">checkWin</span>() != <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">showMap</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Please enter the row and column of the square you want to open: &quot;</span>;</span><br><span class="line">        cin &gt;&gt; ro &gt;&gt; co;</span><br><span class="line">        <span class="keyword">if</span>(ro &lt; <span class="number">0</span> || ro &gt;= row || co &lt; <span class="number">0</span> || co &gt;= col)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Wuxiao input! Please try again&quot;</span> &lt;&lt; endl;  <span class="comment">// 不能越界，否则重输入</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        if_dig[ro][co] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">digSurroundings</span>(ro, co);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">checkMines</span>(ro, co) == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;You lose!&quot;</span> &lt;&lt; endl;  <span class="comment">// 一旦挖的块是雷，直接结束游戏，并展示地图中所有雷的位置</span></span><br><span class="line">            <span class="built_in">showFinalMap</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You win!&quot;</span> &lt;&lt; endl;  <span class="comment">// 不然就赢，也展示地图</span></span><br><span class="line">    <span class="built_in">showFinalMap</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> row = <span class="number">0</span>, col = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Please enter the row and column of map: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; row &gt;&gt; col;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mines = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;Please enter the number of mines: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; mines;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">Game <span class="title">game</span><span class="params">(row, col, mines)</span></span>;</span><br><span class="line">    game.<span class="built_in">Play</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象语言</title>
    <url>/2024/11/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h3 id="面向对象语言"><a href="#面向对象语言" class="headerlink" title="面向对象语言"></a>面向对象语言</h3><ul>
<li><p><strong>类和对象</strong></p>
<p>C++面向对象的三大特性为：<strong>封装、继承、多态</strong></p>
<p>C++认为<strong>万事万物都皆为对象</strong>，对象上有其属性和行为</p>
</li>
</ul>
<p>​    </p>
<p>​    例如：人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…</p>
<pre><code>     车也可以作为对象，属性有轮胎、方向盘、车灯… ,  行为有载人、放音乐、放空调…

     具有相同性质的**对象**，我们可以抽象称为**类**，人属于人类，车属于车类
</code></pre><h4 id="1-1-封装"><a href="#1-1-封装" class="headerlink" title="1.1 封装"></a>1.1 封装</h4><ol>
<li>意义：</li>
</ol>
<ul>
<li><p>将属性和行为作为一个整体，表现生活中的事物。</p>
</li>
<li><p>将属性和行为加以权限控制。</p>
</li>
</ul>
<p>​    </p>
<p><strong>意义①：将属性和行为作为一个整体，表现生活中的事物。</strong></p>
<p>​        在设计<strong>类</strong>的时候，属性和行为写在一起，表现事物。</p>
<p>​        语法：<code>class 类名&#123;访问权限: 属性/行为&#125;;</code></p>
<p>​    <strong>示例1</strong>：设计一个圆类，求圆的周长。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>  <span class="comment">//圆周率</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//封装一个圆类，求圆的周长</span></span><br><span class="line"><span class="comment">//class代表设计一个类，后面跟着的是类名</span></span><br><span class="line"><span class="keyword">class</span> Circle</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//访问权限  公共的权限</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> m_r;<span class="comment">//半径</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">calculateZC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span> * PI * m_r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Circle c1;</span><br><span class="line">    c<span class="number">1.</span>m_r = <span class="number">10</span>;<span class="comment">//给圆的半径赋值</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;圆的周长为：&quot;</span> &lt;&lt; c<span class="number">1.</span><span class="built_in">calculateZC</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>示例2：</strong> 设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">		m_name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setID</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">		m_id = id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot; ID:&quot;</span> &lt;&lt; m_id &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_name;</span><br><span class="line">	<span class="type">int</span> m_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Student stu;</span><br><span class="line">	stu.<span class="built_in">setName</span>(<span class="string">&quot;德玛西亚&quot;</span>);</span><br><span class="line">	stu.<span class="built_in">setID</span>(<span class="number">250</span>);</span><br><span class="line">	stu.<span class="built_in">showStudent</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>意义②：将属性和行为加以权限控制。</strong></p>
<p>​    类在设计时，可以把属性和行为放在不同的权限下，加以控制。访问权限有三种：</p>
<p>​        public 公共权限</p>
<p>​        protected 保护权限</p>
<p>​        private 私有权限</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三种权限</span></span><br><span class="line"><span class="comment">//公共权限  public     类内可以访问  类外可以访问</span></span><br><span class="line"><span class="comment">//保护权限  protected  类内可以访问  类外不可以访问</span></span><br><span class="line"><span class="comment">//私有权限  private    类内可以访问  类外不可以访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//姓名  公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//汽车  保护权限</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string m_Car;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//银行卡密码  私有权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_Password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_Name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">		m_Car = <span class="string">&quot;拖拉机&quot;</span>;</span><br><span class="line">		m_Password = <span class="number">123456</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Person p;</span><br><span class="line">	p.m_Name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">	<span class="comment">//p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到</span></span><br><span class="line">	<span class="comment">//p.m_Password = 123; //私有权限类外访问不到</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="2-struct和class的区别"><a href="#2-struct和class的区别" class="headerlink" title="2. struct和class的区别"></a>2. struct和class的区别</h5><p>在C++中 struct和class唯一的<strong>区别</strong>就在于<strong>默认的访问权限不同</strong>，区别：</p>
<ul>
<li>struct 默认权限为<strong>公共</strong></li>
<li>class 默认权限为<strong>私有</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>  m_A; <span class="comment">//默认是私有权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> m_A;  <span class="comment">//默认是公共权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	C1 c1;</span><br><span class="line">	c<span class="number">1.</span>m_A = <span class="number">10</span>; <span class="comment">//错误，访问权限是私有</span></span><br><span class="line"></span><br><span class="line">	C2 c2;</span><br><span class="line">	c<span class="number">2.</span>m_A = <span class="number">10</span>; <span class="comment">//正确，访问权限是公共</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="3-成员属性设置为私有"><a href="#3-成员属性设置为私有" class="headerlink" title="3.成员属性设置为私有"></a>3.成员属性设置为私有</h5><p><strong>优点1：</strong> 将所有成员属性设置为私有，可以自己控制读写权限</p>
<p><strong>优点2：</strong> 对于写权限，我们可以检测数据的有效性</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//姓名设置可读可写</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">		m_Name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">string <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取年龄 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置年龄</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">150</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;你个老妖精!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//情人设置为只写</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setLover</span><span class="params">(string lover)</span> </span>&#123;</span><br><span class="line">		m_Lover = lover;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_Name; <span class="comment">//可读可写  姓名</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> m_Age; <span class="comment">//只读  年龄</span></span><br><span class="line"></span><br><span class="line">	string m_Lover; <span class="comment">//只写  情人</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Person p;</span><br><span class="line">	<span class="comment">//姓名设置</span></span><br><span class="line">	p.<span class="built_in">setName</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//年龄设置</span></span><br><span class="line">	p.<span class="built_in">setAge</span>(<span class="number">50</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;年龄： &quot;</span> &lt;&lt; p.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//情人设置</span></span><br><span class="line">	p.<span class="built_in">setLover</span>(<span class="string">&quot;苍井&quot;</span>);</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="1-2-对象的初始化和清理"><a href="#1-2-对象的初始化和清理" class="headerlink" title="1.2 对象的初始化和清理"></a>1.2 对象的初始化和清理</h4><ul>
<li>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li>
<li>C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。</li>
</ul>
<p><strong>1.构造函数和析构函数</strong></p>
<p>​    对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题，一个对象或者变量没有初始状态，对其使用后果是未知，同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p>
<p>​    c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p>
<p>​    对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p>
<p>​    <strong>编译器提供的构造函数和析构函数是空实现</strong>。</p>
<p>​    构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。<br>​    析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</p>
<p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p>
<ol>
<li>构造函数，没有返回值也不写void</li>
<li>函数名称与类名相同</li>
<li>构造函数可以有参数，因此可以发生重载</li>
<li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li>
</ol>
<p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p>
<ol>
<li>析构函数，没有返回值也不写void</li>
<li>函数名称与类名相同,在名称前加上符号 ~</li>
<li>析构函数不可以有参数，因此不可以发生重载</li>
<li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>2.构造函数的分类及调用</strong></p>
<ul>
<li><p>两种分类方式：</p>
<p>   按<strong>参数</strong>分为：<strong>有参构造和无参构造</strong></p>
<p>   按<strong>类型</strong>分为：<strong>普通构造和拷贝构造</strong></p>
</li>
<li><p>三种调用方式：</p>
<ul>
<li><p>括号法</p>
</li>
<li><p>显示法</p>
</li>
<li><p>隐式转换法</p>
</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、构造函数分类</span></span><br><span class="line"><span class="comment">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span></span><br><span class="line"><span class="comment">// 按照类型分类分为 普通构造和拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、构造函数的调用</span></span><br><span class="line"><span class="comment">//调用无参构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p; <span class="comment">//调用无参构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用有参的构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.1  括号法，常用</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="comment">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span></span><br><span class="line">	<span class="comment">//Person p2();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.2 显式法</span></span><br><span class="line">	Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>); </span><br><span class="line">	Person p3 = <span class="built_in">Person</span>(p2);</span><br><span class="line">	<span class="comment">//Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.3 隐式转换法</span></span><br><span class="line">	Person p4 = <span class="number">10</span>; <span class="comment">// Person p4 = Person(10); </span></span><br><span class="line">	Person p5 = p4; <span class="comment">// Person p5 = Person(p4); </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span></span><br><span class="line">	<span class="comment">//Person p5(p4);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="3-拷贝构造函数调用时机"><a href="#3-拷贝构造函数调用时机" class="headerlink" title="3. 拷贝构造函数调用时机"></a>3. 拷贝构造函数调用时机</h5><p>C++中拷贝构造函数调用时机通常有三种情况</p>
<ul>
<li>使用一个已经创建完毕的对象来初始化一个新对象</li>
<li>值传递的方式给函数参数传值</li>
<li>以值方式返回局部对象</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = p.mAge;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数在释放内存之前调用</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">man</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//p对象已经创建完毕</span></span><br><span class="line">	<span class="function">Person <span class="title">newman</span><span class="params">(man)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">	Person newman2 = man; <span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Person newman3;</span></span><br><span class="line">	<span class="comment">//newman3 = man; //不是调用拷贝构造函数，赋值操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 值传递的方式给函数参数传值</span></span><br><span class="line"><span class="comment">//相当于Person p1 = p;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(Person p1)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p; <span class="comment">//无参构造函数</span></span><br><span class="line">	<span class="built_in">doWork</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 以值方式返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p1;</span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span> *)&amp;p1 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p = <span class="built_in">doWork2</span>();</span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span> *)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>4. 构造函数调用规则</strong><br>默认情况下，c++编译器至少给一个类添加3个函数</p>
<p>​    1．默认构造函数(无参，函数体为空)</p>
<p>​    2．默认析构函数(无参，函数体为空)</p>
<p>​    3．默认拷贝构造函数，对属性进行值拷贝</p>
<p>构造函数调用规则如下：</p>
<p>​    如果用户定义有参构造函数，c++不再提供默认无参构造，但是会提供默认拷贝构造</p>
<p>​    如果用户定义拷贝构造函数，c++不会再提供其他构造函数</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="comment">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p<span class="number">2.</span>age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造</span></span><br><span class="line">	Person p1; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//用户提供的有参</span></span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>; <span class="comment">//此时如果用户没有提供拷贝构造，编译器会提供</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果用户提供拷贝构造，编译器不会提供其他构造函数</span></span><br><span class="line">	Person p4; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//此时如果用户自己没有提供有参，会出错</span></span><br><span class="line">	<span class="function">Person <span class="title">p6</span><span class="params">(p5)</span></span>; <span class="comment">//用户自己提供拷贝构造</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-深拷贝与浅拷贝"><a href="#5-深拷贝与浅拷贝" class="headerlink" title="5. 深拷贝与浅拷贝"></a>5. 深拷贝与浅拷贝</h5><p>深浅拷贝是面试经典问题，也是常见的一个坑</p>
<p>​    浅拷贝：简单的赋值拷贝操作</p>
<p>​    深拷贝：在堆区重新申请空间，进行拷贝操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age ,<span class="type">int</span> height) &#123;</span><br><span class="line">		</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		m_age = age;</span><br><span class="line">		m_height = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数  </span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span></span><br><span class="line">		m_age = p.m_age;</span><br><span class="line">		m_height = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_height);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (m_height != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_height;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_age;</span><br><span class="line">	<span class="type">int</span>* m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>, <span class="number">180</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的年龄： &quot;</span> &lt;&lt; p<span class="number">1.</span>m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p<span class="number">1.</span>m_height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄： &quot;</span> &lt;&lt; p<span class="number">2.</span>m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p<span class="number">2.</span>m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="6-初始化列表"><a href="#6-初始化列表" class="headerlink" title="6. 初始化列表"></a>6. 初始化列表</h5><p><strong>作用：</strong></p>
<p>​    C++提供了初始化列表语法，用来初始化属性</p>
<p><strong>语法：</strong> <code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	传统方式初始化</span><br><span class="line">	<span class="comment">//Person(int a, int b, int c) &#123;</span></span><br><span class="line">	<span class="comment">//	m_A = a;</span></span><br><span class="line">	<span class="comment">//	m_B = b;</span></span><br><span class="line">	<span class="comment">//	m_C = c;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化列表方式初始化</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) :<span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b), <span class="built_in">m_C</span>(c) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mB:&quot;</span> &lt;&lt; m_B &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mC:&quot;</span> &lt;&lt; m_C &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">PrintPerson</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="7-类对象作为类成员"><a href="#7-类对象作为类成员" class="headerlink" title="7. 类对象作为类成员"></a>7. 类对象作为类成员</h5><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    A a；</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>B类中有对象A作为成员，A为对象成员，那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Phone</span>(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		m_PhoneName = name;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Phone构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Phone</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Phone析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	string m_PhoneName;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化列表可以告诉编译器调用哪一个构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(string name, string pName) :<span class="built_in">m_Name</span>(name), <span class="built_in">m_Phone</span>(pName)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">playGame</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; 使用&quot;</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="string">&quot; 牌手机! &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	Phone m_Phone;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//当类中成员是其他类对象时，我们称该成员为 对象成员</span></span><br><span class="line">	<span class="comment">//构造的顺序是 ：先调用对象成员的构造，再调用本类构造</span></span><br><span class="line">	<span class="comment">//析构顺序与构造相反</span></span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span> , <span class="string">&quot;苹果X&quot;</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">playGame</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="8-静态成员"><a href="#8-静态成员" class="headerlink" title="8. 静态成员"></a>8. 静态成员</h5><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p>
<p>静态成员分为：</p>
<ul>
<li>静态成员变量<ul>
<li>所有对象共享同一份数据</li>
<li>在编译阶段分配内存</li>
<li>类内声明，类外初始化</li>
</ul>
</li>
<li>静态成员函数<ul>
<li>所有对象共享同一个函数</li>
<li>静态成员函数只能访问静态成员变量</li>
</ul>
</li>
</ul>
<p><strong>示例1 ：</strong> 静态成员变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员变量特点：</span></span><br><span class="line">	<span class="comment">//1 在编译阶段分配内存</span></span><br><span class="line">	<span class="comment">//2 类内声明，类外初始化</span></span><br><span class="line">	<span class="comment">//3 所有对象共享同一份数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_B; <span class="comment">//静态成员变量也是有访问权限的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、通过对象</span></span><br><span class="line">	Person p1;</span><br><span class="line">	p<span class="number">1.</span>m_A = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p<span class="number">1.</span>m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	Person p2;</span><br><span class="line">	p<span class="number">2.</span>m_A = <span class="number">200</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p<span class="number">1.</span>m_A &lt;&lt; endl; <span class="comment">//共享同一份数据</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2.m_A = &quot;</span> &lt;&lt; p<span class="number">2.</span>m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、通过类名</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong> 静态成员函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员函数特点：</span></span><br><span class="line">	<span class="comment">//1 程序共享一个函数</span></span><br><span class="line">	<span class="comment">//2 静态成员函数只能访问静态成员变量</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">		<span class="comment">//m_B = 100; //错误，不可以访问非静态成员变量</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line">	<span class="type">int</span> m_B; <span class="comment">// </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员函数也是有访问权限的</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func2调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、通过对象</span></span><br><span class="line">	Person p1;</span><br><span class="line">	p<span class="number">1.f</span>unc();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、通过类名</span></span><br><span class="line">	Person::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Person::func2(); //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="1-3-C-对象模型和this指针"><a href="#1-3-C-对象模型和this指针" class="headerlink" title="1.3 C++对象模型和this指针"></a>1.3 C++对象模型和this指针</h4><h5 id="1-成员变量和成员函数分开存储"><a href="#1-成员变量和成员函数分开存储" class="headerlink" title="1. 成员变量和成员函数分开存储"></a>1. 成员变量和成员函数分开存储</h5><p>在C++中，类内的成员变量和成员函数分开存储，只有非静态成员变量才属于类的对象上.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		mA = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//非静态成员变量占对象空间</span></span><br><span class="line">	<span class="type">int</span> mA;</span><br><span class="line">	<span class="comment">//静态成员变量不占对象空间</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> mB; </span><br><span class="line">	<span class="comment">//函数也不占对象空间，所有函数共享一个函数实例</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mA &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//静态成员函数也不占对象空间</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(Person) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>2. this指针概念</strong></p>
<p>在C++中成员变量和成员函数是分开存储的</p>
<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p>
<p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p>
<p>​    c++通过提供特殊的对象指针，this指针，解决上述问题。this指针指向被调用的成员函数所属的对象。</p>
<p>this指针是隐含每一个非静态成员函数内的一种指针，不需要定义，直接使用即可</p>
<p>this指针的用途：</p>
<ul>
<li>当形参和成员变量同名时，可用this指针来区分</li>
<li>在类的非静态成员函数中返回对象本身，可使用return *this</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//1、当形参和成员变量同名时，可用this指针来区分</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person&amp; <span class="title">PersonAddPerson</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">		<span class="comment">//返回对象本身</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.age = &quot;</span> &lt;&lt; p<span class="number">1.</span>age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	p<span class="number">2.</span><span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2.age = &quot;</span> &lt;&lt; p<span class="number">2.</span>age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="3-空指针访问成员函数"><a href="#3-空指针访问成员函数" class="headerlink" title="3. 空指针访问成员函数"></a>3. 空指针访问成员函数</h5><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p>
<p>如果用到this指针，需要加以判断保证代码的健壮性</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//空指针访问成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我是Person类!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person * p = <span class="literal">NULL</span>;</span><br><span class="line">	p-&gt;<span class="built_in">ShowClassName</span>(); <span class="comment">//空指针，可以调用成员函数</span></span><br><span class="line">	p-&gt;<span class="built_in">ShowPerson</span>();  <span class="comment">//但是如果成员函数中用到了this指针，就不可以了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="4-const修饰成员函数"><a href="#4-const修饰成员函数" class="headerlink" title="4. const修饰成员函数"></a>4. const修饰成员函数</h5><p><strong>常函数：</strong></p>
<ul>
<li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li>
<li>常函数内不可以修改成员属性</li>
<li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li>
</ul>
<p><strong>常对象：</strong></p>
<ul>
<li>声明对象前加const称该对象为常对象</li>
<li>常对象只能调用常函数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		m_A = <span class="number">0</span>;</span><br><span class="line">		m_B = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//this指针的本质是一个指针常量，指针的指向不可修改</span></span><br><span class="line">	<span class="comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="comment">//const Type* const pointer;</span></span><br><span class="line">		<span class="comment">//this = NULL; //不能修改指针的指向 Person* const this;</span></span><br><span class="line">		<span class="comment">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="comment">//mA = 10000;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> m_B; <span class="comment">//可修改 可变的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰对象  常对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> Person person; <span class="comment">//常量对象  </span></span><br><span class="line">	cout &lt;&lt; person.m_A &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span></span><br><span class="line">	person.m_B = <span class="number">100</span>; <span class="comment">//但是常对象可以修改mutable修饰成员变量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//常对象访问成员函数</span></span><br><span class="line">	person.<span class="built_in">MyFunc</span>(); <span class="comment">//常对象不能调用const的函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="1-4-友元"><a href="#1-4-友元" class="headerlink" title="1.4 友元"></a>1.4 友元</h4><p>生活中你的家有客厅(Public)，有你的卧室(Private)，客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去。但是，你也可以允许你的好闺蜜好基友进去。在程序里，有些<strong>私有属性</strong>也想让类外特殊的一些函数或者类进行访问，就需要用到<strong>友元</strong>的技术。</p>
<p>友元的目的就是让一个函数或者类 访问另一个类中私有成员，其关键字为 friend。</p>
<p><strong>友元的三种实现</strong></p>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<p><strong>1. 全局函数做友元</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Building</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom; <span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Building b;</span><br><span class="line">	<span class="built_in">goodGay</span>(&amp;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>2. 类做友元</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">goodGay</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">goodGay</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">	building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	goodGay gg;</span><br><span class="line">	gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. 成员函数做友元</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">goodGay</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>; <span class="comment">//只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">	building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	goodGay  gg;</span><br><span class="line">	gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="1-5-运算符重载"><a href="#1-5-运算符重载" class="headerlink" title="1.5 运算符重载"></a>1.5 运算符重载</h4><p><strong>1. 加号运算符重载</strong></p>
<p>作用：实现两个自定义数据类型相加的计算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;&#125;;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//成员函数实现 + 号运算符重载</span></span><br><span class="line">	Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		Person temp;</span><br><span class="line">		temp.m_A = <span class="keyword">this</span>-&gt;m_A + p.m_A;</span><br><span class="line">		temp.m_B = <span class="keyword">this</span>-&gt;m_B + p.m_B;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现 + 号运算符重载</span></span><br><span class="line"><span class="comment">//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;</span></span><br><span class="line"><span class="comment">//	Person temp(0, 0);</span></span><br><span class="line"><span class="comment">//	temp.m_A = p1.m_A + p2.m_A;</span></span><br><span class="line"><span class="comment">//	temp.m_B = p1.m_B + p2.m_B;</span></span><br><span class="line"><span class="comment">//	return temp;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符重载 可以发生函数重载 </span></span><br><span class="line">Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p2, <span class="type">int</span> val)  </span><br><span class="line">&#123;</span><br><span class="line">	Person temp;</span><br><span class="line">	temp.m_A = p<span class="number">2.</span>m_A + val;</span><br><span class="line">	temp.m_B = p<span class="number">2.</span>m_B + val;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//成员函数方式</span></span><br><span class="line">	Person p3 = p2 + p1;  <span class="comment">//相当于 p2.operaor+(p1)</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p<span class="number">3.</span>m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p<span class="number">3.</span>m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Person p4 = p3 + <span class="number">10</span>; <span class="comment">//相当于 operator+(p3,10)</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p<span class="number">4.</span>m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p<span class="number">4.</span>m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> <strong>总结：~对于内置的数据类型的表达式的的运算符是不可能改变的</strong></p>
<p>​        <strong>~不要滥用运算符重载</strong></p>
<h5 id="2-左移运算符重载"><a href="#2-左移运算符重载" class="headerlink" title="2.  左移运算符重载"></a>2.  左移运算符重载</h5><p>作用：可以输出自定义数据类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span></span><br><span class="line">	<span class="comment">//void operator&lt;&lt;(Person&amp; p)&#123;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现左移重载</span></span><br><span class="line"><span class="comment">//ostream对象只能有一个</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;</span><br><span class="line">	out &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; p.m_B;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl; <span class="comment">//链式编程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>总结：~重载左移运算符配合友元可以实现输出自定义数据类型</strong></p>
<h5 id="3-递增运算符重载"><a href="#3-递增运算符重载" class="headerlink" title="3 递增运算符重载"></a>3 递增运算符重载</h5><p>作用： 通过重载递增运算符，实现自己的整型数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyInteger</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyInteger</span>() &#123;</span><br><span class="line">		m_Num = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//前置++</span></span><br><span class="line">	MyInteger&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">		<span class="comment">//先++</span></span><br><span class="line">		m_Num++;</span><br><span class="line">		<span class="comment">//再返回</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后置++</span></span><br><span class="line">	MyInteger <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">		<span class="comment">//先返回</span></span><br><span class="line">		MyInteger temp = *<span class="keyword">this</span>; <span class="comment">//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；</span></span><br><span class="line">		m_Num++;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;</span><br><span class="line">	out &lt;&lt; myint.m_Num;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//前置++ 先++ 再返回</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	MyInteger myInt;</span><br><span class="line">	cout &lt;&lt; ++myInt &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++ 先返回 再++</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	MyInteger myInt;</span><br><span class="line">	cout &lt;&lt; myInt++ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>总结：前置递增返回引用，后置递增返回值</strong></p>
<p><strong>4. 赋值运算符重载</strong></p>
<p>c++编译器至少给一个类添加4个函数</p>
<ol>
<li>默认构造函数(无参，函数体为空)</li>
<li>默认析构函数(无参，函数体为空)</li>
<li>默认拷贝构造函数，对属性进行值拷贝</li>
<li>赋值运算符 operator=, 对属性进行值拷贝</li>
</ol>
<p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//将年龄数据开辟到堆区</span></span><br><span class="line">		m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重载赋值运算符 </span></span><br><span class="line">	Person&amp; <span class="keyword">operator</span>=(Person &amp;p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Age;</span><br><span class="line">			m_Age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//编译器提供的代码是浅拷贝</span></span><br><span class="line">		<span class="comment">//m_Age = p.m_Age;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//提供深拷贝 解决浅拷贝的问题</span></span><br><span class="line">		m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Age);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//返回自身</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Age;</span><br><span class="line">			m_Age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//年龄的指针</span></span><br><span class="line">	<span class="type">int</span> *m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	p3 = p2 = p1; <span class="comment">//赋值操作</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; *p<span class="number">1.</span>m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; *p<span class="number">2.</span>m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p3的年龄为：&quot;</span> &lt;&lt; *p<span class="number">3.</span>m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//int a = 10;</span></span><br><span class="line">	<span class="comment">//int b = 20;</span></span><br><span class="line">	<span class="comment">//int c = 30;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//c = b = a;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>5. 关系运算符重载</strong></p>
<p><strong>作用：</strong>重载关系运算符，可以让两个自定义类型对象进行对比操作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(Person &amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>!=(Person &amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//int a = 0;</span></span><br><span class="line">	<span class="comment">//int b = 0;</span></span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">a</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">b</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (a == b)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (a != b)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="6-函数调用运算符重载"><a href="#6-函数调用运算符重载" class="headerlink" title="6. 函数调用运算符重载"></a>6. 函数调用运算符重载</h5><ul>
<li>函数调用运算符 () 也可以重载</li>
<li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li>
<li>仿函数没有固定写法，非常灵活</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string text)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//重载的（）操作符 也称为仿函数</span></span><br><span class="line">	MyPrint myFunc;</span><br><span class="line">	<span class="built_in">myFunc</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 + v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyAdd add;</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">add</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//匿名对象调用  </span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;MyAdd()(100,100) = &quot;</span> &lt;&lt; <span class="built_in">MyAdd</span>()(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="1-6-继承"><a href="#1-6-继承" class="headerlink" title="1.6 继承"></a>1.6 继承</h4><p>​    继承是面向对象三大特性之一</p>
<p>​    我们可以考虑利用继承的技术，减少重复代码</p>
<p><strong>1. 继承的基本语法</strong></p>
<p>​    例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同。接下</p>
<p>来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p>
<p><strong>普通实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Java页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Java ja;</span><br><span class="line">	ja.<span class="built_in">header</span>();</span><br><span class="line">	ja.<span class="built_in">footer</span>();</span><br><span class="line">	ja.<span class="built_in">left</span>();</span><br><span class="line">	ja.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Python页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Python py;</span><br><span class="line">	py.<span class="built_in">header</span>();</span><br><span class="line">	py.<span class="built_in">footer</span>();</span><br><span class="line">	py.<span class="built_in">left</span>();</span><br><span class="line">	py.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//C++页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	CPP cp;</span><br><span class="line">	cp.<span class="built_in">header</span>();</span><br><span class="line">	cp.<span class="built_in">footer</span>();</span><br><span class="line">	cp.<span class="built_in">left</span>();</span><br><span class="line">	cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>继承实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公共页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Java页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Java ja;</span><br><span class="line">	ja.<span class="built_in">header</span>();</span><br><span class="line">	ja.<span class="built_in">footer</span>();</span><br><span class="line">	ja.<span class="built_in">left</span>();</span><br><span class="line">	ja.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Python页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Python py;</span><br><span class="line">	py.<span class="built_in">header</span>();</span><br><span class="line">	py.<span class="built_in">footer</span>();</span><br><span class="line">	py.<span class="built_in">left</span>();</span><br><span class="line">	py.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//C++页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	CPP cp;</span><br><span class="line">	cp.<span class="built_in">header</span>();</span><br><span class="line">	cp.<span class="built_in">footer</span>();</span><br><span class="line">	cp.<span class="built_in">left</span>();</span><br><span class="line">	cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>继承的好处：<strong>可以减少重复的代码</strong></p>
<p>class A : public B;</p>
<p>A 类称为子类 或 派生类</p>
<p>B 类称为父类 或 基类</p>
<p><strong>派生类中的成员，包含两大部分：</strong></p>
<p>一类是从基类继承过来的，一类是自己增加的成员。</p>
<p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p>
<p><strong>2. 继承方式</strong></p>
<p>继承的语法：<code>class 子类 : 继承方式 父类</code></p>
<p><strong>继承方式一共有三种：</strong></p>
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> :<span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A; <span class="comment">//可访问 public权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son1 s1;</span><br><span class="line">	s<span class="number">1.</span>m_A; <span class="comment">//其他类只能访问到公共权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>:<span class="keyword">protected</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son2 s;</span><br><span class="line">	<span class="comment">//s.m_A; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>:<span class="keyword">private</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A; <span class="comment">//可访问 private权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 private权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandSon3</span> :<span class="keyword">public</span> Son3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span></span><br><span class="line">		<span class="comment">//m_A;</span></span><br><span class="line">		<span class="comment">//m_B;</span></span><br><span class="line">		<span class="comment">//m_C;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="3-继承中的对象模型"><a href="#3-继承中的对象模型" class="headerlink" title="3. 继承中的对象模型"></a>3. 继承中的对象模型</h5><p><strong>问题：</strong> 从父类继承过来的成员，哪些属于子类对象中？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C; <span class="comment">//私有成员只是被隐藏了，但是还是会继承下去</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Son) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>打开工具窗口后，定位到当前CPP文件的盘符</p>
<p>然后输入： <code>cl /d1 reportSingleClassLayout</code>查看的类名 所属文件名</p>
<p><strong>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</strong></p>
<h5 id="4-继承中构造和析构顺序"><a href="#4-继承中构造和析构顺序" class="headerlink" title="4. 继承中构造和析构顺序"></a>4. 继承中构造和析构顺序</h5><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p>
<p>问题：父类和子类的构造和析构顺序是谁先谁后？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span></span><br><span class="line">	Son s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</strong></p>
<h5 id="5-继承同名成员处理方式"><a href="#5-继承同名成员处理方式" class="headerlink" title="5. 继承同名成员处理方式"></a>5. 继承同名成员处理方式</h5><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p>
<ul>
<li>访问子类同名成员 直接访问即可</li>
<li>访问父类同名成员 需要加作用域</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - func(int a)调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">200</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span></span><br><span class="line">	<span class="comment">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son s;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	s.<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>​    ~子类对象可以直接访问到子类中同名成员</p>
<p>​    ~子类对象加作用域可以访问到父类同名成员</p>
<p>​    ~当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</p>
<h5 id="6-继承同名静态成员处理方式"><a href="#6-继承同名静态成员处理方式" class="headerlink" title="6. 继承同名静态成员处理方式"></a>6. 继承同名静态成员处理方式</h5><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p>
<p>静态成员和非静态成员出现同名，处理方式一致</p>
<ul>
<li>访问子类同名成员 直接访问即可</li>
<li>访问父类同名成员 需要加作用域</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员属性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//通过对象访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过类名访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//通过对象访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Son s;</span><br><span class="line">	s.<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Son::<span class="built_in">func</span>();</span><br><span class="line">	Son::Base::<span class="built_in">func</span>();</span><br><span class="line">	<span class="comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span></span><br><span class="line">	Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（ 通过对象 和 通过类名 ）</strong></p>
<h5 id="7-多继承语法"><a href="#7-多继承语法" class="headerlink" title="7. 多继承语法"></a>7. 多继承语法</h5><p>C++允许<strong>一个类继承多个类</strong></p>
<p>语法：<code>class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p>
<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>
<p><strong>C++实际开发中不建议用多继承</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base1</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base2</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">200</span>;  <span class="comment">//开始是m_B 不会出问题，但是改为mA就会出现不明确</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_C = <span class="number">300</span>;</span><br><span class="line">		m_D = <span class="number">400</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">	<span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多继承容易产生成员同名的情况</span></span><br><span class="line"><span class="comment">//通过使用类名作用域可以区分调用哪一个基类的成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(s) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</strong></p>
<p><strong>8. 菱形继承</strong></p>
<p>菱形继承概念：</p>
<pre><code> 两个派生类继承同一个基类，又有某个类同时继承者两个派生类，这种继承被称为**菱形继承**，或者钻石继承。
</code></pre><p><strong>菱形继承问题：</strong></p>
<pre><code>1. 羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。
2. 草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。
</code></pre><p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承前加virtual关键字后，变为虚继承</span></span><br><span class="line"><span class="comment">//此时公共的父类Animal称为虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span>   : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepTuo</span> : <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SheepTuo st;</span><br><span class="line">	st.Sheep::m_Age = <span class="number">100</span>;</span><br><span class="line">	st.Tuo::m_Age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<p>​    ~菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</p>
<p>​    ~利用虚继承可以解决菱形继承问题</p>
<hr>
<h4 id="1-7-多态"><a href="#1-7-多态" class="headerlink" title="1.7 多态"></a>1.7 多态</h4><p><strong>1. 多态的基本概念</strong><br>多态是C++面向对象三大特性之一，它分为<strong>静态多态和动态多态</strong>两类：</p>
<p>​    静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名<br>​    动态多态: 派生类和虚函数实现运行时多态</p>
<p>静态多态和动态多态区别：</p>
<p>​    静态多态的函数地址早绑定 - 编译阶段确定函数地址<br>​    动态多态的函数地址晚绑定 - 运行阶段确定函数地址</p>
<p><strong>案例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//Speak函数就是虚函数</span></span><br><span class="line">	<span class="comment">//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//我们希望传入什么对象，那么就调用什么对象的函数</span></span><br><span class="line"><span class="comment">//如果函数地址在编译阶段就能确定，那么静态联编</span></span><br><span class="line"><span class="comment">//如果函数地址在运行阶段才能确定，就是动态联编</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSpeak</span><span class="params">(Animal &amp; animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//多态满足条件： </span></span><br><span class="line"><span class="comment">//1、有继承关系</span></span><br><span class="line"><span class="comment">//2、子类重写父类中的虚函数</span></span><br><span class="line"><span class="comment">//多态使用：</span></span><br><span class="line"><span class="comment">//父类指针或引用指向子类对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Cat cat;</span><br><span class="line">	<span class="built_in">DoSpeak</span>(cat);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Dog dog;</span><br><span class="line">	<span class="built_in">DoSpeak</span>(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<p>​    ~多态满足条件：</p>
<p>​        有继承关系</p>
<p>​        子类重写父类中的虚函数</p>
<p>​    ~多态使用条件：</p>
<p>​        父类指针或引用指向子类对象</p>
<p><strong>重写</strong>：<strong>函数返回值类型、函数名、参数列表</strong>完全一致称为重写</p>
<p>**2. 多态案例一-计算器类</p>
<p>案例描述：</p>
<p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p>
<p>多态的优点：</p>
<ul>
<li>代码组织结构清晰</li>
<li>可读性强</li>
<li>利于前期和后期的扩展以及维护</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">(string oper)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (oper == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果要提供新的运算，需要修改源码</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_Num1;</span><br><span class="line">	<span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//普通实现测试</span></span><br><span class="line">	Calculator c;</span><br><span class="line">	c.m_Num1 = <span class="number">10</span>;</span><br><span class="line">	c.m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;+&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;-&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;*&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多态实现</span></span><br><span class="line"><span class="comment">//抽象计算器类</span></span><br><span class="line"><span class="comment">//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractCalculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_Num1;</span><br><span class="line">	<span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MulCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建加法计算器</span></span><br><span class="line">	AbstractCalculator *abc = <span class="keyword">new</span> AddCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;  <span class="comment">//用完了记得销毁</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建减法计算器</span></span><br><span class="line">	abc = <span class="keyword">new</span> SubCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;  </span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建乘法计算器</span></span><br><span class="line">	abc = <span class="keyword">new</span> MulCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</strong></p>
<p><strong>3. 纯虚函数和抽象类</strong><br>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容，因此可以将虚函数改为纯虚函数。</p>
<p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p>
<p>当类中有了纯虚函数，这个类也称为<strong>抽象类</strong></p>
<p>抽象类特点：</p>
<p>​    无法实例化对象<br>​    子类必须重写抽象类中的纯虚函数，否则也属于抽象类</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//纯虚函数</span></span><br><span class="line">	<span class="comment">//类中只要有一个纯虚函数就称为抽象类</span></span><br><span class="line">	<span class="comment">//抽象类无法实例化对象</span></span><br><span class="line">	<span class="comment">//子类必须重写父类中的纯虚函数，否则也属于抽象类</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base * base = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//base = new Base; // 错误，抽象类无法实例化对象</span></span><br><span class="line">	base = <span class="keyword">new</span> Son;</span><br><span class="line">	base-&gt;<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">delete</span> base;<span class="comment">//记得销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="4-多态案例二-制作饮品"><a href="#4-多态案例二-制作饮品" class="headerlink" title="4. 多态案例二-制作饮品"></a>4. 多态案例二-制作饮品</h5><p><strong>案例描述：</strong></p>
<p>制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料</p>
<p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象制作饮品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractDrinking</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//规定流程</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MakeDrink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">Boil</span>();</span><br><span class="line">		<span class="built_in">Brew</span>();</span><br><span class="line">		<span class="built_in">PourInCup</span>();</span><br><span class="line">		<span class="built_in">PutSomething</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作咖啡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> : <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;煮农夫山泉!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;冲泡咖啡!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;将咖啡倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;加入牛奶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作茶水</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span> : <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;煮自来水!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;冲泡茶叶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;将茶水倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;加入枸杞!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoWork</span><span class="params">(AbstractDrinking* drink)</span> </span>&#123;</span><br><span class="line">	drink-&gt;<span class="built_in">MakeDrink</span>();</span><br><span class="line">	<span class="keyword">delete</span> drink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">DoWork</span>(<span class="keyword">new</span> Coffee);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">DoWork</span>(<span class="keyword">new</span> Tea);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>5. 虚析构和纯虚析构</strong></p>
<p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>解决方式：将父类中的析构函数改为虚析构或者纯虚析构</p>
<p>虚析构和纯虚析构共性：</p>
<p>​    可以解决父类指针释放子类对象<br>​    都需要有具体的函数实现</p>
<p>虚析构和纯虚析构区别：</p>
<p>​    如果是纯虚析构，该类属于抽象类，无法实例化对象</p>
<p>虚析构语法：<code>virtual ~类名()&#123;&#125;</code></p>
<p>纯虚析构语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">virtual ~类名() = 0;</span><br><span class="line">类名::~类名()&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Animal</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Animal 构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构函数加上virtual关键字，变成虚析构函数</span></span><br><span class="line">	<span class="comment">//virtual ~Animal()</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~<span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Animal 纯虚析构函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Cat</span>(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cat构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">		m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; *m_Name &lt;&lt;  <span class="string">&quot;小猫在说话!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Cat</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cat析构函数调用!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Name;</span><br><span class="line">			m_Name = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string *m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Animal *animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">	animal-&gt;<span class="built_in">Speak</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span></span><br><span class="line">	<span class="comment">//怎么解决？给基类增加一个虚析构函数</span></span><br><span class="line">	<span class="comment">//虚析构函数就是用来解决通过父类指针释放子类对象</span></span><br><span class="line">	<span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<p> ~虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p>
<p> ~如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p>
<p> ~拥有纯虚析构函数的类也属于抽象类</p>
<p><strong>6. 多态案例三-电脑组装</strong></p>
<p><strong>案例描述：</strong></p>
<p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p>
<p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</p>
<p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口。测试时组装三台不同的电脑进行工作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象CPU类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的计算函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象显卡类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoCard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的显示函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象内存条类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的存储函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Computer</span>(CPU * cpu, VideoCard * vc, Memory * mem)</span><br><span class="line">	&#123;</span><br><span class="line">		m_cpu = cpu;</span><br><span class="line">		m_vc = vc;</span><br><span class="line">		m_mem = mem;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提供工作的函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//让零件工作起来，调用接口</span></span><br><span class="line">		m_cpu-&gt;<span class="built_in">calculate</span>();</span><br><span class="line"></span><br><span class="line">		m_vc-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">		m_mem-&gt;<span class="built_in">storage</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提供析构函数 释放3个电脑零件</span></span><br><span class="line">	~<span class="built_in">Computer</span>()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放CPU零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_cpu != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_cpu;</span><br><span class="line">			m_cpu = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放显卡零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_vc != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_vc;</span><br><span class="line">			m_vc = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放内存条零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_mem != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_mem;</span><br><span class="line">			m_mem = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	CPU * m_cpu; <span class="comment">//CPU的零件指针</span></span><br><span class="line">	VideoCard * m_vc; <span class="comment">//显卡零件指针</span></span><br><span class="line">	Memory * m_mem; <span class="comment">//内存条零件指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体厂商</span></span><br><span class="line"><span class="comment">//Intel厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lenovo厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Lenovo的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Lenovo的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Lenovo的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//第一台电脑零件</span></span><br><span class="line">	CPU * intelCpu = <span class="keyword">new</span> IntelCPU;</span><br><span class="line">	VideoCard * intelCard = <span class="keyword">new</span> IntelVideoCard;</span><br><span class="line">	Memory * intelMem = <span class="keyword">new</span> IntelMemory;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//创建第一台电脑</span></span><br><span class="line">	Computer * computer1 = <span class="keyword">new</span> <span class="built_in">Computer</span>(intelCpu, intelCard, intelMem);</span><br><span class="line">	computer1-&gt;<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer1;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第二台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//第二台电脑组装</span></span><br><span class="line">	Computer * computer2 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> LenovoVideoCard, <span class="keyword">new</span> LenovoMemory);;</span><br><span class="line">	computer2-&gt;<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer2;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第三台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//第三台电脑组装</span></span><br><span class="line">	Computer * computer3 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> IntelVideoCard, <span class="keyword">new</span> LenovoMemory);;</span><br><span class="line">	computer3-&gt;<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
