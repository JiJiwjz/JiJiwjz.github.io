<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="ROS 1在 ROS-Wiki 上，我们可以得知ROS到底是个啥：  简介：ROS 是一个适用于机器人的开源的元操作系统。它提供了操作系统应有的服务，包括硬件抽象，底层设备控制，常用函数的实现，进程间消息传递，以及包管理。它也提供用于获取、编译、编写、和跨计算机运行代码所需的工具和库函数。在某些方面ROS相当于一种”机器人框架“。（复制粘贴的）">
<meta property="og:type" content="article">
<meta property="og:title" content="ROS1初步学习">
<meta property="og:url" content="http://example.com/2024/11/19/ROS1%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Samxander&#39;s home">
<meta property="og:description" content="ROS 1在 ROS-Wiki 上，我们可以得知ROS到底是个啥：  简介：ROS 是一个适用于机器人的开源的元操作系统。它提供了操作系统应有的服务，包括硬件抽象，底层设备控制，常用函数的实现，进程间消息传递，以及包管理。它也提供用于获取、编译、编写、和跨计算机运行代码所需的工具和库函数。在某些方面ROS相当于一种”机器人框架“。（复制粘贴的）">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/images/ROS_pic1.png">
<meta property="article:published_time" content="2024-11-19T12:15:39.000Z">
<meta property="article:modified_time" content="2025-02-19T12:22:11.846Z">
<meta property="article:author" content="Sam">
<meta property="article:tag" content="ROS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/ROS_pic1.png">

<link rel="canonical" href="http://example.com/2024/11/19/ROS1%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>ROS1初步学习 | Samxander's home</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?39a7b28cea42de31b1e8e2834e588560";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Samxander's home</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">You shall see the difference now that we are back again!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/19/ROS1%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="Sam">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Samxander's home">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ROS1初步学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-11-19 20:15:39" itemprop="dateCreated datePublished" datetime="2024-11-19T20:15:39+08:00">2024-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-19 20:22:11" itemprop="dateModified" datetime="2025-02-19T20:22:11+08:00">2025-02-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="ROS-1"><a href="#ROS-1" class="headerlink" title="ROS 1"></a>ROS 1</h1><p>在 <code>ROS-Wiki</code> 上，我们可以得知ROS到底是个啥：</p>
<p> <strong>简介：</strong>ROS 是一个适用于机器人的开源的元操作系统。它提供了操作系统应有的服务，包括硬件抽象，底层设备控制，常用函数的实现，进程间消息传递，以及包管理。它也提供用于获取、编译、编写、和跨计算机运行代码所需的工具和库函数。在某些方面ROS相当于一种”机器人框架“。（<del>复制粘贴的</del>）</p>
<p><strong>ROS1的安装</strong></p>
<p>我已经在虚拟机上准备了一个已经换好源的 Ubuntu 20.04 ，我们将在这个系统上运行 ROS。</p>
<p>根据csdn上的教程，我根据我的乌班图版本选择了 <code>ROS Noetic Ninjemys</code> 这个ROS版本</p>
<p>安装完 <code>ros</code> 之后，这篇博客还推荐配置 <code>rosdep</code> ，我也顺手搞定了。(<em>不知道为什么，博主推荐的一键安装失效了，还是我手动配置的</em>)</p>
<h2 id="ROS1-初级教程学习"><a href="#ROS1-初级教程学习" class="headerlink" title="ROS1 初级教程学习"></a>ROS1 初级教程学习</h2><p><strong>配置ROS环境</strong></p>
<p>由于我安装的是 <code>ROS Noetic Ninjemys</code>  这个版本，得先输入如下指令才能访问ROS相关的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /opt/ros/noetic/setup.bash</span><br></pre></td></tr></table></figure>
<p>每次都输太麻烦，所以直接使用 <code>vim ~/.bashrc</code> 这条指令，在文件末尾插入上述命令(<del>我用的小鱼一键安装，搞半天像傻子一样打开才发现人家已经在文件末尾写好了</del>)</p>
<p><strong>创建ROS工作空间</strong></p>
<p>我们要使用wiki里面给出的指令创建和构建一个 <code>catkin工作空间</code> 。wiki还告诉我们，<code>catkin_make</code>命令在 <code>catkin工作空间</code> 中是一个非常方便的工具。在工作空间中第一次运行它时，它会在<code>src</code>目录下创建一个 <code>CMakeLists.txt</code> 的链接。</p>
<p>然后继续根据要求，<code>source</code>一下新生成的 <code>setup.*sh</code> 文件，再确定一下那个环境变量包括我当前的工作目录就行了。</p>
<hr>
<h3 id="ROS-文件系统导览"><a href="#ROS-文件系统导览" class="headerlink" title="ROS 文件系统导览"></a>ROS 文件系统导览</h3><ul>
<li>软件包(Packages)：wiki告诉我们，包是ROS代码的<strong>软件组织单元</strong>，每个软件包都可以包含程序库、可执行文件、脚本或者其他构件。</li>
<li>清单(Manifests)：清单是对软件包的描述。他用于定义软件包之间的依赖关系，并记录有关软件包的元信息，比如版本、维护者、许可证之类的。</li>
</ul>
<p>程序的代码散落在许多ROS包里头，如果使用<code>ls</code> <code>cd</code> 这些来进行查找和导航比较繁琐，因此ROS提供了专门的命令工具来简化这些操作。</p>
<p><strong>rospack</strong></p>
<p>这个命令允许我们获取软件包的有关信息，wiki给我们讲了 <code>find</code> 这个参数：</p>
<p>使用如下代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rospack find roscpp</span><br></pre></td></tr></table></figure>
<p>它输出的是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/ros/noetic/share/roscpp</span><br></pre></td></tr></table></figure>
<p>所以显然，这个选项能够返回软件包的所在路径。</p>
<p><strong>roscd</strong></p>
<p><code>roscd</code> 由 <code>ros</code> 和 <code>cd</code> 组成，所以显然，这个命令可以让我们直接切换目录到某个软件包或者软件包集。</p>
<p>依次输入如下代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ roscd roscpp</span><br><span class="line">$ <span class="built_in">pwd</span></span><br></pre></td></tr></table></figure>
<p>它输出的是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/ros/noetic/share/roscpp</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>子目录</strong></li>
</ul>
<p>​    <code>roscd</code> 也可以切换到一个软件包或软件包集的子目录中。</p>
<p>​    执行如下代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ roscd roscpp/cmake</span><br><span class="line">$ <span class="built_in">pwd</span></span><br></pre></td></tr></table></figure>
<p>​    结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/ros/noetic/share/roscpp/cmake</span><br></pre></td></tr></table></figure>
<ul>
<li>roscd log</li>
</ul>
<p>​    这个命令会进入存储 <code>ROS</code> 日志文件的目录。</p>
<p>​    如果没有执行过任何 <code>ROS</code> 程序，系统会报错说该目录不存在。即如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">No active roscore</span><br><span class="line">bash: <span class="built_in">cd</span>: /home/wjz2024302124/.ros/log: No such file or directory</span><br></pre></td></tr></table></figure>
<p><strong>rosls</strong></p>
<p>这个命令允许直接按软件包的名称执行 <code>ls</code> 命令，而不需要繁琐地输入绝对路径。</p>
<p>执行如下代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rosls roscpp_tutorials</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake launch package.xml  srv</span><br></pre></td></tr></table></figure>
<p><strong>Tab 补全</strong></p>
<p>总是输入完整的软件包名称比较繁琐，而一些ROS工具支持<strong>Tab补全</strong>这个功能</p>
<p>输入如下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ roscd roscpp_tut&lt;&lt;&lt;按TAB键&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>它会自动补全如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ roscd roscpp_tutorials/</span><br></pre></td></tr></table></figure>
<p>然而，当输入的东西不完整，并且有许多软件包以输入的东西作为开头，再次按下TAB键会列出所有以其开头的ROS软件包。</p>
<hr>
<h3 id="创建ROS软件包"><a href="#创建ROS软件包" class="headerlink" title="创建ROS软件包"></a>创建ROS软件包</h3><p><strong>一个catkin软件包的组成</strong>：</p>
<ul>
<li>一个符合 <code>catkin</code> 规范的 <code>package.xml</code> 文件，用于提供该软件包的元信息</li>
<li>一个 <code>catkin</code> 版本的 <code>CMakeLists.txt</code> 文件或文件的相关样板</li>
<li>目录（同一个目录下不能有嵌套的或者多个软件包存在）</li>
</ul>
<p>最简单的软件包看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_package/</span><br><span class="line">  CMakeLists.txt</span><br><span class="line">  package.xml</span><br></pre></td></tr></table></figure>
<p><strong>catkin工作空间中的软件包</strong></p>
<p>开发 <code>catkin</code> 软件包的推荐方法是使用 <code>catkin工作空间</code>，但也可以单独开发 <code>catkin</code> 软件包。</p>
<p><strong>创建catkin软件包</strong></p>
<p>先切换到创建的空白catkin工作空间中的源文件空间目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/catkin_ws/src</span><br></pre></td></tr></table></figure>
<p>然后使用 <code>catkin_create_pkg</code> 命令创建一个名为 <code>beginner_tutorials</code> 的新软件包，这个软件包依赖于 <code>std_msgs</code>、<code>roscpp</code> 和 <code>rospy</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ catkin_create_pkg beginner_tutorials std_msgs rospy roscpp</span><br></pre></td></tr></table></figure>
<p>这样搞的话就会创建一个名为 <code>beginner_tutorials</code> 的文件夹，这个文件夹里面包含一个 <code>package.xml</code> 文件和一个<code>CMakeLists.txt</code> 文件，这两个文件都已经部分填写了在执行 <code>catkin_create_pkg</code> 命令时提供的信息。</p>
<p><code>catkin_create_pkg</code> 命令会要求输入 <code>package_name</code> ，如有需要还可以在后面添加一些需要依赖的其它软件包。</p>
<p><strong>构建一个catkin工作区并生效配置文件</strong></p>
<p>现在咱们在catkin工作区中构建软件包：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ catkin_make</span><br></pre></td></tr></table></figure>
<p>工作空间构建完成后，在 <code>devel</code> 子目录下创建了一个与通常在 <code>/opt/ros/$ROSDISTRO_NAME</code> 下看到的目录结构类似的结构。</p>
<p>要将这个工作空间添加到ROS环境中，需要<code>source</code>一下生成的配置文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ . ~/catkin_ws/devel/setup.bash</span><br></pre></td></tr></table></figure>
<p><strong>软件包依赖关系</strong></p>
<p><strong>一级依赖</strong></p>
<p>之前在使用 <code>catkin_create_pkg</code> 命令时提供了几个软件包作为依赖关系，现在我们可以使用 <code>rospack</code> 命令工具来查看这些<strong>一级依赖</strong>包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rospack depends1 beginner_tutorials</span><br></pre></td></tr></table></figure>
<p>结果是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">roscpp</span><br><span class="line">rospy</span><br><span class="line">std_msgs</span><br></pre></td></tr></table></figure>
<p>诶，这不就是前面咱们加的东西吗？</p>
<p><code>rospack</code>列出了在运行 <code>catkin_create_pkg</code> 命令时作为参数的依赖包，这些依赖关系存储在 <code>package.xml</code> 文件中。</p>
<p><strong>间接依赖</strong></p>
<p>一个依赖还会有自己的依赖关系，譬如 <code>rospy</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ rospack depends1 rospy</span><br><span class="line"></span><br><span class="line">genpy</span><br><span class="line">roscpp</span><br><span class="line">rosgraph</span><br><span class="line">rosgraph_msgs</span><br><span class="line">roslib</span><br><span class="line">std_msgs</span><br></pre></td></tr></table></figure>
<p>一个软件包可以有相当多间接的依赖关系，使用 <code>rospack</code> 就可以递归检测出所有嵌套的依赖包。</p>
<p><strong>自定义软件包</strong></p>
<p><strong>自定义<code>package.xml</code></strong></p>
<ul>
<li><p>描述标签</p>
<p>注意到 <code>description</code> 标签 <code>&lt;description&gt;The beginner_tutorials package&lt;/description&gt;</code> ，可以将描述信息修改为任何内容。</p>
</li>
<li><p>维护者标签</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- One maintainer tag required, multiple allowed, one person per tag --&gt;</span><br><span class="line">&lt;!-- Example:  --&gt;</span><br><span class="line">&lt;!-- &lt;maintainer email=<span class="string">&quot;jane.doe@example.com&quot;</span>&gt;Jane Doe&lt;/maintainer&gt; --&gt;</span><br><span class="line">&lt;maintainer email=<span class="string">&quot;wjz2024302124@todo.todo&quot;</span>&gt;wjz2024302124&lt;/maintainer&gt;</span><br></pre></td></tr></table></figure>
<p>从wiki中我们可以知道，这是 <code>package.xml</code> 中的一个重要标签，因为它能够让其他人联系到软件包的相关人员。这里至少需要填写一个维护者，但如果想的话可以添加多个。除了在标签里面填写维护者的名字外，还应该在标签的<code>email</code>属性中填写电子邮件地址。</p>
</li>
<li><p>许可证标签</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- One license tag required, multiple allowed, one license per tag --&gt;</span><br><span class="line">&lt;!-- Commonly used license strings: --&gt;</span><br><span class="line">&lt;!--   BSD, MIT, Boost Software License, GPLv2, GPLv3, LGPLv2.1, LGPLv3 --&gt;</span><br><span class="line">&lt;license&gt;TODO&lt;/license&gt;</span><br></pre></td></tr></table></figure>
<p>在wiki中提到，我们应使用BSD。</p>
</li>
<li><p>依赖项标签</p>
</li>
</ul>
<p>​    接下来的标签描述了软件包的依赖关系，这些依赖项分为<code>build_depend</code>、<code>buildtool_depend</code>、<code>run_depend</code>、<code>test_depend</code>。</p>
<pre><code>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- The *depend tags are used to specify dependencies --&gt;</span><br><span class="line">&lt;!-- Dependencies can be catkin packages or system dependencies --&gt;</span><br><span class="line">&lt;!-- Examples: --&gt;</span><br><span class="line">&lt;!-- Use depend as a shortcut <span class="keyword">for</span> packages that are both build and <span class="built_in">exec</span> dependencies --&gt;</span><br><span class="line">&lt;!--   &lt;depend&gt;roscpp&lt;/depend&gt; --&gt;</span><br><span class="line">&lt;!--   Note that this is equivalent to the following: --&gt;</span><br><span class="line">&lt;!--   &lt;build_depend&gt;roscpp&lt;/build_depend&gt; --&gt;</span><br><span class="line">&lt;!--   &lt;exec_depend&gt;roscpp&lt;/exec_depend&gt; --&gt;</span><br><span class="line">&lt;!-- Use build_depend <span class="keyword">for</span> packages you need at compile time: --&gt;</span><br><span class="line">&lt;!--   &lt;build_depend&gt;message_generation&lt;/build_depend&gt; --&gt;</span><br><span class="line">&lt;!-- Use build_export_depend <span class="keyword">for</span> packages you need <span class="keyword">in</span> order to build against this package: --&gt;</span><br><span class="line">&lt;!--   &lt;build_export_depend&gt;message_generation&lt;/build_export_depend&gt; --&gt;</span><br><span class="line">&lt;!-- Use buildtool_depend <span class="keyword">for</span> build tool packages: --&gt;</span><br><span class="line">&lt;!--   &lt;buildtool_depend&gt;catkin&lt;/buildtool_depend&gt; --&gt;</span><br><span class="line">&lt;!-- Use exec_depend <span class="keyword">for</span> packages you need at runtime: --&gt;</span><br><span class="line">&lt;!--   &lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; --&gt;</span><br><span class="line">&lt;!-- Use test_depend <span class="keyword">for</span> packages you need only <span class="keyword">for</span> testing: --&gt;</span><br><span class="line">&lt;!--   &lt;test_depend&gt;gtest&lt;/test_depend&gt; --&gt;</span><br><span class="line">&lt;!-- Use doc_depend <span class="keyword">for</span> packages you need only <span class="keyword">for</span> building documentation: --&gt;</span><br><span class="line">&lt;!--   &lt;doc_depend&gt;doxygen&lt;/doc_depend&gt; --&gt;</span><br><span class="line">&lt;buildtool_depend&gt;catkin&lt;/buildtool_depend&gt;</span><br><span class="line">&lt;build_depend&gt;roscpp&lt;/build_depend&gt;</span><br><span class="line">&lt;build_depend&gt;rospy&lt;/build_depend&gt;</span><br><span class="line">&lt;build_depend&gt;std_msgs&lt;/build_depend&gt;</span><br><span class="line">&lt;build_export_depend&gt;roscpp&lt;/build_export_depend&gt;</span><br><span class="line">&lt;build_export_depend&gt;rospy&lt;/build_export_depend&gt;</span><br><span class="line">&lt;build_export_depend&gt;std_msgs&lt;/build_export_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;roscpp&lt;/exec_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;rospy&lt;/exec_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt;</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>最终的 <code>package.xml</code></p>
<p>去掉注释和未使用标签即可。</p>
</li>
</ul>
<hr>
<h3 id="构建ROS软件包"><a href="#构建ROS软件包" class="headerlink" title="构建ROS软件包"></a>构建ROS软件包</h3><p>只要安装了这个包的所有系统依赖项，就可以开始编译软件包了。</p>
<p><code>catkin_make</code> 的用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ catkin_make [make_targets] [-DCMAKE_VARIABLES=...]</span><br></pre></td></tr></table></figure>
<p><strong>开始构建软件包</strong></p>
<p>输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/catkin_ws/</span><br><span class="line">$ <span class="built_in">ls</span> src</span><br><span class="line"></span><br><span class="line">beginner_tutorials  CMakeLists.txt</span><br></pre></td></tr></table></figure>
<p>现在我们可以使用catkin_make来构建</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ catkin_make</span><br></pre></td></tr></table></figure>
<p>这样的话就成功构建了一个ROS软件包。</p>
<hr>
<h3 id="理解ROS节点"><a href="#理解ROS节点" class="headerlink" title="理解ROS节点"></a>理解ROS节点</h3><p><strong>图概念</strong></p>
<p>(概念来自wiki)计算图是一个由ROS进程组成的点对点网络，它们能够共同处理数据。</p>
<p>ROS的基本计算图概念：</p>
<ul>
<li>节点：一个可执行文件，可通过ROS来与其他节点进行通信</li>
<li>消息：订阅或发布话题时所使用的ROS数据类型</li>
<li>话题：节点可以将消息发布到话题，或通过订阅话题来接收消息</li>
<li>主节点：ROS的命名服务，例如帮助节点发现彼此</li>
<li>rosout：在ROS中相当于 <code>stdout/stderr</code> </li>
<li>roscore：主节点 + rosout + 参数服务器(wiki提到后面会进行介绍)</li>
</ul>
<p><strong>节点</strong></p>
<p>正如上面提到的，它是一个可执行文件。ROS节点使用ROS客户端库与其他节点通信。节点可以发布或订阅话题，也可以提供或使用服务。</p>
<p>（wiki里面的例子，是把遥控器和机器人当做两个节点来理解）</p>
<p><strong>客户端库</strong></p>
<p>ROS客户端库可以让用不同编程语言编写的节点进行相互通信：</p>
<ul>
<li>rospy=Python数据库</li>
<li>roscpp=C++数据库</li>
</ul>
<p><strong>roscore</strong></p>
<p>wiki提到，这个命令是在运行所有ROS程序前首先要运行的命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ roscore</span><br></pre></td></tr></table></figure>
<p>我这边并没有按照预期显示，有可能网络配置出问题了，所以我输入了如下代码，保证其能够完成单机配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> ROS_HOSTNAME=localhost</span><br><span class="line">$ <span class="built_in">export</span> ROS_MASTER_URI=http://localhost:11311</span><br></pre></td></tr></table></figure>
<p>最终成功。</p>
<p><strong>rosnode</strong></p>
<p>在保持原来终端开着的情况下，打开一个新终端。 <code>rosnode</code>显示当前正在运行的ROS节点信息。<code>rosnode list</code>命令会列出这些活动的节点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rosnode list</span><br><span class="line"></span><br><span class="line">/rosout</span><br></pre></td></tr></table></figure>
<p>表示当前只有一个节点在运行：<code>rosout</code> 。这个节点用于收集和记录节点的调试输出，所以总是运行着的。</p>
<p><code>rosnode info</code>命令返回的是某个指定节点的信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ rosnode info /rosout</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">Node [/rosout]</span><br><span class="line">Publications: </span><br><span class="line"> * /rosout_agg [rosgraph_msgs/Log]</span><br><span class="line"></span><br><span class="line">Subscriptions: </span><br><span class="line"> * /rosout [unknown <span class="built_in">type</span>]</span><br><span class="line"></span><br><span class="line">Services: </span><br><span class="line"> * /rosout/get_loggers</span><br><span class="line"> * /rosout/set_logger_level</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contacting node http://localhost:35183/ ...</span><br><span class="line">Pid: 11688</span><br></pre></td></tr></table></figure>
<p>wiki表示，这给了我们更多关于<code>rosout</code>的信息，比如说实际上它是发布了一个<code>/rosout_agg</code>话题。</p>
<p><strong>rosrun</strong></p>
<p>这个指令可以让咱们用包名直接运行软件包内的节点，不需要知道包的路径。</p>
<p>它的用法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rosrun [package_name] [node_name]</span><br></pre></td></tr></table></figure>
<p>wiki指引我们运行一个运行 <code>turtlesim</code> 包中的 <code>turtlesim_node</code> ，跟随wiki的指引，我们能够看到一个蓝底的窗口上有一只乌龟。</p>
<p>咱们还可以通过命令行重新分配名称，例如输入以下代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rosrun turtlesim turtlesim_node __name:=my_turtle</span><br></pre></td></tr></table></figure>
<p>节点的名称就被更改了。</p>
<hr>
<h3 id="理解ROS话题"><a href="#理解ROS话题" class="headerlink" title="理解ROS话题"></a>理解ROS话题</h3><p>先把roscore运行着，然后打开一个<strong>新终端</strong>就行，输入如下代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rosrun turtlesim turtlesim_node</span><br></pre></td></tr></table></figure>
<p><strong>通过键盘遥控turtle</strong></p>
<p>这时候已经有一个乌龟窗口被打开了，<strong>再</strong>打开一个<strong>新终端</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rosrun turtlesim turtle_teleop_key</span><br></pre></td></tr></table></figure>
<p>这时候就可以用方向键来控制乌龟了 (↑是向头指向的方向移动，←→是调整方向)</p>
<p><strong>ROS话题</strong></p>
<p>wiki告诉我们，刚才提到的 <code>turtlesim_node</code> 节点和 <code>turtle_teleop_key</code> 节点之间是通过一个ROS<strong>话题</strong>来相互通信的。<code>turtle_teleop_key</code>在话题上<strong>发布</strong>键盘按下的消息，<code>turtlesim</code>则<strong>订阅</strong>该话题以接收消息。</p>
<p><strong>rqt_graph</strong></p>
<p><code>rqt_graph</code> 用动态的图显示了系统中正在发生的事情。</p>
<p>安装完 <code>rqt_graph</code> 之后，再打开一个<strong>新</strong>终端：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rosrun rqt_graph rqt_graph</span><br></pre></td></tr></table></figure>
<p>此时会弹出一个新的窗口，把鼠标放在 <code>/turtle1/command_velocity</code> 上方，ROS节点会变为蓝and绿色，话题会变成红色。</p>
<p>wiki告诉我们，<code>turtlesim_node</code> 和 <code>turtle_teleop_key</code> 节点正通过一个名为 <code>/turtle1/command_velocity</code> 的话题来相互通信。</p>
<p><strong>rostopic</strong></p>
<p>这个命令可以让我们来获取ROS话题的信息，可以使用 <code>$ rostopic -h</code> 来查看可用的子命令。</p>
<p><strong>rostopic echo</strong></p>
<p>这个命令可以显示在某个话题上发布的数据，用法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rostopic <span class="built_in">echo</span> [topic]</span><br></pre></td></tr></table></figure>
<p>现在让我们看看由 <code>turtle_teleop_key</code> 节点发布的“指令、速度”数据。再打开一个<strong>新</strong>终端：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ rostopic <span class="built_in">echo</span> /turtlel/cmd_vel</span><br><span class="line"></span><br><span class="line">linear: </span><br><span class="line">  x: 2.0</span><br><span class="line">  y: 0.0</span><br><span class="line">  z: 0.0</span><br><span class="line">angular: </span><br><span class="line">  x: 0.0</span><br><span class="line">  y: 0.0</span><br><span class="line">  z: 0.0</span><br><span class="line">---</span><br><span class="line">linear: </span><br><span class="line">  x: 0.0</span><br><span class="line">  y: 0.0</span><br><span class="line">  z: 0.0</span><br><span class="line">angular: </span><br><span class="line">  x: 0.0</span><br><span class="line">  y: 0.0</span><br><span class="line">  z: 2.0</span><br></pre></td></tr></table></figure>
<p>我随便点了两下，就有上述的输出。</p>
<p>再看一下 <code>rqt_graph</code> ，按下左上角的刷新按钮显示新的节点：现在 <code>rostopic echo</code>（红色）现在也<strong>订阅</strong>了 <code>turtle1/command_velocity</code>这个话题。</p>
<p><strong>rostopic list</strong></p>
<p>这个命令能够列出当前已经被订阅和发布的所有话题。</p>
<p>咱们继续打开一个<strong>新</strong>终端：（向上面一样，可以通过 <code>$ rostopic list -h</code> 命令打开帮助页面）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ rostopic list -v</span><br><span class="line"></span><br><span class="line">Published topics:</span><br><span class="line"> * /rosout_agg [rosgraph_msgs/Log] 1 publisher</span><br><span class="line"> * /rosout [rosgraph_msgs/Log] 5 publishers</span><br><span class="line"> * /turtle1/pose [turtlesim/Pose] 1 publisher</span><br><span class="line"> * /turtle1/color_sensor [turtlesim/Color] 1 publisher</span><br><span class="line"> * /turtle1/cmd_vel [geometry_msgs/Twist] 1 publisher</span><br><span class="line"></span><br><span class="line">Subscribed topics:</span><br><span class="line"> * /rosout [rosgraph_msgs/Log] 1 subscriber</span><br><span class="line"> * /turtle1/cmd_vel [geometry_msgs/Twist] 2 subscribers</span><br><span class="line"> * /statistics [rosgraph_msgs/TopicStatistics] 1 subscriber</span><br></pre></td></tr></table></figure>
<p>如输出所示，这样会列出所有发布和订阅的主题及其类型的详细信息。</p>
<p><strong>ROS 消息</strong></p>
<p>wiki告诉我们，话题的通信是通过节点间发送<strong>ROS消息</strong>实现的。</p>
<p>为了使发布者（<code>turtle_teleop_key</code>）和订阅者（<code>turtulesim_node</code>）进行通信，发布者和订阅者必须发送和接收相同<strong>类型</strong>的消息。这意味着话题的<strong>类型</strong>是由发布在它上面消息的<strong>类型</strong>决定的。使用<code>rostopic type</code>命令可以查看发布在话题上的消息的<strong>类型</strong>。</p>
<p><strong>rostopic type</strong></p>
<p>这个命令是用来查看所发布话题的消息类型。</p>
<p>用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rostopic <span class="built_in">type</span> [topic]</span><br></pre></td></tr></table></figure>
<p>根据wiki，我们运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rostopic <span class="built_in">type</span> /turtle1/cmd_vel</span><br><span class="line"></span><br><span class="line">geometry_msgs/Twist</span><br></pre></td></tr></table></figure>
<p>继续用rosmsg查看消息的详细信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ rosmsg show geometry_msgs/Twist</span><br><span class="line"></span><br><span class="line">geometry_msgs/Vector3 linear</span><br><span class="line">  float64 x</span><br><span class="line">  float64 y</span><br><span class="line">  float64 z</span><br><span class="line">geometry_msgs/Vector3 angular</span><br><span class="line">  float64 x</span><br><span class="line">  float64 y</span><br><span class="line">  float64 z</span><br></pre></td></tr></table></figure>
<p>所以，现在我们已经知道了 <code>turtlesim</code> 节点想要的消息类型，然后就可以发布命令给 <code>turtle</code> 了。</p>
<p><strong>rostopic pub</strong></p>
<p>这个命令可以把数据发布到当前某个正在广播的话题上。</p>
<p>用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rostopic pub [topic] [msg_type] [args]</span><br></pre></td></tr></table></figure>
<p>继续跟着wiki的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rostopic pub -1 /turtle1/cmd_vel geometry_msgs/Twist -- <span class="string">&#x27;[2.0, 0.0, 0.0]&#x27;</span> <span class="string">&#x27;[0.0, 0.0, 1.8]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>根据wiki上的解释，我们得知这个命令会发送一条消息给 <code>turtlesim</code> ，告诉它要以2.0的线速度和1.8的角速度移动。</p>
<p>逐步解析：</p>
<ul>
<li><code>rostopic pub</code> 将消息发布到指定的话题；</li>
<li><code>-1</code> 这个选项会让 <code>rostopic</code> 只发布一条消息，然后退出；</li>
<li><code>/turtle1/cmd_vel</code> 是要发布到的话题的名称；</li>
<li><code>geometry_mags/Twist</code> 是发布到话题时要使用的消息的类型；</li>
<li><code>--</code> 用来告诉选项解析器，表明之后的参数都不是选项。如果参数前有破折号（-）比如负数，那么这是必需的；</li>
<li><code>&#39;[2.0, 0.0, 0.0]&#39; &#39;[0.0, 0.0, 1.8]&#39;</code> ：如前所述，一个 <code>turtlesim/Velocity</code> 消息有两个浮点型元素：<code>linear</code>和<code>angular</code>。在本例中，<code>&#39;[2.0, 0.0, 0.0]&#39;</code>表示 <code>linear</code> 的值为 <code>x=2.0</code>, <code>y=0.0</code>, <code>z=0.0</code>，而<code>&#39;[0.0, 0.0, 1.8]&#39;</code> 是说 <code>angular</code> 的值为 <code>x=0.0</code>, <code>y=0.0</code>, <code>z=1.8</code>。而且根据wiki我们得知，这些参数使用的是YAML语法。</li>
</ul>
<p>我们发现，小乌龟动了一小下就停止移动了。wiki告诉我们，<code>turtle</code> 需要一个稳定的频率为1Hz的指令流才能保持移动状态。我们可以使用 <code>rostopic pub -r</code>命令来发布源源不断的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rostopic pub /turtle1/cmd_vel geometry_msgs/Twist -r 1 -- <span class="string">&#x27;[2.0, 0.0, 0.0]&#x27;</span> <span class="string">&#x27;[0.0, 0.0, -1.8]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>诶，这样的话小乌龟就一直在动了！</p>
<p><strong>rostopic hz</strong></p>
<p>这个命令呢，是用来报告数据发布的速率的~</p>
<p>用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rostopic hz [topic]</span><br></pre></td></tr></table></figure>
<p>比如，咱们看一下 <code>turtlesim_node</code> 发布 <code>/turtle/pose</code> 的速率：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ rostopic hz /turtle1/pose</span><br><span class="line"></span><br><span class="line">average rate: 62.477</span><br><span class="line">	min: 0.015s max: 0.017s std dev: 0.00050s window: 63</span><br><span class="line">average rate: 62.480</span><br><span class="line">	min: 0.015s max: 0.017s std dev: 0.00053s window: 125</span><br><span class="line">average rate: 62.485</span><br><span class="line">	min: 0.015s max: 0.017s std dev: 0.00054s window: 188</span><br><span class="line">average rate: 62.493</span><br><span class="line">	min: 0.015s max: 0.017s std dev: 0.00054s window: 251</span><br><span class="line">average rate: 62.485</span><br><span class="line">	min: 0.014s max: 0.017s std dev: 0.00057s window: 313</span><br><span class="line">average rate: 62.487</span><br><span class="line">	min: 0.014s max: 0.017s std dev: 0.00057s window: 376</span><br></pre></td></tr></table></figure>
<p>由上可知，<code>turtlesim</code> 正以大约 <code>60Hz</code> 的频率发布有关乌龟的数据。</p>
<p><strong>rqt_plot</strong></p>
<p>这个命令可以在<strong>滚动时间图上</strong>显示发布到某个话题上的数据。这里我们将使用 <code>rqt_plot</code> 命令来绘制正被发布到 <code>/turtle1/pose</code> 话题上的数据。</p>
<p>再再再再次打开一个<strong>新</strong>终端：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rosrun rqt_plot rqt_plot</span><br></pre></td></tr></table></figure>
<p>然后就弹出了一个新窗口，咱们在左上角这个文本框里头添加任何想要绘制的话题</p>
<p><img src="/images/ROS_pic1.png" alt="ROS_pic1"></p>
<p>咱们输入 <code>/turtle1/pose/x</code> 之后，按一下变亮的加号按钮；对 <code>turtle1/pose/y</code> 重复这样的过程，咱们就能看到龟龟的 <code>x-y</code> 位置力~</p>
<p>按下减号按钮会显示一组菜单，可以在图中隐藏指定的话题。</p>
<p>到此为止，咱们已经理解了ROS话题是如何工作的了~</p>
<hr>
<h3 id="理解ROS服务和参数"><a href="#理解ROS服务和参数" class="headerlink" title="理解ROS服务和参数"></a>理解ROS服务和参数</h3><p><strong>ROS服务</strong></p>
<p>wiki告诉我们，<em>服务</em> 是节点之间通讯的另一种方式，服务允许节点发送一个<strong>请求</strong>并获得一个<strong>响应</strong>。</p>
<p><strong>rosservice</strong></p>
<p><code>rosservice</code> 可以通过服务附加到ROS客户端/服务器框架上。</p>
<p>用法：(摘自wiki)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rosservice list         输出活跃服务的信息</span><br><span class="line">rosservice call         用给定的参数调用服务</span><br><span class="line">rosservice <span class="built_in">type</span>         输出服务的类型</span><br><span class="line">rosservice find         按服务的类型查找服务</span><br><span class="line">rosservice uri          输出服务的ROSRPC uri</span><br></pre></td></tr></table></figure>
<p><strong>rosservice list</strong></p>
<p>在终端输入这个命令 (注意要打开小乌龟的窗口)，它会显示 <code>turtlesim</code> 节点提供了哪些服务，比如 <code>clear</code> <del>就不一一列举了</del></p>
<p><strong>rosservice type</strong></p>
<p>以 <code>clear</code> 服务为例，我们来查看它的类型：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rosservice <span class="built_in">type</span> /clear</span><br><span class="line"></span><br><span class="line">std_srvs/Empty</span><br></pre></td></tr></table></figure>
<p>wiki告诉我们，服务的类型为 <code>empty</code>（空），这表明调用这个服务时不需要参数（即，它在发出<strong>请求</strong>时不发送数据，在接收<strong>响应</strong>时也不接收数据）。</p>
<p><strong>rosservice call</strong></p>
<p>这个命令就是用来调用服务的，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rosservice call /clear</span><br></pre></td></tr></table></figure>
<p>在终端输入后，我们不难发现，小乌龟窗口中背景的轨迹被清除了</p>
<p>我们再来试试有参数的服务 <code>spawn</code> ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ rosservice <span class="built_in">type</span> /spawn | rossrv show</span><br><span class="line"></span><br><span class="line">float32 x</span><br><span class="line">float32 y</span><br><span class="line">float32 theta</span><br><span class="line">string name</span><br><span class="line">---</span><br><span class="line">string name</span><br></pre></td></tr></table></figure>
<p>咱们来观察一下返回的东西：显然，这个服务能让我们可以在给定的位置和角度生成一只新的乌龟，还可以给它起名字。</p>
<p><strong>rosparam</strong></p>
<p>这个命令可以让我们在 <code>ROS参数服务器</code> 上<strong>存储</strong>和<strong>操作</strong>数据。</p>
<p>参数服务器能够存储整型、浮点型、布尔、字典和列表这些数据类型。<code>rosparam</code> 使用YAML标记语言的语法。一般而言，YAML的表述很自然，<code>1</code> 是整型，<code>1.0</code> 是浮点型，<code>one</code> 是字符串，<code>true</code> 是布尔型，<code>[1, 2, 3]</code> 是整型组成的列表…</p>
<p><code>rosparam</code> 有很多命令可以用来操作参数，wiki告诉了我们这些命令的用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rosparam <span class="built_in">set</span>            设置参数</span><br><span class="line">rosparam get            获取参数</span><br><span class="line">rosparam load           从文件中加载参数</span><br><span class="line">rosparam dump           向文件中转储参数</span><br><span class="line">rosparam delete         删除参数</span><br><span class="line">rosparam list           列出参数名</span><br></pre></td></tr></table></figure>
<p><strong>rosparam list</strong></p>
<p>我们使用这个命令之后，可以看到参数服务器上有3个参数用于设定背景颜色：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/rosdistro</span><br><span class="line">/roslaunch/uris/host_nxt__43407</span><br><span class="line">/rosversion</span><br><span class="line">/run_id</span><br><span class="line">/turtlesim/background_b</span><br><span class="line">/turtlesim/background_g</span><br><span class="line">/turtlesim/background_r</span><br></pre></td></tr></table></figure>
<p><strong>rosparam set &amp; rosparam get</strong></p>
<p>这俩的用法都是后头加上 <code>[param_name]</code></p>
<p>比如使用如下命令修改背景颜色：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rosparam <span class="built_in">set</span> /turtlesim/background_r 150</span><br><span class="line">$ rosservice call /clear <span class="comment">#需要调用clear才能让参数的修改得以生效</span></span><br></pre></td></tr></table></figure>
<p>我们就会发现背景颜色变紫了~</p>
<p>然后我们可以使用 <code>get</code> 来获取其它参数的值，比如获取背景绿色通道的值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rosparam get /turtlesim/background_g</span><br><span class="line"></span><br><span class="line">86</span><br></pre></td></tr></table></figure>
<p>我们甚至还能用 <code>rosparam get /</code> 来显示参数服务器上的所有内容</p>
<p><strong>rosparam dump &amp; rosparam load</strong></p>
<p>这俩的用法都是在后头加上 <code>[file_name] [namespace]</code></p>
<p>比如，我们将所有的参数写入 <code>params.yaml</code> 文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rosparam dump params.yaml</span><br></pre></td></tr></table></figure>
<p>甚至可以将 <code>yaml</code> 文件重载入新的命令空间，比如 <code>copy_turtle</code>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ rosparam load params.yaml copy_turtle</span><br><span class="line">$ rosparam get /copy_turtle/turtlesim/background_b</span><br><span class="line"></span><br><span class="line">255</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="使用rqt-console和roslaunch"><a href="#使用rqt-console和roslaunch" class="headerlink" title="使用rqt_console和roslaunch"></a>使用rqt_console和roslaunch</h3><p><strong>rqt_console &amp; rqt_logger_level</strong></p>
<p>wiki告诉我们，<code>rqt_console</code> 连接到了ROS的日志框架，以显示节点的输出信息。<code>rqt_logger_level</code> 允许我们在节点运行时改变输出信息的详细级别。</p>
<p><code>rqt_logger_level</code>允许我们在节点运行时改变输出信息的详细级别，包括<code>Debug</code>、<code>Info</code>、<code>Warn</code> 和<code>Error</code>。</p>
<p><strong>日志记录器级别</strong></p>
<p>日志级别的优先级按以下顺序排列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fatal  Error  Warn  Info  Debug</span><br></pre></td></tr></table></figure>
<p>wiki告诉我们，通过设置日志级别，咱们可以获得所有优先级级别，或只是更高级别的消息。比如，将日志级别设为<code>Warn</code>时，咱会得到<code>Warn</code>、<code>Error</code>和<code>Fatal</code>这三个等级的日志消息。</p>
<p><strong>roslaunch</strong></p>
<p>这个命令可以用来启动定义在 <code>launch</code> 文件中的节点，用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ roslaunch [package] [filename.launch]</span><br></pre></td></tr></table></figure>
<p>wiki引导我们切换到我们之前的 <code>beginner_tutorials</code> 软件包目录下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ roscd beginner_tutorials</span><br></pre></td></tr></table></figure>
<p>继续创建一个 <code>launch</code> 目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> launch</span><br><span class="line">$ <span class="built_in">cd</span> launch</span><br></pre></td></tr></table></figure>
<p><strong>launch文件</strong></p>
<p>wiki让我们现在创建一个名为 <code>turtlemimic.launch</code> 的launch文件并复制粘贴这些东西进去：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> 1 <span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"> 2 # 首先用launch标签开头，以表明这是一个launch文件</span><br><span class="line"> </span><br><span class="line"> 3   <span class="tag">&lt;<span class="name">group</span> <span class="attr">ns</span>=<span class="string">&quot;turtlesim1&quot;</span>&gt;</span></span><br><span class="line"> 4     <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sim&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtlesim_node&quot;</span>/&gt;</span></span><br><span class="line"> 5   <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"> 6 </span><br><span class="line"> 7   <span class="tag">&lt;<span class="name">group</span> <span class="attr">ns</span>=<span class="string">&quot;turtlesim2&quot;</span>&gt;</span></span><br><span class="line"> 8     <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sim&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtlesim_node&quot;</span>/&gt;</span></span><br><span class="line"> 9   <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"> # 此处我们创建了两个分组，并以命名空间（namespace）标签来区分，其中一个名为turtulesim1，另一个名为turtlesim2，两个分组中都有相同的名为sim的turtlesim节点。这样可以让我们同时启动两个turtlesim模拟器，而不会产生命名冲突。</span><br><span class="line"> </span><br><span class="line">10 </span><br><span class="line">11   <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span> <span class="attr">name</span>=<span class="string">&quot;mimic&quot;</span> <span class="attr">type</span>=<span class="string">&quot;mimic&quot;</span>&gt;</span></span><br><span class="line">12     <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;input&quot;</span> <span class="attr">to</span>=<span class="string">&quot;turtlesim1/turtle1&quot;</span>/&gt;</span></span><br><span class="line">13     <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;output&quot;</span> <span class="attr">to</span>=<span class="string">&quot;turtlesim2/turtle1&quot;</span>/&gt;</span></span><br><span class="line">14   <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line">#在这里我们启动模仿节点，话题的输入和输出分别重命名为turtlesim1和turtlesim2，这样就可以让turtlesim2模仿turtlesim1了。</span><br><span class="line"></span><br><span class="line">15 </span><br><span class="line">16 <span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br><span class="line"># 这一行使得launch文件的XML标签闭合。</span><br></pre></td></tr></table></figure>
<p><strong>使用roslaunch</strong></p>
<p>咱们通过 <code>roslaunch</code> 命令来运行launch文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ roslaunch beginner_tutorials turtlemimic.launch</span><br></pre></td></tr></table></figure>
<p>现在将会有两个turtlesim被启动，然后我们在一个<strong>新</strong>终端中使用<code>rostopic</code>命令发送：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rostopic pub /turtlesim1/turtle1/cmd_vel geometry_msgs/Twist -r 1 -- <span class="string">&#x27;[2.0, 0.0, 0.0]&#x27;</span> <span class="string">&#x27;[0.0, 0.0, -1.8]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>诶，咱们就会惊奇地发现，咱们只让 <code>turtle1</code> 运动了，但是 <code>turtle2</code> 也跟随它一起运动了！</p>
<hr>
<h3 id="使用rosed在ROS中编辑文件"><a href="#使用rosed在ROS中编辑文件" class="headerlink" title="使用rosed在ROS中编辑文件"></a>使用rosed在ROS中编辑文件</h3><p><strong>rosed</strong></p>
<p>利用这个命令可以直接通过软件包名编辑包中文件，无需键入完整路径。</p>
<p>用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rosed [package_name] [filename]</span><br></pre></td></tr></table></figure>
<p><strong>Tab补全</strong></p>
<p>使用这个方法，在不知道准确文件名的情况下，也可以轻松地查看和编辑包中的所有文件，用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rosed [package_name] &lt;tab&gt;&lt;tab&gt;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ rosed roscpp &lt;tab&gt;&lt;tab&gt;</span><br><span class="line"></span><br><span class="line">Empty.srv                   roscpp.cmake</span><br><span class="line">genmsg_cpp.py               roscppConfig.cmake</span><br><span class="line">gensrv_cpp.py               roscppConfig-version.cmake</span><br><span class="line">GetLoggers.srv              roscpp-msg-extras.cmake</span><br><span class="line">Logger.msg                  roscpp-msg-paths.cmake</span><br><span class="line">msg_gen.py                  SetLoggerLevel.srv</span><br><span class="line">package.xml</span><br></pre></td></tr></table></figure>
<p><strong>编辑器</strong></p>
<p>rosed默认的编译器是vim~</p>
<hr>
<h3 id="创建ROS消息和服务"><a href="#创建ROS消息和服务" class="headerlink" title="创建ROS消息和服务"></a>创建ROS消息和服务</h3><p><strong>msg 和 srv</strong></p>
<ul>
<li><code>msg</code>：<code>msg</code> 文件是文本文件，用于描述ROS消息的字段。它们用于为不同编程语言编写的消息生成源代码。</li>
<li><code>srv</code>：一个 <code>srv</code> 文件描述一个服务。它由两部分组成：请求和响应。</li>
</ul>
<hr>
<h3 id="编写简单的发布者和订阅者-Python"><a href="#编写简单的发布者和订阅者-Python" class="headerlink" title="编写简单的发布者和订阅者 (Python)"></a>编写简单的发布者和订阅者 (Python)</h3><p><strong>编写发布者节点</strong></p>
<p>wiki告诉我们，<code>节点</code> 是连接到ROS网络的可执行文件。我们要创建 <code>talker</code> (发布者) 节点，该节点将不断广播消息。</p>
<p>跟着wiki上的步骤，先创建一个 <code>scripts</code> 目录来存放 <code>Python</code> 脚本，然后下载示例脚本 <code>talker.py</code> 放到 <code>scripts</code> 目录中并给执行权限；最后把相关内容添加到 <code>CMakeLists.txt</code> 里头，就能确保正确安装 <code>Python</code>脚本，并使用合适的 <code>Python</code> 解释器了~</p>
<p><strong>解释</strong></p>
<p>跟着wiki分解一下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># (每个Python ROS节点的最开头都有这个声明。第一行确保脚本作为Python脚本执行。)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"><span class="comment"># 如果要编写ROS节点，则需要导入rospy。std_msgs.msg的导入则是为了使我们能够重用std_msgs/String消息类型（即一个简单的字符串容器）来发布。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">talker</span>():</span><br><span class="line">    pub = rospy.Publisher(<span class="string">&#x27;chatter&#x27;</span>, String, queue_size=<span class="number">10</span>)</span><br><span class="line">    rospy.init_node(<span class="string">&#x27;talker&#x27;</span>, anonymous=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 这部分代码定义了talker与其他ROS部分的接口。pub = rospy.Publisher(&quot;chatter&quot;, String, queue_size=10)声明该节点正在使用String消息类型发布到chatter话题。这里的String实际上是std_msgs.msg.String类。queue_size参数是在ROS Hydro及更新版本中新增的，用于在订阅者接收消息的速度不够快的情况下，限制排队的消息数量。对于ROS Groovy及早期版本来说，只需省略即可。下一行的rospy.init_node(NAME, ...)非常重要，因为它把该节点的名称告诉了rospy——只有rospy掌握了这一信息后，才会开始与ROS主节点进行通信。在本例中，节点将使用talker名称。</span></span><br><span class="line">    </span><br><span class="line">    rate = rospy.Rate(<span class="number">10</span>) <span class="comment"># 10hz</span></span><br><span class="line">    <span class="comment"># 此行创建一个Rate对象rate。借助其方法sleep()，它提供了一种方便的方法，来以想要的速率循环。它的参数是10，即表示希望它每秒循环10次（只要我们的处理时间不超过十分之一秒）！</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> rospy.is_shutdown():</span><br><span class="line">        hello_str = <span class="string">&quot;hello world %s&quot;</span> % rospy.get_time()</span><br><span class="line">        rospy.loginfo(hello_str)</span><br><span class="line">        pub.publish(hello_str)</span><br><span class="line">        rate.sleep()</span><br><span class="line">    <span class="comment"># 这个循环是一个相当标准的rospy结构：检查rospy.is_shutdown()标志，然后执行代码逻辑。必须查看is_shutdown()以检查程序是否应该退出（例如有Ctrl+C或其他）。在本例中，代码逻辑即对public .publish(hello_str)的调用，它将一个字符串发布到chatter话题。循环的部分还调用了rate.sleep()，它在循环中可以用刚刚好的睡眠时间维持期望的速率。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        talker()</span><br><span class="line">    <span class="keyword">except</span> rospy.ROSInterruptException:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 除了标准的Python __main__检查，它还会捕获一个rospy.ROSInterruptException异常，当按下Ctrl+C或节点因其他原因关闭时，这一异常就会被rospy.sleep()和rospy.Rate.sleep()抛出。引发此异常的原因是不会意外地在sleep()之后继续执行代码。</span></span><br></pre></td></tr></table></figure>
<p><strong>编写订阅者节点</strong></p>
<p>继续跟着wiki，下载示例脚本 <code>listener.py</code> 放到 <code>scripts</code> 目录中并给执行权限，然后编辑<code>CMakeLists.txt</code> 中的 <code>catkin_install_python()</code> 调用。(此处省略命令和代码)</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rospy.init_node(<span class="string">&#x27;listener&#x27;</span>, anonymous=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">rospy.Subscriber(<span class="string">&#x27;chatter&#x27;</span>, String, callback)</span><br><span class="line"></span><br><span class="line"><span class="comment"># spin() simply keeps python from exiting until this node is stopped</span></span><br><span class="line">rospy.spin()</span><br></pre></td></tr></table></figure>
<p>wiki对这段代码的解释是：<em>这声明节点订阅了 <code>chatter</code> 话题，类型是 <code>std_msgs.msgs.String</code>。当接收到新消息时，<code>callback</code> 函数被调用，消息作为第一个参数。</em></p>
<p><em>我们还稍微更改了对<code>rospy.init_node()</code>的调用。我们添加了  <code>anonymous=True</code> 关键字参数。ROS要求每个节点都有一个唯一的名称，如果出现具有相同名称的节点，则会与前一个节点发生冲突，这样一来，出现故障的节点很容易地被踢出网络。<code>anonymous=True</code> 标志会告诉 <code>rospy</code> 为节点生成唯一的名称，这样就很容易可以有多个 <code>listener.py</code> 一起运行。</em></p>
<p><em>最后再补充一下，<code>rospy.spin()</code> 只是不让节点退出，直到节点被明确关闭。与 <code>roscpp</code> 不同，<code>rospy.spin()</code> 不影响订阅者回调函数，因为它们有自己的线程。</em></p>
<p><strong>构建节点</strong></p>
<p>咱们使用CMake作为构建系统，这是为了确保能为创建的<strong>消息</strong>和<strong>服务</strong>自动生成Python代码。</p>
<p>回到catkin工作空间，然后运行 <code>catkin_make</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">$ catkin_make</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="检验简单的发布者和订阅者"><a href="#检验简单的发布者和订阅者" class="headerlink" title="检验简单的发布者和订阅者"></a>检验简单的发布者和订阅者</h3><p><strong>运行发布者</strong></p>
<p>咱们运行刚才制作的叫做 <code>talker</code> 的发布者：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">rosrun beginner_tutorials talker.py</span><br><span class="line"></span><br><span class="line">[INFO] [1734609185.705253]: hello world 1734609185.7051988</span><br><span class="line">[INFO] [1734609185.806596]: hello world 1734609185.8064554</span><br><span class="line">[INFO] [1734609185.906493]: hello world 1734609185.9063175</span><br><span class="line">[INFO] [1734609186.005546]: hello world 1734609186.0053947</span><br><span class="line">[INFO] [1734609186.106381]: hello world 1734609186.1062553</span><br><span class="line">[INFO] [1734609186.206608]: hello world 1734609186.2064044</span><br><span class="line">[INFO] [1734609186.305868]: hello world 1734609186.3057268</span><br><span class="line">[INFO] [1734609186.406142]: hello world 1734609186.4059968</span><br><span class="line">[INFO] [1734609186.505583]: hello world 1734609186.5054214</span><br><span class="line">[INFO] [1734609186.606951]: hello world 1734609186.6068125</span><br><span class="line">[INFO] [1734609186.705764]: hello world 1734609186.7056243</span><br><span class="line">[INFO] [1734609186.805870]: hello world 1734609186.8057344</span><br><span class="line">[INFO] [1734609186.905890]: hello world 1734609186.9057145</span><br><span class="line">[INFO] [1734609187.006627]: hello world 1734609187.0064893</span><br></pre></td></tr></table></figure>
<p>wiki告诉我们，发布者节点已启动并运行。现在我们需要一个订阅者以接收来自发布者的消息。</p>
<p><strong>运行订阅者</strong></p>
<p>咱们运行刚才制作的叫做 <code>listener</code> 的订阅者：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ rosrun beginner_tutorials listener</span><br><span class="line"></span><br><span class="line">[INFO] [1734609563.673116]: /listener_14824_1734609563066I heard hello world 1734609563.671003</span><br><span class="line">[INFO] [1734609563.773131]: /listener_14824_1734609563066I heard hello world 1734609563.7711043</span><br><span class="line">[INFO] [1734609563.873401]: /listener_14824_1734609563066I heard hello world 1734609563.8712664</span><br><span class="line">[INFO] [1734609563.973288]: /listener_14824_1734609563066I heard hello world 1734609563.9714963</span><br><span class="line">[INFO] [1734609564.073304]: /listener_14824_1734609563066I heard hello world 1734609564.0710852</span><br><span class="line">[INFO] [1734609564.173103]: /listener_14824_1734609563066I heard hello world 1734609564.1708713</span><br><span class="line">[INFO] [1734609564.273282]: /listener_14824_1734609563066I heard hello world 1734609564.2709982</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="编写简单的服务器和客户端-Python"><a href="#编写简单的服务器和客户端-Python" class="headerlink" title="编写简单的服务器和客户端 (Python)"></a>编写简单的服务器和客户端 (Python)</h3><p><strong>编写服务节点</strong></p>
<p>跟着wiki的指引，我们将创建简单的服务节点 <code>add_two_ints_server</code>，该节点将接收两个整数，并返回它们的和。</p>
<p><strong>代码</strong></p>
<p>在beginner_tutorials包中创建 <code>scripts/add_two_ints_server.py</code> 文件并粘贴以下内容进去：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> beginner_tutorials.srv <span class="keyword">import</span> AddTwoInts,AddTwoIntsResponse</span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_add_two_ints</span>(<span class="params">req</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Returning [%s + %s = %s]&quot;</span>%(req.a, req.b, (req.a + req.b)))</span><br><span class="line">    <span class="keyword">return</span> AddTwoIntsResponse(req.a + req.b)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_two_ints_server</span>():</span><br><span class="line">    rospy.init_node(<span class="string">&#x27;add_two_ints_server&#x27;</span>)</span><br><span class="line">    s = rospy.Service(<span class="string">&#x27;add_two_ints&#x27;</span>, AddTwoInts, handle_add_two_ints)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Ready to add two ints.&quot;</span>)</span><br><span class="line">    rospy.spin()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    add_two_ints_server()</span><br></pre></td></tr></table></figure>
<p><strong>解释</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = rospy.Service(<span class="string">&#x27;add_two_ints&#x27;</span>, AddTwoInts, handle_add_two_ints)</span><br></pre></td></tr></table></figure>
<p>wiki告诉我们：<em>这声明了一个名为 <code>add_two_ints</code> 的新服务，其服务类型为 <code>AddTwoInts</code>。所有的请求（request）都传递给了 <code>handle_add_two_ints</code> 函数。<code>handle_add_two_ints</code> 被 <code>AddTwoIntsRequest</code> 的实例调用，返回 <code>AddTwoIntsResponse</code> 实例。</em></p>
<p><em>就像订阅者中的例子一样，<code>rospy.spin()</code> 可以防止代码在服务关闭之前退出。</em></p>
<p><strong>编写客户端节点</strong></p>
<p><strong>代码</strong></p>
<p>继续跟随wiki指引，在 <code>beginner_tutorials</code> 包中创建 <code>scripts/add_two_ints_client.py</code>文件并粘贴以下内容进去：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> beginner_tutorials.srv <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_two_ints_client</span>(<span class="params">x, y</span>):</span><br><span class="line">    rospy.wait_for_service(<span class="string">&#x27;add_two_ints&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        add_two_ints = rospy.ServiceProxy(<span class="string">&#x27;add_two_ints&#x27;</span>, AddTwoInts)</span><br><span class="line">        resp1 = add_two_ints(x, y)</span><br><span class="line">        <span class="keyword">return</span> resp1.<span class="built_in">sum</span></span><br><span class="line">    <span class="keyword">except</span> rospy.ServiceException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Service call failed: %s&quot;</span>%e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">usage</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;%s [x y]&quot;</span>%sys.argv[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) == <span class="number">3</span>:</span><br><span class="line">        x = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line">        y = <span class="built_in">int</span>(sys.argv[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(usage())</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Requesting %s+%s&quot;</span>%(x, y))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s + %s = %s&quot;</span>%(x, y, add_two_ints_client(x, y)))</span><br></pre></td></tr></table></figure>
<p><strong>解释</strong></p>
<p>wiki的解释如下：</p>
<p><em>客户端（用来调用服务）的代码也很简单。对于客户端来说不需要调用<code>init_node()</code>。我们首先调用：</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rospy.wait_for_service(&#x27;add_two_ints&#x27;)</span><br></pre></td></tr></table></figure>
<p><em>这是一种很方便的方法，可以让在<code>add_two_ints</code>服务可用之前一直阻塞。</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_two_ints = rospy.ServiceProxy(&#x27;add_two_ints&#x27;, AddTwoInts)</span><br></pre></td></tr></table></figure>
<p><em>这里我们为服务的调用创建了一个句柄（handle）。</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resp1 = add_two_ints(x, y)</span><br><span class="line">return resp1.sum</span><br></pre></td></tr></table></figure>
<p><em>然后我们可以使用这个句柄，就像普通的函数一样调用它。</em></p>
<p><em>因为我们已经将服务的类型声明为 <code>AddTwoInts</code>，它会生成 <code>AddTwoIntsRequest</code> 对象 (you’re free to pass in your own instead)。如果调用失败，<code>rospy.ServiceException</code>将会抛出，所以应该弄一个合适的 <code>try/except</code> 部分。</em></p>
<p><strong>构建节点</strong></p>
<p>继续使用CMake作为构建系统，跟前面一模一样，不再赘述~</p>
<hr>
<h3 id="检验简单的服务和客户端"><a href="#检验简单的服务和客户端" class="headerlink" title="检验简单的服务和客户端"></a>检验简单的服务和客户端</h3><p><strong>运行服务</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rosrun beginner_tutorials add_two_ints_server,py</span><br><span class="line"></span><br><span class="line">Ready to add two ints.</span><br></pre></td></tr></table></figure>
<p><strong>运行客户端</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ rosrun beginner_tutorials add_two_ints_client.py 1 3</span><br><span class="line"></span><br><span class="line">Requesting 1+3</span><br><span class="line">1 + 3 = 4</span><br></pre></td></tr></table></figure>
<p>至此，成功地运行了第一个服务和客户端~</p>
<hr>
<h3 id="录制和回放数据"><a href="#录制和回放数据" class="headerlink" title="录制和回放数据"></a>录制和回放数据</h3><p><strong>录制数据 (创建bag文件) </strong></p>
<p>wiki告诉我们，这一部分将指导咱如何从正在运行的ROS系统中记录话题数据，话题数据将被积累到一个 <code>bag</code> 文件中。</p>
<p>咱打开三个新终端，分别输入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ roscore</span><br><span class="line"></span><br><span class="line">$ rosrun turtlesim turtlesim_node</span><br><span class="line"></span><br><span class="line">$ rosrun turtlesim turtle_teleop_key</span><br></pre></td></tr></table></figure>
<p>这三个命令就是咱之前用来控制小乌龟运动的命令。</p>
<p><strong>录制所有发布的话题</strong></p>
<p>咱们打开一个新终端：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> ~/bagfiles</span><br><span class="line">$ <span class="built_in">cd</span> ~/bagfiles</span><br><span class="line">$ rosbag record -a</span><br></pre></td></tr></table></figure>
<p>wiki告诉我们，这里我们只是创建了一个临时目录来记录数据，然后运行 <code>rosbag record</code> 带选项 <code>-a</code>，表明所有发布的话题都应该积累在一个 <code>bag</code> 文件中。</p>
<p>咱们回到 <code>turtle_teleop</code> 节点所在的终端窗口，控制乌龟移动10秒左右。然后咱在运行 <code>rosbag record</code> 的窗口中按 <code>Ctrl + C</code> 退出，然后查看 <code>~/bagfiles</code> 里的内容，咱们就能发现一个以<strong>年份、日期和时间</strong>开头，并且扩展名是 <code>.bag</code> 的文件，这就是咱们所说的袋文件，它包含 <code>rosbag record</code> 运行期间由任何节点发布的所有话题。</p>
<p><strong>检查并回放bag文件</strong></p>
<p>刚才咱已经使用 <code>rosbag record</code> 命令录制了一个 <code>bag</code> 文件，接下来我们可以使用 <code>rosbag info</code> 查看它的内容，或者使用 <code>rosbag play</code> 命令回放。</p>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rosbag info &lt;your bagfile&gt;</span><br></pre></td></tr></table></figure>
<p>用观察大法知，这些信息告诉了咱 <code>bag</code> 文件中所包含话题的名称、类型和消息数量。</p>
<p>下一步咱们回放 <code>bag</code> 文件以再现系统运行过程。首先用<code>Ctrl+C</code>杀死之前运行的 <code>turtle_teleop_key</code> ，但让 <code>turtlesim</code> 继续运行。在终端中 <code>bag</code> 文件所在目录下运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rosbag play &lt;your bagfile&gt;</span><br></pre></td></tr></table></figure>
<p>wiki上写到：<em>默认模式下，<strong>rosbag play</strong>命令在公告每条消息后会等待一小段时间（0.2秒）才真正开始发布bag文件中的内容。等待一段时间是为了可以通知订阅者，消息已经公告且数据可能会马上到来。如果<strong>rosbag play</strong>在公告消息后立即发布，订阅者可能会接收不到几条最先发布的消息。等待时间可以通过 <code>-d</code> 选项来指定。</em></p>
<p><em>最终 <code>/turtle1/cmd_vel</code> 话题将会被发布，同时在turtuelsim中乌龟应该会像之前用turtle_teleop_key控制它那样开始移动。从运行<strong>rosbag play</strong>到乌龟开始移动时所经历时间应该近似等于之前在本教程开始部分运行<strong>rosbag record</strong>后到开始按下键盘发出控制命令时所经历时间。</em></p>
<p><strong>录制数据子集</strong></p>
<p>wiki告诉我们，当运行一个复杂的系统时，比如 <code>PR2</code> 软件套装，会有几百个话题被发布，有些话题亦会发布大量数据（比如包含摄像头图像流的话题）。在这种系统中，将包含所有话题的日志写入一个bag文件到磁盘通常是不切实际的。<strong>rosbag record</strong>命令支持只录制特定的话题到bag文件中，这样就可以只录制用户感兴趣的话题。</p>
<p>在bag文件所在目录下执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rosbag record -O subset /turtle1/cmd_vel /turtle1/pose</span><br></pre></td></tr></table></figure>
<p>上述命令中的 <code>-O</code> 参数告诉 <code>rosbag record</code> 将数据记录到名为 <code>subset.bag</code> 的文件中，而后面的 <code>topic</code> 参数告诉<code>rosbag record</code>只能订阅这两个指定的话题。然后通过键盘控制乌龟随意移动几秒钟，最后按 <code>Ctrl+C</code> 退出 <code>rosbag record</code> 命令。</p>
<p>现在看看bag文件中的内容（<code>rosbag info subset.bag</code>），里面就只包含指定的话题了~</p>
<p><strong>rosbag 录制和回放的局限性</strong></p>
<p>仔细观察发现，乌龟的路径可能并没有完全地映射到原先通过键盘控制时产生的路径上——整体形状应该是差不多的，但没有完全一样。wiki告诉我们，<em>这是因为 <code>turtlesim</code> 的移动路径对系统定时精度的变化非常敏感。<code>rosbag</code> 受制于其本身的性能无法完全复制录制时的系统运行行为，<code>rosplay</code> 也一样。对于像 <code>turtlesim</code> 这样的节点，当处理消息的过程中系统定时发生极小变化时也会使其行为发生微妙变化，用户不应该期望能够完美地模仿系统行为。</em></p>
<hr>
<h3 id="从bag文件中读取信息"><a href="#从bag文件中读取信息" class="headerlink" title="从bag文件中读取信息"></a>从bag文件中读取信息</h3><p><strong>立即回放信息并在多个终端中查看输出</strong></p>
<p>在终端里头使用下面这个命令，来手动检查所有已经发布的话题，以及向每个话题发布了多少信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ time rosbag info demo.bag</span><br><span class="line"><span class="comment"># 或者已经知道话题名称的话：</span></span><br><span class="line">$ time rosbag info mybag.bag | grep -E <span class="string">&quot;(topic1|topic2|topic3)&quot;</span></span><br></pre></td></tr></table></figure>
<p>咱们就能看到有多少条消息发布在什么话题上了~</p>
<p>有30条消息发布在 <code>/obs1/gps/fix</code> 话题上，有40条消息发布在 <code>/diagnostics_agg</code> 话题上。</p>
<p>跟着wiki，咱们还是先运行 <code>roscore</code> ，然后订阅 <code>/obs1/gps/fix</code> 话题并复读该话题发布的所有内容，同时用tee命令转储到一个 <code>yaml</code> 格式的文件中以遍之后查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rostopic <span class="built_in">echo</span> /obs1/gps/fix | <span class="built_in">tee</span> topic1.yaml</span><br></pre></td></tr></table></figure>
<p>再打开一个新终端，订阅另一个话题 <code>/diagnostics_agg</code>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rostopic <span class="built_in">echo</span> /diagnostics_agg | <span class="built_in">tee</span> topic2.yaml</span><br></pre></td></tr></table></figure>
<p>然后咱们还得再打开另一个新终端来回放 <code>bag</code> 文件。这一次我们将尽可能快地回放 <code>bag</code> 文件（使用 <code>--immediate</code> 选项），<strong>只</strong>会发布我们感兴趣的话题。格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time rosbag play --immediate demo.bag --topics /obs1/gps/fix /diagnostics_agg</span><br></pre></td></tr></table></figure>
<p>现在看一下咱的两个终端，每个终端都订阅了一个话题，每个话题类型的所有消息都用 <code>YAML</code> 格式输出，每条消息之间用 <code>---</code> 分割。咱们用任意文本编辑器（我用的 <code>vscode</code>）就能查看文件中的消息了~</p>
<p><strong>使用 ros_readbagfile 脚本提取感兴趣的话题</strong></p>
<p>下载并安装 <code>ros_readbag.py</code> :</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Download the file</span></span><br><span class="line">wget https://raw.githubusercontent.com/ElectricRCAircraftGuy/eRCaGuy_dotfiles/master/useful_scripts/ros_readbagfile.py</span><br><span class="line"><span class="comment"># Make it executable</span></span><br><span class="line"><span class="built_in">chmod</span> +x ros_readbagfile.py</span><br><span class="line"><span class="comment"># Ensure you have the ~/bin directory for personal binaries</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/bin</span><br><span class="line"><span class="comment"># Move this executable script into that directory as `ros_readbagfile`, so that it will</span></span><br><span class="line"><span class="comment"># be available as that command</span></span><br><span class="line"><span class="built_in">mv</span> ros_readbagfile.py ~/bin/ros_readbagfile</span><br><span class="line"><span class="comment"># Re-source your ~/.bashrc file to ensure ~/bin is in your PATH, so you can use this</span></span><br><span class="line"><span class="comment"># new `ros_readbagfile` command you just installed</span></span><br><span class="line">. ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>先通过 <code>rosbag info</code> 命令确定要从bag文件中读取的<strong>准确</strong>话题名，然后使用 <code>ros_readbagfile</code> ，格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ros_readbagfile &lt;mybagfile.bag&gt; [topic1] [topic2] [topic3] [...]</span><br></pre></td></tr></table></figure>
<p>要阅读信息，就输入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ time ros_readbagfile demo.bag /obs1/gps/fix /diagnostics_agg | <span class="built_in">tee</span> topics.yaml</span><br></pre></td></tr></table></figure>
<p>这样之后，咱们就能看到它快速打印出来了所有信息~</p>
<p>咱们用任意文本编辑器 (我用的vim) 来打开 <code>topics.yaml</code> ，就能看到它从 <code>bag</code> 文件中提取的所有信息了~</p>
<hr>
<h3 id="roswtf入门"><a href="#roswtf入门" class="headerlink" title="roswtf入门"></a>roswtf入门</h3><p>首先咱们要确保 <code>roscore</code> 没有运行</p>
<p><strong>安装检查</strong></p>
<p>这个命令可以检查我的系统，并且尝试发现问题，咱们输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ roscd rosmaster</span><br><span class="line">$ roswtf</span><br><span class="line"></span><br><span class="line">Package: rosmaster <span class="comment"># roswtf使用当前目录中的任何内容来确定其执行的检查。这个输出告诉我们是在包rosmaster的目录中启动了roswtf。</span></span><br><span class="line">================================================================================</span><br><span class="line">Static checks summary: <span class="comment"># 它会报告任何关于文件系统或非运行时（比如无需roscore的场景）的问题。本例显示我们没有错误。</span></span><br><span class="line"></span><br><span class="line">No errors or warnings</span><br><span class="line">================================================================================</span><br><span class="line"></span><br><span class="line">ROS Master does not appear to be running. <span class="comment"># roscore未在运行。roswtf不会做任何ROS在线检查。</span></span><br><span class="line">Online graph checks will not be run.</span><br><span class="line">ROS_MASTER_URI is [http://localhost:11311]</span><br></pre></td></tr></table></figure>
<p><strong>在线检查</strong></p>
<p>依照wiki，接下来咱们要启动一个 <code>Master</code> ，在新终端启动 <code>roscore</code> ，然后继续</p>
<p>现在咱们按照相同的顺序运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ roscd</span><br><span class="line">$ roswtf</span><br><span class="line"></span><br><span class="line">No package or stack <span class="keyword">in</span> context</span><br><span class="line">======================================================</span><br><span class="line">Static checks summary:</span><br><span class="line"></span><br><span class="line">No errors or warnings</span><br><span class="line">======================================================</span><br><span class="line">Beginning tests of your ROS graph. These may take awhile...</span><br><span class="line">analyzing graph...</span><br><span class="line">... <span class="keyword">done</span> analyzing graph</span><br><span class="line">running graph rules...</span><br><span class="line">... <span class="keyword">done</span> running graph rules</span><br><span class="line"></span><br><span class="line">Online checks summary:</span><br><span class="line"></span><br><span class="line">Found 1 warning(s).</span><br><span class="line">Warnings are things that may be just fine, but are sometimes at fault</span><br><span class="line"></span><br><span class="line">WARNING The following node subscriptions are unconnected:</span><br><span class="line"> * /rosout:</span><br><span class="line">   * /rosout</span><br></pre></td></tr></table></figure>
<p>显然，在输出末尾， <code>roswtf</code> 发出了警告，<code>rosout</code> 节点订阅了一个没有节点向其发布的话题。wiki告诉我们，在本例中，这正是所期望看到的，因为除了 <code>roscore</code> 没有任何其它节点在运行，所以我们就可以忽略这个警告了~</p>
<p><strong>错误</strong></p>
<p>wiki告诉我们， <code>roswtf</code> <em>会对一些系统中看起来异常但可能是正常的运行情况发出警告。也会对确实有问题的情况报告错误。</em></p>
<p>接下来按照wiki的步骤，给 <code>ROS_PACKAGE_PATH</code> 环境变量设置一个 <code>bad</code> 值，并退出 <code>roscore</code> 以简化检查输出信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ roscd</span><br><span class="line">$ ROS_PACKAGE_PATH=bad:<span class="variable">$ROS_PACKAGE_PATH</span> roswtf</span><br><span class="line"></span><br><span class="line">Stack: ros</span><br><span class="line">================================================================================</span><br><span class="line">Static checks summary:</span><br><span class="line"></span><br><span class="line">Found 1 error(s).</span><br><span class="line"></span><br><span class="line">ERROR Not all paths <span class="keyword">in</span> ROS_PACKAGE_PATH [bad] point to an existing directory: </span><br><span class="line"> * bad</span><br><span class="line"></span><br><span class="line">================================================================================</span><br><span class="line"></span><br><span class="line">Cannot communicate with master, ignoring graph checks</span><br></pre></td></tr></table></figure>
<p>显然，<code>roswtf</code> 发现了一个有关 <code>ROS_PACKAGE_PATH</code> 设置的错误。</p>
<p><code>roswtf</code> 还可以发现很多其它类型的问题。如果发现自己被构建或通信的问题难住了，可以尝试运行<code>roswtf</code>看能否指明正确的方向。</p>
<hr>
<p>至此，ROS 1学习结束~</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>Insist on writing original high-quality articles. Your support is my biggest motivation.</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="Sam 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="Sam 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/ROS/" rel="tag"># ROS</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/11/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80/" rel="prev" title="面向对象语言">
      <i class="fa fa-chevron-left"></i> 面向对象语言
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/11/25/Git%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/" rel="next" title="Git初步学习">
      Git初步学习 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#ROS-1"><span class="nav-number">1.</span> <span class="nav-text">ROS 1</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ROS1-%E5%88%9D%E7%BA%A7%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0"><span class="nav-number">1.1.</span> <span class="nav-text">ROS1 初级教程学习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ROS-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%A7%88"><span class="nav-number">1.1.1.</span> <span class="nav-text">ROS 文件系统导览</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAROS%E8%BD%AF%E4%BB%B6%E5%8C%85"><span class="nav-number">1.1.2.</span> <span class="nav-text">创建ROS软件包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E5%BB%BAROS%E8%BD%AF%E4%BB%B6%E5%8C%85"><span class="nav-number">1.1.3.</span> <span class="nav-text">构建ROS软件包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%A7%A3ROS%E8%8A%82%E7%82%B9"><span class="nav-number">1.1.4.</span> <span class="nav-text">理解ROS节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%A7%A3ROS%E8%AF%9D%E9%A2%98"><span class="nav-number">1.1.5.</span> <span class="nav-text">理解ROS话题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%A7%A3ROS%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%8F%82%E6%95%B0"><span class="nav-number">1.1.6.</span> <span class="nav-text">理解ROS服务和参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8rqt-console%E5%92%8Croslaunch"><span class="nav-number">1.1.7.</span> <span class="nav-text">使用rqt_console和roslaunch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8rosed%E5%9C%A8ROS%E4%B8%AD%E7%BC%96%E8%BE%91%E6%96%87%E4%BB%B6"><span class="nav-number">1.1.8.</span> <span class="nav-text">使用rosed在ROS中编辑文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAROS%E6%B6%88%E6%81%AF%E5%92%8C%E6%9C%8D%E5%8A%A1"><span class="nav-number">1.1.9.</span> <span class="nav-text">创建ROS消息和服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E5%B8%83%E8%80%85%E5%92%8C%E8%AE%A2%E9%98%85%E8%80%85-Python"><span class="nav-number">1.1.10.</span> <span class="nav-text">编写简单的发布者和订阅者 (Python)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E9%AA%8C%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E5%B8%83%E8%80%85%E5%92%8C%E8%AE%A2%E9%98%85%E8%80%85"><span class="nav-number">1.1.11.</span> <span class="nav-text">检验简单的发布者和订阅者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF-Python"><span class="nav-number">1.1.12.</span> <span class="nav-text">编写简单的服务器和客户端 (Python)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E9%AA%8C%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">1.1.13.</span> <span class="nav-text">检验简单的服务和客户端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%95%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%BE%E6%95%B0%E6%8D%AE"><span class="nav-number">1.1.14.</span> <span class="nav-text">录制和回放数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8Ebag%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%BB%E5%8F%96%E4%BF%A1%E6%81%AF"><span class="nav-number">1.1.15.</span> <span class="nav-text">从bag文件中读取信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#roswtf%E5%85%A5%E9%97%A8"><span class="nav-number">1.1.16.</span> <span class="nav-text">roswtf入门</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Sam"
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name">Sam</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/shuai-xiao-ji-65" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;shuai-xiao-ji-65" rel="noopener" target="_blank"><i class="fab fa-zhihu fa-fw"></i>Zhihu</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/JiJiwjz" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;JiJiwjz" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/weijiazhe123.mail.nwpu.edu.cn" title="E-Mail → weijiazhe123.mail.nwpu.edu.cn"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sam</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
